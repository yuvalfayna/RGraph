{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst util_1 = require(\"./util\");\nconst utils_1 = require(\"../utils\");\nconst Redis_1 = require(\"../Redis\");\nconst debug = (0, utils_1.Debug)(\"cluster:subscriber\");\nclass ClusterSubscriber {\n  constructor(connectionPool, emitter) {\n    this.connectionPool = connectionPool;\n    this.emitter = emitter;\n    this.started = false;\n    this.subscriber = null;\n    this.onSubscriberEnd = () => {\n      if (!this.started) {\n        debug(\"subscriber has disconnected, but ClusterSubscriber is not started, so not reconnecting.\");\n        return;\n      }\n      // If the subscriber closes whilst it's still the active connection,\n      // we might as well try to connecting to a new node if possible to\n      // minimise the number of missed publishes.\n      debug(\"subscriber has disconnected, selecting a new one...\");\n      this.selectSubscriber();\n    };\n    // If the current node we're using as the subscriber disappears\n    // from the node pool for some reason, we will select a new one\n    // to connect to.\n    // Note that this event is only triggered if the connection to\n    // the node has been used; cluster subscriptions are setup with\n    // lazyConnect = true. It's possible for the subscriber node to\n    // disappear without this method being called!\n    // See https://github.com/luin/ioredis/pull/1589\n    this.connectionPool.on(\"-node\", (_, key) => {\n      if (!this.started || !this.subscriber) {\n        return;\n      }\n      if ((0, util_1.getNodeKey)(this.subscriber.options) === key) {\n        debug(\"subscriber has left, selecting a new one...\");\n        this.selectSubscriber();\n      }\n    });\n    this.connectionPool.on(\"+node\", () => {\n      if (!this.started || this.subscriber) {\n        return;\n      }\n      debug(\"a new node is discovered and there is no subscriber, selecting a new one...\");\n      this.selectSubscriber();\n    });\n  }\n  getInstance() {\n    return this.subscriber;\n  }\n  start() {\n    this.started = true;\n    this.selectSubscriber();\n    debug(\"started\");\n  }\n  stop() {\n    this.started = false;\n    if (this.subscriber) {\n      this.subscriber.disconnect();\n      this.subscriber = null;\n    }\n    debug(\"stopped\");\n  }\n  selectSubscriber() {\n    const lastActiveSubscriber = this.lastActiveSubscriber;\n    // Disconnect the previous subscriber even if there\n    // will not be a new one.\n    if (lastActiveSubscriber) {\n      lastActiveSubscriber.off(\"end\", this.onSubscriberEnd);\n      lastActiveSubscriber.disconnect();\n    }\n    if (this.subscriber) {\n      this.subscriber.off(\"end\", this.onSubscriberEnd);\n      this.subscriber.disconnect();\n    }\n    const sampleNode = (0, utils_1.sample)(this.connectionPool.getNodes());\n    if (!sampleNode) {\n      debug(\"selecting subscriber failed since there is no node discovered in the cluster yet\");\n      this.subscriber = null;\n      return;\n    }\n    const {\n      options\n    } = sampleNode;\n    debug(\"selected a subscriber %s:%s\", options.host, options.port);\n    /*\n     * Create a specialized Redis connection for the subscription.\n     * Note that auto reconnection is enabled here.\n     *\n     * `enableReadyCheck` is also enabled because although subscription is allowed\n     * while redis is loading data from the disk, we can check if the password\n     * provided for the subscriber is correct, and if not, the current subscriber\n     * will be disconnected and a new subscriber will be selected.\n     */\n    this.subscriber = new Redis_1.default({\n      port: options.port,\n      host: options.host,\n      username: options.username,\n      password: options.password,\n      enableReadyCheck: true,\n      connectionName: (0, util_1.getConnectionName)(\"subscriber\", options.connectionName),\n      lazyConnect: true,\n      tls: options.tls,\n      // Don't try to reconnect the subscriber connection. If the connection fails\n      // we will get an end event (handled below), at which point we'll pick a new\n      // node from the pool and try to connect to that as the subscriber connection.\n      retryStrategy: null\n    });\n    // Ignore the errors since they're handled in the connection pool.\n    this.subscriber.on(\"error\", utils_1.noop);\n    // The node we lost connection to may not come back up in a\n    // reasonable amount of time (e.g. a slave that's taken down\n    // for maintainence), we could potentially miss many published\n    // messages so we should reconnect as quickly as possible, to\n    // a different node if needed.\n    this.subscriber.once(\"end\", this.onSubscriberEnd);\n    // Re-subscribe previous channels\n    const previousChannels = {\n      subscribe: [],\n      psubscribe: [],\n      ssubscribe: []\n    };\n    if (lastActiveSubscriber) {\n      const condition = lastActiveSubscriber.condition || lastActiveSubscriber.prevCondition;\n      if (condition && condition.subscriber) {\n        previousChannels.subscribe = condition.subscriber.channels(\"subscribe\");\n        previousChannels.psubscribe = condition.subscriber.channels(\"psubscribe\");\n        previousChannels.ssubscribe = condition.subscriber.channels(\"ssubscribe\");\n      }\n    }\n    if (previousChannels.subscribe.length || previousChannels.psubscribe.length || previousChannels.ssubscribe.length) {\n      let pending = 0;\n      for (const type of [\"subscribe\", \"psubscribe\", \"ssubscribe\"]) {\n        const channels = previousChannels[type];\n        if (channels.length) {\n          pending += 1;\n          debug(\"%s %d channels\", type, channels.length);\n          this.subscriber[type](channels).then(() => {\n            if (! --pending) {\n              this.lastActiveSubscriber = this.subscriber;\n            }\n          }).catch(() => {\n            // TODO: should probably disconnect the subscriber and try again.\n            debug(\"failed to %s %d channels\", type, channels.length);\n          });\n        }\n      }\n    } else {\n      this.lastActiveSubscriber = this.subscriber;\n    }\n    for (const event of [\"message\", \"messageBuffer\", \"smessage\", \"smessageBuffer\"]) {\n      this.subscriber.on(event, (arg1, arg2) => {\n        this.emitter.emit(event, arg1, arg2);\n      });\n    }\n    for (const event of [\"pmessage\", \"pmessageBuffer\"]) {\n      this.subscriber.on(event, (arg1, arg2, arg3) => {\n        this.emitter.emit(event, arg1, arg2, arg3);\n      });\n    }\n  }\n}\nexports.default = ClusterSubscriber;","map":{"version":3,"names":["Object","defineProperty","exports","value","util_1","require","utils_1","Redis_1","debug","Debug","ClusterSubscriber","constructor","connectionPool","emitter","started","subscriber","onSubscriberEnd","selectSubscriber","on","_","key","getNodeKey","options","getInstance","start","stop","disconnect","lastActiveSubscriber","off","sampleNode","sample","getNodes","host","port","default","username","password","enableReadyCheck","connectionName","getConnectionName","lazyConnect","tls","retryStrategy","noop","once","previousChannels","subscribe","psubscribe","ssubscribe","condition","prevCondition","channels","length","pending","type","then","catch","event","arg1","arg2","emit","arg3"],"sources":["C:/rgraph/node_modules/ioredis/built/cluster/ClusterSubscriber.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst util_1 = require(\"./util\");\nconst utils_1 = require(\"../utils\");\nconst Redis_1 = require(\"../Redis\");\nconst debug = (0, utils_1.Debug)(\"cluster:subscriber\");\nclass ClusterSubscriber {\n    constructor(connectionPool, emitter) {\n        this.connectionPool = connectionPool;\n        this.emitter = emitter;\n        this.started = false;\n        this.subscriber = null;\n        this.onSubscriberEnd = () => {\n            if (!this.started) {\n                debug(\"subscriber has disconnected, but ClusterSubscriber is not started, so not reconnecting.\");\n                return;\n            }\n            // If the subscriber closes whilst it's still the active connection,\n            // we might as well try to connecting to a new node if possible to\n            // minimise the number of missed publishes.\n            debug(\"subscriber has disconnected, selecting a new one...\");\n            this.selectSubscriber();\n        };\n        // If the current node we're using as the subscriber disappears\n        // from the node pool for some reason, we will select a new one\n        // to connect to.\n        // Note that this event is only triggered if the connection to\n        // the node has been used; cluster subscriptions are setup with\n        // lazyConnect = true. It's possible for the subscriber node to\n        // disappear without this method being called!\n        // See https://github.com/luin/ioredis/pull/1589\n        this.connectionPool.on(\"-node\", (_, key) => {\n            if (!this.started || !this.subscriber) {\n                return;\n            }\n            if ((0, util_1.getNodeKey)(this.subscriber.options) === key) {\n                debug(\"subscriber has left, selecting a new one...\");\n                this.selectSubscriber();\n            }\n        });\n        this.connectionPool.on(\"+node\", () => {\n            if (!this.started || this.subscriber) {\n                return;\n            }\n            debug(\"a new node is discovered and there is no subscriber, selecting a new one...\");\n            this.selectSubscriber();\n        });\n    }\n    getInstance() {\n        return this.subscriber;\n    }\n    start() {\n        this.started = true;\n        this.selectSubscriber();\n        debug(\"started\");\n    }\n    stop() {\n        this.started = false;\n        if (this.subscriber) {\n            this.subscriber.disconnect();\n            this.subscriber = null;\n        }\n        debug(\"stopped\");\n    }\n    selectSubscriber() {\n        const lastActiveSubscriber = this.lastActiveSubscriber;\n        // Disconnect the previous subscriber even if there\n        // will not be a new one.\n        if (lastActiveSubscriber) {\n            lastActiveSubscriber.off(\"end\", this.onSubscriberEnd);\n            lastActiveSubscriber.disconnect();\n        }\n        if (this.subscriber) {\n            this.subscriber.off(\"end\", this.onSubscriberEnd);\n            this.subscriber.disconnect();\n        }\n        const sampleNode = (0, utils_1.sample)(this.connectionPool.getNodes());\n        if (!sampleNode) {\n            debug(\"selecting subscriber failed since there is no node discovered in the cluster yet\");\n            this.subscriber = null;\n            return;\n        }\n        const { options } = sampleNode;\n        debug(\"selected a subscriber %s:%s\", options.host, options.port);\n        /*\n         * Create a specialized Redis connection for the subscription.\n         * Note that auto reconnection is enabled here.\n         *\n         * `enableReadyCheck` is also enabled because although subscription is allowed\n         * while redis is loading data from the disk, we can check if the password\n         * provided for the subscriber is correct, and if not, the current subscriber\n         * will be disconnected and a new subscriber will be selected.\n         */\n        this.subscriber = new Redis_1.default({\n            port: options.port,\n            host: options.host,\n            username: options.username,\n            password: options.password,\n            enableReadyCheck: true,\n            connectionName: (0, util_1.getConnectionName)(\"subscriber\", options.connectionName),\n            lazyConnect: true,\n            tls: options.tls,\n            // Don't try to reconnect the subscriber connection. If the connection fails\n            // we will get an end event (handled below), at which point we'll pick a new\n            // node from the pool and try to connect to that as the subscriber connection.\n            retryStrategy: null,\n        });\n        // Ignore the errors since they're handled in the connection pool.\n        this.subscriber.on(\"error\", utils_1.noop);\n        // The node we lost connection to may not come back up in a\n        // reasonable amount of time (e.g. a slave that's taken down\n        // for maintainence), we could potentially miss many published\n        // messages so we should reconnect as quickly as possible, to\n        // a different node if needed.\n        this.subscriber.once(\"end\", this.onSubscriberEnd);\n        // Re-subscribe previous channels\n        const previousChannels = { subscribe: [], psubscribe: [], ssubscribe: [] };\n        if (lastActiveSubscriber) {\n            const condition = lastActiveSubscriber.condition || lastActiveSubscriber.prevCondition;\n            if (condition && condition.subscriber) {\n                previousChannels.subscribe = condition.subscriber.channels(\"subscribe\");\n                previousChannels.psubscribe =\n                    condition.subscriber.channels(\"psubscribe\");\n                previousChannels.ssubscribe =\n                    condition.subscriber.channels(\"ssubscribe\");\n            }\n        }\n        if (previousChannels.subscribe.length ||\n            previousChannels.psubscribe.length ||\n            previousChannels.ssubscribe.length) {\n            let pending = 0;\n            for (const type of [\"subscribe\", \"psubscribe\", \"ssubscribe\"]) {\n                const channels = previousChannels[type];\n                if (channels.length) {\n                    pending += 1;\n                    debug(\"%s %d channels\", type, channels.length);\n                    this.subscriber[type](channels)\n                        .then(() => {\n                        if (!--pending) {\n                            this.lastActiveSubscriber = this.subscriber;\n                        }\n                    })\n                        .catch(() => {\n                        // TODO: should probably disconnect the subscriber and try again.\n                        debug(\"failed to %s %d channels\", type, channels.length);\n                    });\n                }\n            }\n        }\n        else {\n            this.lastActiveSubscriber = this.subscriber;\n        }\n        for (const event of [\n            \"message\",\n            \"messageBuffer\",\n            \"smessage\",\n            \"smessageBuffer\",\n        ]) {\n            this.subscriber.on(event, (arg1, arg2) => {\n                this.emitter.emit(event, arg1, arg2);\n            });\n        }\n        for (const event of [\"pmessage\", \"pmessageBuffer\"]) {\n            this.subscriber.on(event, (arg1, arg2, arg3) => {\n                this.emitter.emit(event, arg1, arg2, arg3);\n            });\n        }\n    }\n}\nexports.default = ClusterSubscriber;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}