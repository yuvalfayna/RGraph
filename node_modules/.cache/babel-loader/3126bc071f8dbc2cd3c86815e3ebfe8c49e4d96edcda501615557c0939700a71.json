{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst crypto_1 = require(\"crypto\");\nconst Command_1 = require(\"./Command\");\nconst standard_as_callback_1 = require(\"standard-as-callback\");\nclass Script {\n  constructor(lua, numberOfKeys = null, keyPrefix = \"\", readOnly = false) {\n    this.lua = lua;\n    this.numberOfKeys = numberOfKeys;\n    this.keyPrefix = keyPrefix;\n    this.readOnly = readOnly;\n    this.sha = (0, crypto_1.createHash)(\"sha1\").update(lua).digest(\"hex\");\n    const sha = this.sha;\n    const socketHasScriptLoaded = new WeakSet();\n    this.Command = class CustomScriptCommand extends Command_1.default {\n      toWritable(socket) {\n        const origReject = this.reject;\n        this.reject = err => {\n          if (err.message.indexOf(\"NOSCRIPT\") !== -1) {\n            socketHasScriptLoaded.delete(socket);\n          }\n          origReject.call(this, err);\n        };\n        if (!socketHasScriptLoaded.has(socket)) {\n          socketHasScriptLoaded.add(socket);\n          this.name = \"eval\";\n          this.args[0] = lua;\n        } else if (this.name === \"eval\") {\n          this.name = \"evalsha\";\n          this.args[0] = sha;\n        }\n        return super.toWritable(socket);\n      }\n    };\n  }\n  execute(container, args, options, callback) {\n    if (typeof this.numberOfKeys === \"number\") {\n      args.unshift(this.numberOfKeys);\n    }\n    if (this.keyPrefix) {\n      options.keyPrefix = this.keyPrefix;\n    }\n    if (this.readOnly) {\n      options.readOnly = true;\n    }\n    const evalsha = new this.Command(\"evalsha\", [this.sha, ...args], options);\n    evalsha.promise = evalsha.promise.catch(err => {\n      if (err.message.indexOf(\"NOSCRIPT\") === -1) {\n        throw err;\n      }\n      // Resend the same custom evalsha command that gets transformed\n      // to an eval in case it's not loaded yet on the connection.\n      const resend = new this.Command(\"evalsha\", [this.sha, ...args], options);\n      const client = container.isPipeline ? container.redis : container;\n      return client.sendCommand(resend);\n    });\n    (0, standard_as_callback_1.default)(evalsha.promise, callback);\n    return container.sendCommand(evalsha);\n  }\n}\nexports.default = Script;","map":{"version":3,"names":["Object","defineProperty","exports","value","crypto_1","require","Command_1","standard_as_callback_1","Script","constructor","lua","numberOfKeys","keyPrefix","readOnly","sha","createHash","update","digest","socketHasScriptLoaded","WeakSet","Command","CustomScriptCommand","default","toWritable","socket","origReject","reject","err","message","indexOf","delete","call","has","add","name","args","execute","container","options","callback","unshift","evalsha","promise","catch","resend","client","isPipeline","redis","sendCommand"],"sources":["C:/rgraph/node_modules/ioredis/built/Script.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst crypto_1 = require(\"crypto\");\nconst Command_1 = require(\"./Command\");\nconst standard_as_callback_1 = require(\"standard-as-callback\");\nclass Script {\n    constructor(lua, numberOfKeys = null, keyPrefix = \"\", readOnly = false) {\n        this.lua = lua;\n        this.numberOfKeys = numberOfKeys;\n        this.keyPrefix = keyPrefix;\n        this.readOnly = readOnly;\n        this.sha = (0, crypto_1.createHash)(\"sha1\").update(lua).digest(\"hex\");\n        const sha = this.sha;\n        const socketHasScriptLoaded = new WeakSet();\n        this.Command = class CustomScriptCommand extends Command_1.default {\n            toWritable(socket) {\n                const origReject = this.reject;\n                this.reject = (err) => {\n                    if (err.message.indexOf(\"NOSCRIPT\") !== -1) {\n                        socketHasScriptLoaded.delete(socket);\n                    }\n                    origReject.call(this, err);\n                };\n                if (!socketHasScriptLoaded.has(socket)) {\n                    socketHasScriptLoaded.add(socket);\n                    this.name = \"eval\";\n                    this.args[0] = lua;\n                }\n                else if (this.name === \"eval\") {\n                    this.name = \"evalsha\";\n                    this.args[0] = sha;\n                }\n                return super.toWritable(socket);\n            }\n        };\n    }\n    execute(container, args, options, callback) {\n        if (typeof this.numberOfKeys === \"number\") {\n            args.unshift(this.numberOfKeys);\n        }\n        if (this.keyPrefix) {\n            options.keyPrefix = this.keyPrefix;\n        }\n        if (this.readOnly) {\n            options.readOnly = true;\n        }\n        const evalsha = new this.Command(\"evalsha\", [this.sha, ...args], options);\n        evalsha.promise = evalsha.promise.catch((err) => {\n            if (err.message.indexOf(\"NOSCRIPT\") === -1) {\n                throw err;\n            }\n            // Resend the same custom evalsha command that gets transformed\n            // to an eval in case it's not loaded yet on the connection.\n            const resend = new this.Command(\"evalsha\", [this.sha, ...args], options);\n            const client = container.isPipeline ? container.redis : container;\n            return client.sendCommand(resend);\n        });\n        (0, standard_as_callback_1.default)(evalsha.promise, callback);\n        return container.sendCommand(evalsha);\n    }\n}\nexports.default = Script;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}