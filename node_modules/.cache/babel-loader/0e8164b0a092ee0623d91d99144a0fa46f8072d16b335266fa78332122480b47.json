{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.readyHandler = exports.errorHandler = exports.closeHandler = exports.connectHandler = void 0;\nconst redis_errors_1 = require(\"redis-errors\");\nconst Command_1 = require(\"../Command\");\nconst errors_1 = require(\"../errors\");\nconst utils_1 = require(\"../utils\");\nconst DataHandler_1 = require(\"../DataHandler\");\nconst debug = (0, utils_1.Debug)(\"connection\");\nfunction connectHandler(self) {\n  return function () {\n    self.setStatus(\"connect\");\n    self.resetCommandQueue();\n    // AUTH command should be processed before any other commands\n    let flushed = false;\n    const {\n      connectionEpoch\n    } = self;\n    if (self.condition.auth) {\n      self.auth(self.condition.auth, function (err) {\n        if (connectionEpoch !== self.connectionEpoch) {\n          return;\n        }\n        if (err) {\n          if (err.message.indexOf(\"no password is set\") !== -1) {\n            console.warn(\"[WARN] Redis server does not require a password, but a password was supplied.\");\n          } else if (err.message.indexOf(\"without any password configured for the default user\") !== -1) {\n            console.warn(\"[WARN] This Redis server's `default` user does not require a password, but a password was supplied\");\n          } else if (err.message.indexOf(\"wrong number of arguments for 'auth' command\") !== -1) {\n            console.warn(`[ERROR] The server returned \"wrong number of arguments for 'auth' command\". You are probably passing both username and password to Redis version 5 or below. You should only pass the 'password' option for Redis version 5 and under.`);\n          } else {\n            flushed = true;\n            self.recoverFromFatalError(err, err);\n          }\n        }\n      });\n    }\n    if (self.condition.select) {\n      self.select(self.condition.select).catch(err => {\n        // If the node is in cluster mode, select is disallowed.\n        // In this case, reconnect won't help.\n        self.silentEmit(\"error\", err);\n      });\n    }\n    if (!self.options.enableReadyCheck) {\n      exports.readyHandler(self)();\n    }\n    /*\n      No need to keep the reference of DataHandler here\n      because we don't need to do the cleanup.\n      `Stream#end()` will remove all listeners for us.\n    */\n    new DataHandler_1.default(self, {\n      stringNumbers: self.options.stringNumbers\n    });\n    if (self.options.enableReadyCheck) {\n      self._readyCheck(function (err, info) {\n        if (connectionEpoch !== self.connectionEpoch) {\n          return;\n        }\n        if (err) {\n          if (!flushed) {\n            self.recoverFromFatalError(new Error(\"Ready check failed: \" + err.message), err);\n          }\n        } else {\n          if (self.connector.check(info)) {\n            exports.readyHandler(self)();\n          } else {\n            self.disconnect(true);\n          }\n        }\n      });\n    }\n  };\n}\nexports.connectHandler = connectHandler;\nfunction abortError(command) {\n  const err = new redis_errors_1.AbortError(\"Command aborted due to connection close\");\n  err.command = {\n    name: command.name,\n    args: command.args\n  };\n  return err;\n}\n// If a contiguous set of pipeline commands starts from index zero then they\n// can be safely reattempted. If however we have a chain of pipelined commands\n// starting at index 1 or more it means we received a partial response before\n// the connection close and those pipelined commands must be aborted. For\n// example, if the queue looks like this: [2, 3, 4, 0, 1, 2] then after\n// aborting and purging we'll have a queue that looks like this: [0, 1, 2]\nfunction abortIncompletePipelines(commandQueue) {\n  var _a;\n  let expectedIndex = 0;\n  for (let i = 0; i < commandQueue.length;) {\n    const command = (_a = commandQueue.peekAt(i)) === null || _a === void 0 ? void 0 : _a.command;\n    const pipelineIndex = command.pipelineIndex;\n    if (pipelineIndex === undefined || pipelineIndex === 0) {\n      expectedIndex = 0;\n    }\n    if (pipelineIndex !== undefined && pipelineIndex !== expectedIndex++) {\n      commandQueue.remove(i, 1);\n      command.reject(abortError(command));\n      continue;\n    }\n    i++;\n  }\n}\n// If only a partial transaction result was received before connection close,\n// we have to abort any transaction fragments that may have ended up in the\n// offline queue\nfunction abortTransactionFragments(commandQueue) {\n  var _a;\n  for (let i = 0; i < commandQueue.length;) {\n    const command = (_a = commandQueue.peekAt(i)) === null || _a === void 0 ? void 0 : _a.command;\n    if (command.name === \"multi\") {\n      break;\n    }\n    if (command.name === \"exec\") {\n      commandQueue.remove(i, 1);\n      command.reject(abortError(command));\n      break;\n    }\n    if (command.inTransaction) {\n      commandQueue.remove(i, 1);\n      command.reject(abortError(command));\n    } else {\n      i++;\n    }\n  }\n}\nfunction closeHandler(self) {\n  return function () {\n    const prevStatus = self.status;\n    self.setStatus(\"close\");\n    if (self.commandQueue.length) {\n      abortIncompletePipelines(self.commandQueue);\n    }\n    if (self.offlineQueue.length) {\n      abortTransactionFragments(self.offlineQueue);\n    }\n    if (prevStatus === \"ready\") {\n      if (!self.prevCondition) {\n        self.prevCondition = self.condition;\n      }\n      if (self.commandQueue.length) {\n        self.prevCommandQueue = self.commandQueue;\n      }\n    }\n    if (self.manuallyClosing) {\n      self.manuallyClosing = false;\n      debug(\"skip reconnecting since the connection is manually closed.\");\n      return close();\n    }\n    if (typeof self.options.retryStrategy !== \"function\") {\n      debug(\"skip reconnecting because `retryStrategy` is not a function\");\n      return close();\n    }\n    const retryDelay = self.options.retryStrategy(++self.retryAttempts);\n    if (typeof retryDelay !== \"number\") {\n      debug(\"skip reconnecting because `retryStrategy` doesn't return a number\");\n      return close();\n    }\n    debug(\"reconnect in %sms\", retryDelay);\n    self.setStatus(\"reconnecting\", retryDelay);\n    self.reconnectTimeout = setTimeout(function () {\n      self.reconnectTimeout = null;\n      self.connect().catch(utils_1.noop);\n    }, retryDelay);\n    const {\n      maxRetriesPerRequest\n    } = self.options;\n    if (typeof maxRetriesPerRequest === \"number\") {\n      if (maxRetriesPerRequest < 0) {\n        debug(\"maxRetriesPerRequest is negative, ignoring...\");\n      } else {\n        const remainder = self.retryAttempts % (maxRetriesPerRequest + 1);\n        if (remainder === 0) {\n          debug(\"reach maxRetriesPerRequest limitation, flushing command queue...\");\n          self.flushQueue(new errors_1.MaxRetriesPerRequestError(maxRetriesPerRequest));\n        }\n      }\n    }\n  };\n  function close() {\n    self.setStatus(\"end\");\n    self.flushQueue(new Error(utils_1.CONNECTION_CLOSED_ERROR_MSG));\n  }\n}\nexports.closeHandler = closeHandler;\nfunction errorHandler(self) {\n  return function (error) {\n    debug(\"error: %s\", error);\n    self.silentEmit(\"error\", error);\n  };\n}\nexports.errorHandler = errorHandler;\nfunction readyHandler(self) {\n  return function () {\n    self.setStatus(\"ready\");\n    self.retryAttempts = 0;\n    if (self.options.monitor) {\n      self.call(\"monitor\").then(() => self.setStatus(\"monitoring\"), error => self.emit(\"error\", error));\n      const {\n        sendCommand\n      } = self;\n      self.sendCommand = function (command) {\n        if (Command_1.default.checkFlag(\"VALID_IN_MONITOR_MODE\", command.name)) {\n          return sendCommand.call(self, command);\n        }\n        command.reject(new Error(\"Connection is in monitoring mode, can't process commands.\"));\n        return command.promise;\n      };\n      self.once(\"close\", function () {\n        delete self.sendCommand;\n      });\n      return;\n    }\n    const finalSelect = self.prevCondition ? self.prevCondition.select : self.condition.select;\n    if (self.options.connectionName) {\n      debug(\"set the connection name [%s]\", self.options.connectionName);\n      self.client(\"setname\", self.options.connectionName).catch(utils_1.noop);\n    }\n    if (self.options.readOnly) {\n      debug(\"set the connection to readonly mode\");\n      self.readonly().catch(utils_1.noop);\n    }\n    if (self.prevCondition) {\n      const condition = self.prevCondition;\n      self.prevCondition = null;\n      if (condition.subscriber && self.options.autoResubscribe) {\n        // We re-select the previous db first since\n        // `SELECT` command is not valid in sub mode.\n        if (self.condition.select !== finalSelect) {\n          debug(\"connect to db [%d]\", finalSelect);\n          self.select(finalSelect);\n        }\n        const subscribeChannels = condition.subscriber.channels(\"subscribe\");\n        if (subscribeChannels.length) {\n          debug(\"subscribe %d channels\", subscribeChannels.length);\n          self.subscribe(subscribeChannels);\n        }\n        const psubscribeChannels = condition.subscriber.channels(\"psubscribe\");\n        if (psubscribeChannels.length) {\n          debug(\"psubscribe %d channels\", psubscribeChannels.length);\n          self.psubscribe(psubscribeChannels);\n        }\n        const ssubscribeChannels = condition.subscriber.channels(\"ssubscribe\");\n        if (ssubscribeChannels.length) {\n          debug(\"ssubscribe %d channels\", ssubscribeChannels.length);\n          self.ssubscribe(ssubscribeChannels);\n        }\n      }\n    }\n    if (self.prevCommandQueue) {\n      if (self.options.autoResendUnfulfilledCommands) {\n        debug(\"resend %d unfulfilled commands\", self.prevCommandQueue.length);\n        while (self.prevCommandQueue.length > 0) {\n          const item = self.prevCommandQueue.shift();\n          if (item.select !== self.condition.select && item.command.name !== \"select\") {\n            self.select(item.select);\n          }\n          self.sendCommand(item.command, item.stream);\n        }\n      } else {\n        self.prevCommandQueue = null;\n      }\n    }\n    if (self.offlineQueue.length) {\n      debug(\"send %d commands in offline queue\", self.offlineQueue.length);\n      const offlineQueue = self.offlineQueue;\n      self.resetOfflineQueue();\n      while (offlineQueue.length > 0) {\n        const item = offlineQueue.shift();\n        if (item.select !== self.condition.select && item.command.name !== \"select\") {\n          self.select(item.select);\n        }\n        self.sendCommand(item.command, item.stream);\n      }\n    }\n    if (self.condition.select !== finalSelect) {\n      debug(\"connect to db [%d]\", finalSelect);\n      self.select(finalSelect);\n    }\n  };\n}\nexports.readyHandler = readyHandler;","map":{"version":3,"names":["Object","defineProperty","exports","value","readyHandler","errorHandler","closeHandler","connectHandler","redis_errors_1","require","Command_1","errors_1","utils_1","DataHandler_1","debug","Debug","self","setStatus","resetCommandQueue","flushed","connectionEpoch","condition","auth","err","message","indexOf","console","warn","recoverFromFatalError","select","catch","silentEmit","options","enableReadyCheck","default","stringNumbers","_readyCheck","info","Error","connector","check","disconnect","abortError","command","AbortError","name","args","abortIncompletePipelines","commandQueue","_a","expectedIndex","i","length","peekAt","pipelineIndex","undefined","remove","reject","abortTransactionFragments","inTransaction","prevStatus","status","offlineQueue","prevCondition","prevCommandQueue","manuallyClosing","close","retryStrategy","retryDelay","retryAttempts","reconnectTimeout","setTimeout","connect","noop","maxRetriesPerRequest","remainder","flushQueue","MaxRetriesPerRequestError","CONNECTION_CLOSED_ERROR_MSG","error","monitor","call","then","emit","sendCommand","checkFlag","promise","once","finalSelect","connectionName","client","readOnly","readonly","subscriber","autoResubscribe","subscribeChannels","channels","subscribe","psubscribeChannels","psubscribe","ssubscribeChannels","ssubscribe","autoResendUnfulfilledCommands","item","shift","stream","resetOfflineQueue"],"sources":["C:/rgraph/node_modules/ioredis/built/redis/event_handler.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.readyHandler = exports.errorHandler = exports.closeHandler = exports.connectHandler = void 0;\nconst redis_errors_1 = require(\"redis-errors\");\nconst Command_1 = require(\"../Command\");\nconst errors_1 = require(\"../errors\");\nconst utils_1 = require(\"../utils\");\nconst DataHandler_1 = require(\"../DataHandler\");\nconst debug = (0, utils_1.Debug)(\"connection\");\nfunction connectHandler(self) {\n    return function () {\n        self.setStatus(\"connect\");\n        self.resetCommandQueue();\n        // AUTH command should be processed before any other commands\n        let flushed = false;\n        const { connectionEpoch } = self;\n        if (self.condition.auth) {\n            self.auth(self.condition.auth, function (err) {\n                if (connectionEpoch !== self.connectionEpoch) {\n                    return;\n                }\n                if (err) {\n                    if (err.message.indexOf(\"no password is set\") !== -1) {\n                        console.warn(\"[WARN] Redis server does not require a password, but a password was supplied.\");\n                    }\n                    else if (err.message.indexOf(\"without any password configured for the default user\") !== -1) {\n                        console.warn(\"[WARN] This Redis server's `default` user does not require a password, but a password was supplied\");\n                    }\n                    else if (err.message.indexOf(\"wrong number of arguments for 'auth' command\") !== -1) {\n                        console.warn(`[ERROR] The server returned \"wrong number of arguments for 'auth' command\". You are probably passing both username and password to Redis version 5 or below. You should only pass the 'password' option for Redis version 5 and under.`);\n                    }\n                    else {\n                        flushed = true;\n                        self.recoverFromFatalError(err, err);\n                    }\n                }\n            });\n        }\n        if (self.condition.select) {\n            self.select(self.condition.select).catch((err) => {\n                // If the node is in cluster mode, select is disallowed.\n                // In this case, reconnect won't help.\n                self.silentEmit(\"error\", err);\n            });\n        }\n        if (!self.options.enableReadyCheck) {\n            exports.readyHandler(self)();\n        }\n        /*\n          No need to keep the reference of DataHandler here\n          because we don't need to do the cleanup.\n          `Stream#end()` will remove all listeners for us.\n        */\n        new DataHandler_1.default(self, {\n            stringNumbers: self.options.stringNumbers,\n        });\n        if (self.options.enableReadyCheck) {\n            self._readyCheck(function (err, info) {\n                if (connectionEpoch !== self.connectionEpoch) {\n                    return;\n                }\n                if (err) {\n                    if (!flushed) {\n                        self.recoverFromFatalError(new Error(\"Ready check failed: \" + err.message), err);\n                    }\n                }\n                else {\n                    if (self.connector.check(info)) {\n                        exports.readyHandler(self)();\n                    }\n                    else {\n                        self.disconnect(true);\n                    }\n                }\n            });\n        }\n    };\n}\nexports.connectHandler = connectHandler;\nfunction abortError(command) {\n    const err = new redis_errors_1.AbortError(\"Command aborted due to connection close\");\n    err.command = {\n        name: command.name,\n        args: command.args,\n    };\n    return err;\n}\n// If a contiguous set of pipeline commands starts from index zero then they\n// can be safely reattempted. If however we have a chain of pipelined commands\n// starting at index 1 or more it means we received a partial response before\n// the connection close and those pipelined commands must be aborted. For\n// example, if the queue looks like this: [2, 3, 4, 0, 1, 2] then after\n// aborting and purging we'll have a queue that looks like this: [0, 1, 2]\nfunction abortIncompletePipelines(commandQueue) {\n    var _a;\n    let expectedIndex = 0;\n    for (let i = 0; i < commandQueue.length;) {\n        const command = (_a = commandQueue.peekAt(i)) === null || _a === void 0 ? void 0 : _a.command;\n        const pipelineIndex = command.pipelineIndex;\n        if (pipelineIndex === undefined || pipelineIndex === 0) {\n            expectedIndex = 0;\n        }\n        if (pipelineIndex !== undefined && pipelineIndex !== expectedIndex++) {\n            commandQueue.remove(i, 1);\n            command.reject(abortError(command));\n            continue;\n        }\n        i++;\n    }\n}\n// If only a partial transaction result was received before connection close,\n// we have to abort any transaction fragments that may have ended up in the\n// offline queue\nfunction abortTransactionFragments(commandQueue) {\n    var _a;\n    for (let i = 0; i < commandQueue.length;) {\n        const command = (_a = commandQueue.peekAt(i)) === null || _a === void 0 ? void 0 : _a.command;\n        if (command.name === \"multi\") {\n            break;\n        }\n        if (command.name === \"exec\") {\n            commandQueue.remove(i, 1);\n            command.reject(abortError(command));\n            break;\n        }\n        if (command.inTransaction) {\n            commandQueue.remove(i, 1);\n            command.reject(abortError(command));\n        }\n        else {\n            i++;\n        }\n    }\n}\nfunction closeHandler(self) {\n    return function () {\n        const prevStatus = self.status;\n        self.setStatus(\"close\");\n        if (self.commandQueue.length) {\n            abortIncompletePipelines(self.commandQueue);\n        }\n        if (self.offlineQueue.length) {\n            abortTransactionFragments(self.offlineQueue);\n        }\n        if (prevStatus === \"ready\") {\n            if (!self.prevCondition) {\n                self.prevCondition = self.condition;\n            }\n            if (self.commandQueue.length) {\n                self.prevCommandQueue = self.commandQueue;\n            }\n        }\n        if (self.manuallyClosing) {\n            self.manuallyClosing = false;\n            debug(\"skip reconnecting since the connection is manually closed.\");\n            return close();\n        }\n        if (typeof self.options.retryStrategy !== \"function\") {\n            debug(\"skip reconnecting because `retryStrategy` is not a function\");\n            return close();\n        }\n        const retryDelay = self.options.retryStrategy(++self.retryAttempts);\n        if (typeof retryDelay !== \"number\") {\n            debug(\"skip reconnecting because `retryStrategy` doesn't return a number\");\n            return close();\n        }\n        debug(\"reconnect in %sms\", retryDelay);\n        self.setStatus(\"reconnecting\", retryDelay);\n        self.reconnectTimeout = setTimeout(function () {\n            self.reconnectTimeout = null;\n            self.connect().catch(utils_1.noop);\n        }, retryDelay);\n        const { maxRetriesPerRequest } = self.options;\n        if (typeof maxRetriesPerRequest === \"number\") {\n            if (maxRetriesPerRequest < 0) {\n                debug(\"maxRetriesPerRequest is negative, ignoring...\");\n            }\n            else {\n                const remainder = self.retryAttempts % (maxRetriesPerRequest + 1);\n                if (remainder === 0) {\n                    debug(\"reach maxRetriesPerRequest limitation, flushing command queue...\");\n                    self.flushQueue(new errors_1.MaxRetriesPerRequestError(maxRetriesPerRequest));\n                }\n            }\n        }\n    };\n    function close() {\n        self.setStatus(\"end\");\n        self.flushQueue(new Error(utils_1.CONNECTION_CLOSED_ERROR_MSG));\n    }\n}\nexports.closeHandler = closeHandler;\nfunction errorHandler(self) {\n    return function (error) {\n        debug(\"error: %s\", error);\n        self.silentEmit(\"error\", error);\n    };\n}\nexports.errorHandler = errorHandler;\nfunction readyHandler(self) {\n    return function () {\n        self.setStatus(\"ready\");\n        self.retryAttempts = 0;\n        if (self.options.monitor) {\n            self.call(\"monitor\").then(() => self.setStatus(\"monitoring\"), (error) => self.emit(\"error\", error));\n            const { sendCommand } = self;\n            self.sendCommand = function (command) {\n                if (Command_1.default.checkFlag(\"VALID_IN_MONITOR_MODE\", command.name)) {\n                    return sendCommand.call(self, command);\n                }\n                command.reject(new Error(\"Connection is in monitoring mode, can't process commands.\"));\n                return command.promise;\n            };\n            self.once(\"close\", function () {\n                delete self.sendCommand;\n            });\n            return;\n        }\n        const finalSelect = self.prevCondition\n            ? self.prevCondition.select\n            : self.condition.select;\n        if (self.options.connectionName) {\n            debug(\"set the connection name [%s]\", self.options.connectionName);\n            self.client(\"setname\", self.options.connectionName).catch(utils_1.noop);\n        }\n        if (self.options.readOnly) {\n            debug(\"set the connection to readonly mode\");\n            self.readonly().catch(utils_1.noop);\n        }\n        if (self.prevCondition) {\n            const condition = self.prevCondition;\n            self.prevCondition = null;\n            if (condition.subscriber && self.options.autoResubscribe) {\n                // We re-select the previous db first since\n                // `SELECT` command is not valid in sub mode.\n                if (self.condition.select !== finalSelect) {\n                    debug(\"connect to db [%d]\", finalSelect);\n                    self.select(finalSelect);\n                }\n                const subscribeChannels = condition.subscriber.channels(\"subscribe\");\n                if (subscribeChannels.length) {\n                    debug(\"subscribe %d channels\", subscribeChannels.length);\n                    self.subscribe(subscribeChannels);\n                }\n                const psubscribeChannels = condition.subscriber.channels(\"psubscribe\");\n                if (psubscribeChannels.length) {\n                    debug(\"psubscribe %d channels\", psubscribeChannels.length);\n                    self.psubscribe(psubscribeChannels);\n                }\n                const ssubscribeChannels = condition.subscriber.channels(\"ssubscribe\");\n                if (ssubscribeChannels.length) {\n                    debug(\"ssubscribe %d channels\", ssubscribeChannels.length);\n                    self.ssubscribe(ssubscribeChannels);\n                }\n            }\n        }\n        if (self.prevCommandQueue) {\n            if (self.options.autoResendUnfulfilledCommands) {\n                debug(\"resend %d unfulfilled commands\", self.prevCommandQueue.length);\n                while (self.prevCommandQueue.length > 0) {\n                    const item = self.prevCommandQueue.shift();\n                    if (item.select !== self.condition.select &&\n                        item.command.name !== \"select\") {\n                        self.select(item.select);\n                    }\n                    self.sendCommand(item.command, item.stream);\n                }\n            }\n            else {\n                self.prevCommandQueue = null;\n            }\n        }\n        if (self.offlineQueue.length) {\n            debug(\"send %d commands in offline queue\", self.offlineQueue.length);\n            const offlineQueue = self.offlineQueue;\n            self.resetOfflineQueue();\n            while (offlineQueue.length > 0) {\n                const item = offlineQueue.shift();\n                if (item.select !== self.condition.select &&\n                    item.command.name !== \"select\") {\n                    self.select(item.select);\n                }\n                self.sendCommand(item.command, item.stream);\n            }\n        }\n        if (self.condition.select !== finalSelect) {\n            debug(\"connect to db [%d]\", finalSelect);\n            self.select(finalSelect);\n        }\n    };\n}\nexports.readyHandler = readyHandler;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}