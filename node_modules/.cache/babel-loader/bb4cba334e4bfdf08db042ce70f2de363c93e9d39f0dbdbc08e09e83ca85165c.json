{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst commands_1 = require(\"@ioredis/commands\");\nconst events_1 = require(\"events\");\nconst redis_errors_1 = require(\"redis-errors\");\nconst standard_as_callback_1 = require(\"standard-as-callback\");\nconst Command_1 = require(\"../Command\");\nconst ClusterAllFailedError_1 = require(\"../errors/ClusterAllFailedError\");\nconst Redis_1 = require(\"../Redis\");\nconst ScanStream_1 = require(\"../ScanStream\");\nconst transaction_1 = require(\"../transaction\");\nconst utils_1 = require(\"../utils\");\nconst applyMixin_1 = require(\"../utils/applyMixin\");\nconst Commander_1 = require(\"../utils/Commander\");\nconst ClusterOptions_1 = require(\"./ClusterOptions\");\nconst ClusterSubscriber_1 = require(\"./ClusterSubscriber\");\nconst ConnectionPool_1 = require(\"./ConnectionPool\");\nconst DelayQueue_1 = require(\"./DelayQueue\");\nconst util_1 = require(\"./util\");\nconst Deque = require(\"denque\");\nconst debug = (0, utils_1.Debug)(\"cluster\");\nconst REJECT_OVERWRITTEN_COMMANDS = new WeakSet();\n/**\n * Client for the official Redis Cluster\n */\nclass Cluster extends Commander_1.default {\n  /**\n   * Creates an instance of Cluster.\n   */\n  constructor(startupNodes, options = {}) {\n    super();\n    this.slots = [];\n    /**\n     * @ignore\n     */\n    this._groupsIds = {};\n    /**\n     * @ignore\n     */\n    this._groupsBySlot = Array(16384);\n    /**\n     * @ignore\n     */\n    this.isCluster = true;\n    this.retryAttempts = 0;\n    this.delayQueue = new DelayQueue_1.default();\n    this.offlineQueue = new Deque();\n    this.isRefreshing = false;\n    this._refreshSlotsCacheCallbacks = [];\n    this._autoPipelines = new Map();\n    this._runningAutoPipelines = new Set();\n    this._readyDelayedCallbacks = [];\n    /**\n     * Every time Cluster#connect() is called, this value will be\n     * auto-incrementing. The purpose of this value is used for\n     * discarding previous connect attampts when creating a new\n     * connection.\n     */\n    this.connectionEpoch = 0;\n    events_1.EventEmitter.call(this);\n    this.startupNodes = startupNodes;\n    this.options = (0, utils_1.defaults)({}, options, ClusterOptions_1.DEFAULT_CLUSTER_OPTIONS, this.options);\n    if (this.options.redisOptions && this.options.redisOptions.keyPrefix && !this.options.keyPrefix) {\n      this.options.keyPrefix = this.options.redisOptions.keyPrefix;\n    }\n    // validate options\n    if (typeof this.options.scaleReads !== \"function\" && [\"all\", \"master\", \"slave\"].indexOf(this.options.scaleReads) === -1) {\n      throw new Error('Invalid option scaleReads \"' + this.options.scaleReads + '\". Expected \"all\", \"master\", \"slave\" or a custom function');\n    }\n    this.connectionPool = new ConnectionPool_1.default(this.options.redisOptions);\n    this.connectionPool.on(\"-node\", (redis, key) => {\n      this.emit(\"-node\", redis);\n    });\n    this.connectionPool.on(\"+node\", redis => {\n      this.emit(\"+node\", redis);\n    });\n    this.connectionPool.on(\"drain\", () => {\n      this.setStatus(\"close\");\n    });\n    this.connectionPool.on(\"nodeError\", (error, key) => {\n      this.emit(\"node error\", error, key);\n    });\n    this.subscriber = new ClusterSubscriber_1.default(this.connectionPool, this);\n    if (this.options.scripts) {\n      Object.entries(this.options.scripts).forEach(([name, definition]) => {\n        this.defineCommand(name, definition);\n      });\n    }\n    if (this.options.lazyConnect) {\n      this.setStatus(\"wait\");\n    } else {\n      this.connect().catch(err => {\n        debug(\"connecting failed: %s\", err);\n      });\n    }\n  }\n  /**\n   * Connect to a cluster\n   */\n  connect() {\n    return new Promise((resolve, reject) => {\n      if (this.status === \"connecting\" || this.status === \"connect\" || this.status === \"ready\") {\n        reject(new Error(\"Redis is already connecting/connected\"));\n        return;\n      }\n      const epoch = ++this.connectionEpoch;\n      this.setStatus(\"connecting\");\n      this.resolveStartupNodeHostnames().then(nodes => {\n        if (this.connectionEpoch !== epoch) {\n          debug(\"discard connecting after resolving startup nodes because epoch not match: %d != %d\", epoch, this.connectionEpoch);\n          reject(new redis_errors_1.RedisError(\"Connection is discarded because a new connection is made\"));\n          return;\n        }\n        if (this.status !== \"connecting\") {\n          debug(\"discard connecting after resolving startup nodes because the status changed to %s\", this.status);\n          reject(new redis_errors_1.RedisError(\"Connection is aborted\"));\n          return;\n        }\n        this.connectionPool.reset(nodes);\n        const readyHandler = () => {\n          this.setStatus(\"ready\");\n          this.retryAttempts = 0;\n          this.executeOfflineCommands();\n          this.resetNodesRefreshInterval();\n          resolve();\n        };\n        let closeListener = undefined;\n        const refreshListener = () => {\n          this.invokeReadyDelayedCallbacks(undefined);\n          this.removeListener(\"close\", closeListener);\n          this.manuallyClosing = false;\n          this.setStatus(\"connect\");\n          if (this.options.enableReadyCheck) {\n            this.readyCheck((err, fail) => {\n              if (err || fail) {\n                debug(\"Ready check failed (%s). Reconnecting...\", err || fail);\n                if (this.status === \"connect\") {\n                  this.disconnect(true);\n                }\n              } else {\n                readyHandler();\n              }\n            });\n          } else {\n            readyHandler();\n          }\n        };\n        closeListener = () => {\n          const error = new Error(\"None of startup nodes is available\");\n          this.removeListener(\"refresh\", refreshListener);\n          this.invokeReadyDelayedCallbacks(error);\n          reject(error);\n        };\n        this.once(\"refresh\", refreshListener);\n        this.once(\"close\", closeListener);\n        this.once(\"close\", this.handleCloseEvent.bind(this));\n        this.refreshSlotsCache(err => {\n          if (err && err.message === ClusterAllFailedError_1.default.defaultMessage) {\n            Redis_1.default.prototype.silentEmit.call(this, \"error\", err);\n            this.connectionPool.reset([]);\n          }\n        });\n        this.subscriber.start();\n      }).catch(err => {\n        this.setStatus(\"close\");\n        this.handleCloseEvent(err);\n        this.invokeReadyDelayedCallbacks(err);\n        reject(err);\n      });\n    });\n  }\n  /**\n   * Disconnect from every node in the cluster.\n   */\n  disconnect(reconnect = false) {\n    const status = this.status;\n    this.setStatus(\"disconnecting\");\n    if (!reconnect) {\n      this.manuallyClosing = true;\n    }\n    if (this.reconnectTimeout && !reconnect) {\n      clearTimeout(this.reconnectTimeout);\n      this.reconnectTimeout = null;\n      debug(\"Canceled reconnecting attempts\");\n    }\n    this.clearNodesRefreshInterval();\n    this.subscriber.stop();\n    if (status === \"wait\") {\n      this.setStatus(\"close\");\n      this.handleCloseEvent();\n    } else {\n      this.connectionPool.reset([]);\n    }\n  }\n  /**\n   * Quit the cluster gracefully.\n   */\n  quit(callback) {\n    const status = this.status;\n    this.setStatus(\"disconnecting\");\n    this.manuallyClosing = true;\n    if (this.reconnectTimeout) {\n      clearTimeout(this.reconnectTimeout);\n      this.reconnectTimeout = null;\n    }\n    this.clearNodesRefreshInterval();\n    this.subscriber.stop();\n    if (status === \"wait\") {\n      const ret = (0, standard_as_callback_1.default)(Promise.resolve(\"OK\"), callback);\n      // use setImmediate to make sure \"close\" event\n      // being emitted after quit() is returned\n      setImmediate(function () {\n        this.setStatus(\"close\");\n        this.handleCloseEvent();\n      }.bind(this));\n      return ret;\n    }\n    return (0, standard_as_callback_1.default)(Promise.all(this.nodes().map(node => node.quit().catch(err => {\n      // Ignore the error caused by disconnecting since\n      // we're disconnecting...\n      if (err.message === utils_1.CONNECTION_CLOSED_ERROR_MSG) {\n        return \"OK\";\n      }\n      throw err;\n    }))).then(() => \"OK\"), callback);\n  }\n  /**\n   * Create a new instance with the same startup nodes and options as the current one.\n   *\n   * @example\n   * ```js\n   * var cluster = new Redis.Cluster([{ host: \"127.0.0.1\", port: \"30001\" }]);\n   * var anotherCluster = cluster.duplicate();\n   * ```\n   */\n  duplicate(overrideStartupNodes = [], overrideOptions = {}) {\n    const startupNodes = overrideStartupNodes.length > 0 ? overrideStartupNodes : this.startupNodes.slice(0);\n    const options = Object.assign({}, this.options, overrideOptions);\n    return new Cluster(startupNodes, options);\n  }\n  /**\n   * Get nodes with the specified role\n   */\n  nodes(role = \"all\") {\n    if (role !== \"all\" && role !== \"master\" && role !== \"slave\") {\n      throw new Error('Invalid role \"' + role + '\". Expected \"all\", \"master\" or \"slave\"');\n    }\n    return this.connectionPool.getNodes(role);\n  }\n  /**\n   * This is needed in order not to install a listener for each auto pipeline\n   *\n   * @ignore\n   */\n  delayUntilReady(callback) {\n    this._readyDelayedCallbacks.push(callback);\n  }\n  /**\n   * Get the number of commands queued in automatic pipelines.\n   *\n   * This is not available (and returns 0) until the cluster is connected and slots information have been received.\n   */\n  get autoPipelineQueueSize() {\n    let queued = 0;\n    for (const pipeline of this._autoPipelines.values()) {\n      queued += pipeline.length;\n    }\n    return queued;\n  }\n  /**\n   * Refresh the slot cache\n   *\n   * @ignore\n   */\n  refreshSlotsCache(callback) {\n    if (callback) {\n      this._refreshSlotsCacheCallbacks.push(callback);\n    }\n    if (this.isRefreshing) {\n      return;\n    }\n    this.isRefreshing = true;\n    const _this = this;\n    const wrapper = error => {\n      this.isRefreshing = false;\n      for (const callback of this._refreshSlotsCacheCallbacks) {\n        callback(error);\n      }\n      this._refreshSlotsCacheCallbacks = [];\n    };\n    const nodes = (0, utils_1.shuffle)(this.connectionPool.getNodes());\n    let lastNodeError = null;\n    function tryNode(index) {\n      if (index === nodes.length) {\n        const error = new ClusterAllFailedError_1.default(ClusterAllFailedError_1.default.defaultMessage, lastNodeError);\n        return wrapper(error);\n      }\n      const node = nodes[index];\n      const key = `${node.options.host}:${node.options.port}`;\n      debug(\"getting slot cache from %s\", key);\n      _this.getInfoFromNode(node, function (err) {\n        switch (_this.status) {\n          case \"close\":\n          case \"end\":\n            return wrapper(new Error(\"Cluster is disconnected.\"));\n          case \"disconnecting\":\n            return wrapper(new Error(\"Cluster is disconnecting.\"));\n        }\n        if (err) {\n          _this.emit(\"node error\", err, key);\n          lastNodeError = err;\n          tryNode(index + 1);\n        } else {\n          _this.emit(\"refresh\");\n          wrapper();\n        }\n      });\n    }\n    tryNode(0);\n  }\n  /**\n   * @ignore\n   */\n  sendCommand(command, stream, node) {\n    if (this.status === \"wait\") {\n      this.connect().catch(utils_1.noop);\n    }\n    if (this.status === \"end\") {\n      command.reject(new Error(utils_1.CONNECTION_CLOSED_ERROR_MSG));\n      return command.promise;\n    }\n    let to = this.options.scaleReads;\n    if (to !== \"master\") {\n      const isCommandReadOnly = command.isReadOnly || (0, commands_1.exists)(command.name) && (0, commands_1.hasFlag)(command.name, \"readonly\");\n      if (!isCommandReadOnly) {\n        to = \"master\";\n      }\n    }\n    let targetSlot = node ? node.slot : command.getSlot();\n    const ttl = {};\n    const _this = this;\n    if (!node && !REJECT_OVERWRITTEN_COMMANDS.has(command)) {\n      REJECT_OVERWRITTEN_COMMANDS.add(command);\n      const reject = command.reject;\n      command.reject = function (err) {\n        const partialTry = tryConnection.bind(null, true);\n        _this.handleError(err, ttl, {\n          moved: function (slot, key) {\n            debug(\"command %s is moved to %s\", command.name, key);\n            targetSlot = Number(slot);\n            if (_this.slots[slot]) {\n              _this.slots[slot][0] = key;\n            } else {\n              _this.slots[slot] = [key];\n            }\n            _this._groupsBySlot[slot] = _this._groupsIds[_this.slots[slot].join(\";\")];\n            _this.connectionPool.findOrCreate(_this.natMapper(key));\n            tryConnection();\n            debug(\"refreshing slot caches... (triggered by MOVED error)\");\n            _this.refreshSlotsCache();\n          },\n          ask: function (slot, key) {\n            debug(\"command %s is required to ask %s:%s\", command.name, key);\n            const mapped = _this.natMapper(key);\n            _this.connectionPool.findOrCreate(mapped);\n            tryConnection(false, `${mapped.host}:${mapped.port}`);\n          },\n          tryagain: partialTry,\n          clusterDown: partialTry,\n          connectionClosed: partialTry,\n          maxRedirections: function (redirectionError) {\n            reject.call(command, redirectionError);\n          },\n          defaults: function () {\n            reject.call(command, err);\n          }\n        });\n      };\n    }\n    tryConnection();\n    function tryConnection(random, asking) {\n      if (_this.status === \"end\") {\n        command.reject(new redis_errors_1.AbortError(\"Cluster is ended.\"));\n        return;\n      }\n      let redis;\n      if (_this.status === \"ready\" || command.name === \"cluster\") {\n        if (node && node.redis) {\n          redis = node.redis;\n        } else if (Command_1.default.checkFlag(\"ENTER_SUBSCRIBER_MODE\", command.name) || Command_1.default.checkFlag(\"EXIT_SUBSCRIBER_MODE\", command.name)) {\n          redis = _this.subscriber.getInstance();\n          if (!redis) {\n            command.reject(new redis_errors_1.AbortError(\"No subscriber for the cluster\"));\n            return;\n          }\n        } else {\n          if (!random) {\n            if (typeof targetSlot === \"number\" && _this.slots[targetSlot]) {\n              const nodeKeys = _this.slots[targetSlot];\n              if (typeof to === \"function\") {\n                const nodes = nodeKeys.map(function (key) {\n                  return _this.connectionPool.getInstanceByKey(key);\n                });\n                redis = to(nodes, command);\n                if (Array.isArray(redis)) {\n                  redis = (0, utils_1.sample)(redis);\n                }\n                if (!redis) {\n                  redis = nodes[0];\n                }\n              } else {\n                let key;\n                if (to === \"all\") {\n                  key = (0, utils_1.sample)(nodeKeys);\n                } else if (to === \"slave\" && nodeKeys.length > 1) {\n                  key = (0, utils_1.sample)(nodeKeys, 1);\n                } else {\n                  key = nodeKeys[0];\n                }\n                redis = _this.connectionPool.getInstanceByKey(key);\n              }\n            }\n            if (asking) {\n              redis = _this.connectionPool.getInstanceByKey(asking);\n              redis.asking();\n            }\n          }\n          if (!redis) {\n            redis = (typeof to === \"function\" ? null : _this.connectionPool.getSampleInstance(to)) || _this.connectionPool.getSampleInstance(\"all\");\n          }\n        }\n        if (node && !node.redis) {\n          node.redis = redis;\n        }\n      }\n      if (redis) {\n        redis.sendCommand(command, stream);\n      } else if (_this.options.enableOfflineQueue) {\n        _this.offlineQueue.push({\n          command: command,\n          stream: stream,\n          node: node\n        });\n      } else {\n        command.reject(new Error(\"Cluster isn't ready and enableOfflineQueue options is false\"));\n      }\n    }\n    return command.promise;\n  }\n  sscanStream(key, options) {\n    return this.createScanStream(\"sscan\", {\n      key,\n      options\n    });\n  }\n  sscanBufferStream(key, options) {\n    return this.createScanStream(\"sscanBuffer\", {\n      key,\n      options\n    });\n  }\n  hscanStream(key, options) {\n    return this.createScanStream(\"hscan\", {\n      key,\n      options\n    });\n  }\n  hscanBufferStream(key, options) {\n    return this.createScanStream(\"hscanBuffer\", {\n      key,\n      options\n    });\n  }\n  zscanStream(key, options) {\n    return this.createScanStream(\"zscan\", {\n      key,\n      options\n    });\n  }\n  zscanBufferStream(key, options) {\n    return this.createScanStream(\"zscanBuffer\", {\n      key,\n      options\n    });\n  }\n  /**\n   * @ignore\n   */\n  handleError(error, ttl, handlers) {\n    if (typeof ttl.value === \"undefined\") {\n      ttl.value = this.options.maxRedirections;\n    } else {\n      ttl.value -= 1;\n    }\n    if (ttl.value <= 0) {\n      handlers.maxRedirections(new Error(\"Too many Cluster redirections. Last error: \" + error));\n      return;\n    }\n    const errv = error.message.split(\" \");\n    if (errv[0] === \"MOVED\") {\n      const timeout = this.options.retryDelayOnMoved;\n      if (timeout && typeof timeout === \"number\") {\n        this.delayQueue.push(\"moved\", handlers.moved.bind(null, errv[1], errv[2]), {\n          timeout\n        });\n      } else {\n        handlers.moved(errv[1], errv[2]);\n      }\n    } else if (errv[0] === \"ASK\") {\n      handlers.ask(errv[1], errv[2]);\n    } else if (errv[0] === \"TRYAGAIN\") {\n      this.delayQueue.push(\"tryagain\", handlers.tryagain, {\n        timeout: this.options.retryDelayOnTryAgain\n      });\n    } else if (errv[0] === \"CLUSTERDOWN\" && this.options.retryDelayOnClusterDown > 0) {\n      this.delayQueue.push(\"clusterdown\", handlers.connectionClosed, {\n        timeout: this.options.retryDelayOnClusterDown,\n        callback: this.refreshSlotsCache.bind(this)\n      });\n    } else if (error.message === utils_1.CONNECTION_CLOSED_ERROR_MSG && this.options.retryDelayOnFailover > 0 && this.status === \"ready\") {\n      this.delayQueue.push(\"failover\", handlers.connectionClosed, {\n        timeout: this.options.retryDelayOnFailover,\n        callback: this.refreshSlotsCache.bind(this)\n      });\n    } else {\n      handlers.defaults();\n    }\n  }\n  resetOfflineQueue() {\n    this.offlineQueue = new Deque();\n  }\n  clearNodesRefreshInterval() {\n    if (this.slotsTimer) {\n      clearTimeout(this.slotsTimer);\n      this.slotsTimer = null;\n    }\n  }\n  resetNodesRefreshInterval() {\n    if (this.slotsTimer || !this.options.slotsRefreshInterval) {\n      return;\n    }\n    const nextRound = () => {\n      this.slotsTimer = setTimeout(() => {\n        debug('refreshing slot caches... (triggered by \"slotsRefreshInterval\" option)');\n        this.refreshSlotsCache(() => {\n          nextRound();\n        });\n      }, this.options.slotsRefreshInterval);\n    };\n    nextRound();\n  }\n  /**\n   * Change cluster instance's status\n   */\n  setStatus(status) {\n    debug(\"status: %s -> %s\", this.status || \"[empty]\", status);\n    this.status = status;\n    process.nextTick(() => {\n      this.emit(status);\n    });\n  }\n  /**\n   * Called when closed to check whether a reconnection should be made\n   */\n  handleCloseEvent(reason) {\n    if (reason) {\n      debug(\"closed because %s\", reason);\n    }\n    let retryDelay;\n    if (!this.manuallyClosing && typeof this.options.clusterRetryStrategy === \"function\") {\n      retryDelay = this.options.clusterRetryStrategy.call(this, ++this.retryAttempts, reason);\n    }\n    if (typeof retryDelay === \"number\") {\n      this.setStatus(\"reconnecting\");\n      this.reconnectTimeout = setTimeout(() => {\n        this.reconnectTimeout = null;\n        debug(\"Cluster is disconnected. Retrying after %dms\", retryDelay);\n        this.connect().catch(function (err) {\n          debug(\"Got error %s when reconnecting. Ignoring...\", err);\n        });\n      }, retryDelay);\n    } else {\n      this.setStatus(\"end\");\n      this.flushQueue(new Error(\"None of startup nodes is available\"));\n    }\n  }\n  /**\n   * Flush offline queue with error.\n   */\n  flushQueue(error) {\n    let item;\n    while (item = this.offlineQueue.shift()) {\n      item.command.reject(error);\n    }\n  }\n  executeOfflineCommands() {\n    if (this.offlineQueue.length) {\n      debug(\"send %d commands in offline queue\", this.offlineQueue.length);\n      const offlineQueue = this.offlineQueue;\n      this.resetOfflineQueue();\n      let item;\n      while (item = offlineQueue.shift()) {\n        this.sendCommand(item.command, item.stream, item.node);\n      }\n    }\n  }\n  natMapper(nodeKey) {\n    if (this.options.natMap && typeof this.options.natMap === \"object\") {\n      const key = typeof nodeKey === \"string\" ? nodeKey : `${nodeKey.host}:${nodeKey.port}`;\n      const mapped = this.options.natMap[key];\n      if (mapped) {\n        debug(\"NAT mapping %s -> %O\", key, mapped);\n        return Object.assign({}, mapped);\n      }\n    }\n    return typeof nodeKey === \"string\" ? (0, util_1.nodeKeyToRedisOptions)(nodeKey) : nodeKey;\n  }\n  getInfoFromNode(redis, callback) {\n    if (!redis) {\n      return callback(new Error(\"Node is disconnected\"));\n    }\n    // Use a duplication of the connection to avoid\n    // timeouts when the connection is in the blocking\n    // mode (e.g. waiting for BLPOP).\n    const duplicatedConnection = redis.duplicate({\n      enableOfflineQueue: true,\n      enableReadyCheck: false,\n      retryStrategy: null,\n      connectionName: (0, util_1.getConnectionName)(\"refresher\", this.options.redisOptions && this.options.redisOptions.connectionName)\n    });\n    // Ignore error events since we will handle\n    // exceptions for the CLUSTER SLOTS command.\n    duplicatedConnection.on(\"error\", utils_1.noop);\n    duplicatedConnection.cluster(\"SLOTS\", (0, utils_1.timeout)((err, result) => {\n      duplicatedConnection.disconnect();\n      if (err) {\n        return callback(err);\n      }\n      if (this.status === \"disconnecting\" || this.status === \"close\" || this.status === \"end\") {\n        debug(\"ignore CLUSTER.SLOTS results (count: %d) since cluster status is %s\", result.length, this.status);\n        callback();\n        return;\n      }\n      const nodes = [];\n      debug(\"cluster slots result count: %d\", result.length);\n      for (let i = 0; i < result.length; ++i) {\n        const items = result[i];\n        const slotRangeStart = items[0];\n        const slotRangeEnd = items[1];\n        const keys = [];\n        for (let j = 2; j < items.length; j++) {\n          if (!items[j][0]) {\n            continue;\n          }\n          const node = this.natMapper({\n            host: items[j][0],\n            port: items[j][1]\n          });\n          node.readOnly = j !== 2;\n          nodes.push(node);\n          keys.push(node.host + \":\" + node.port);\n        }\n        debug(\"cluster slots result [%d]: slots %d~%d served by %s\", i, slotRangeStart, slotRangeEnd, keys);\n        for (let slot = slotRangeStart; slot <= slotRangeEnd; slot++) {\n          this.slots[slot] = keys;\n        }\n      }\n      // Assign to each node keys a numeric value to make autopipeline comparison faster.\n      this._groupsIds = Object.create(null);\n      let j = 0;\n      for (let i = 0; i < 16384; i++) {\n        const target = (this.slots[i] || []).join(\";\");\n        if (!target.length) {\n          this._groupsBySlot[i] = undefined;\n          continue;\n        }\n        if (!this._groupsIds[target]) {\n          this._groupsIds[target] = ++j;\n        }\n        this._groupsBySlot[i] = this._groupsIds[target];\n      }\n      this.connectionPool.reset(nodes);\n      callback();\n    }, this.options.slotsRefreshTimeout));\n  }\n  invokeReadyDelayedCallbacks(err) {\n    for (const c of this._readyDelayedCallbacks) {\n      process.nextTick(c, err);\n    }\n    this._readyDelayedCallbacks = [];\n  }\n  /**\n   * Check whether Cluster is able to process commands\n   */\n  readyCheck(callback) {\n    this.cluster(\"INFO\", (err, res) => {\n      if (err) {\n        return callback(err);\n      }\n      if (typeof res !== \"string\") {\n        return callback();\n      }\n      let state;\n      const lines = res.split(\"\\r\\n\");\n      for (let i = 0; i < lines.length; ++i) {\n        const parts = lines[i].split(\":\");\n        if (parts[0] === \"cluster_state\") {\n          state = parts[1];\n          break;\n        }\n      }\n      if (state === \"fail\") {\n        debug(\"cluster state not ok (%s)\", state);\n        callback(null, state);\n      } else {\n        callback();\n      }\n    });\n  }\n  resolveSrv(hostname) {\n    return new Promise((resolve, reject) => {\n      this.options.resolveSrv(hostname, (err, records) => {\n        if (err) {\n          return reject(err);\n        }\n        const self = this,\n          groupedRecords = (0, util_1.groupSrvRecords)(records),\n          sortedKeys = Object.keys(groupedRecords).sort((a, b) => parseInt(a) - parseInt(b));\n        function tryFirstOne(err) {\n          if (!sortedKeys.length) {\n            return reject(err);\n          }\n          const key = sortedKeys[0],\n            group = groupedRecords[key],\n            record = (0, util_1.weightSrvRecords)(group);\n          if (!group.records.length) {\n            sortedKeys.shift();\n          }\n          self.dnsLookup(record.name).then(host => resolve({\n            host,\n            port: record.port\n          }), tryFirstOne);\n        }\n        tryFirstOne();\n      });\n    });\n  }\n  dnsLookup(hostname) {\n    return new Promise((resolve, reject) => {\n      this.options.dnsLookup(hostname, (err, address) => {\n        if (err) {\n          debug(\"failed to resolve hostname %s to IP: %s\", hostname, err.message);\n          reject(err);\n        } else {\n          debug(\"resolved hostname %s to IP %s\", hostname, address);\n          resolve(address);\n        }\n      });\n    });\n  }\n  /**\n   * Normalize startup nodes, and resolving hostnames to IPs.\n   *\n   * This process happens every time when #connect() is called since\n   * #startupNodes and DNS records may chanage.\n   */\n  async resolveStartupNodeHostnames() {\n    if (!Array.isArray(this.startupNodes) || this.startupNodes.length === 0) {\n      throw new Error(\"`startupNodes` should contain at least one node.\");\n    }\n    const startupNodes = (0, util_1.normalizeNodeOptions)(this.startupNodes);\n    const hostnames = (0, util_1.getUniqueHostnamesFromOptions)(startupNodes);\n    if (hostnames.length === 0) {\n      return startupNodes;\n    }\n    const configs = await Promise.all(hostnames.map((this.options.useSRVRecords ? this.resolveSrv : this.dnsLookup).bind(this)));\n    const hostnameToConfig = (0, utils_1.zipMap)(hostnames, configs);\n    return startupNodes.map(node => {\n      const config = hostnameToConfig.get(node.host);\n      if (!config) {\n        return node;\n      }\n      if (this.options.useSRVRecords) {\n        return Object.assign({}, node, config);\n      }\n      return Object.assign({}, node, {\n        host: config\n      });\n    });\n  }\n  createScanStream(command, {\n    key,\n    options = {}\n  }) {\n    return new ScanStream_1.default({\n      objectMode: true,\n      key: key,\n      redis: this,\n      command: command,\n      ...options\n    });\n  }\n}\n(0, applyMixin_1.default)(Cluster, events_1.EventEmitter);\n(0, transaction_1.addTransactionSupport)(Cluster.prototype);\nexports.default = Cluster;","map":{"version":3,"names":["Object","defineProperty","exports","value","commands_1","require","events_1","redis_errors_1","standard_as_callback_1","Command_1","ClusterAllFailedError_1","Redis_1","ScanStream_1","transaction_1","utils_1","applyMixin_1","Commander_1","ClusterOptions_1","ClusterSubscriber_1","ConnectionPool_1","DelayQueue_1","util_1","Deque","debug","Debug","REJECT_OVERWRITTEN_COMMANDS","WeakSet","Cluster","default","constructor","startupNodes","options","slots","_groupsIds","_groupsBySlot","Array","isCluster","retryAttempts","delayQueue","offlineQueue","isRefreshing","_refreshSlotsCacheCallbacks","_autoPipelines","Map","_runningAutoPipelines","Set","_readyDelayedCallbacks","connectionEpoch","EventEmitter","call","defaults","DEFAULT_CLUSTER_OPTIONS","redisOptions","keyPrefix","scaleReads","indexOf","Error","connectionPool","on","redis","key","emit","setStatus","error","subscriber","scripts","entries","forEach","name","definition","defineCommand","lazyConnect","connect","catch","err","Promise","resolve","reject","status","epoch","resolveStartupNodeHostnames","then","nodes","RedisError","reset","readyHandler","executeOfflineCommands","resetNodesRefreshInterval","closeListener","undefined","refreshListener","invokeReadyDelayedCallbacks","removeListener","manuallyClosing","enableReadyCheck","readyCheck","fail","disconnect","once","handleCloseEvent","bind","refreshSlotsCache","message","defaultMessage","prototype","silentEmit","start","reconnect","reconnectTimeout","clearTimeout","clearNodesRefreshInterval","stop","quit","callback","ret","setImmediate","all","map","node","CONNECTION_CLOSED_ERROR_MSG","duplicate","overrideStartupNodes","overrideOptions","length","slice","assign","role","getNodes","delayUntilReady","push","autoPipelineQueueSize","queued","pipeline","values","_this","wrapper","shuffle","lastNodeError","tryNode","index","host","port","getInfoFromNode","sendCommand","command","stream","noop","promise","to","isCommandReadOnly","isReadOnly","exists","hasFlag","targetSlot","slot","getSlot","ttl","has","add","partialTry","tryConnection","handleError","moved","Number","join","findOrCreate","natMapper","ask","mapped","tryagain","clusterDown","connectionClosed","maxRedirections","redirectionError","random","asking","AbortError","checkFlag","getInstance","nodeKeys","getInstanceByKey","isArray","sample","getSampleInstance","enableOfflineQueue","sscanStream","createScanStream","sscanBufferStream","hscanStream","hscanBufferStream","zscanStream","zscanBufferStream","handlers","errv","split","timeout","retryDelayOnMoved","retryDelayOnTryAgain","retryDelayOnClusterDown","retryDelayOnFailover","resetOfflineQueue","slotsTimer","slotsRefreshInterval","nextRound","setTimeout","process","nextTick","reason","retryDelay","clusterRetryStrategy","flushQueue","item","shift","nodeKey","natMap","nodeKeyToRedisOptions","duplicatedConnection","retryStrategy","connectionName","getConnectionName","cluster","result","i","items","slotRangeStart","slotRangeEnd","keys","j","readOnly","create","target","slotsRefreshTimeout","c","res","state","lines","parts","resolveSrv","hostname","records","self","groupedRecords","groupSrvRecords","sortedKeys","sort","a","b","parseInt","tryFirstOne","group","record","weightSrvRecords","dnsLookup","address","normalizeNodeOptions","hostnames","getUniqueHostnamesFromOptions","configs","useSRVRecords","hostnameToConfig","zipMap","config","get","objectMode","addTransactionSupport"],"sources":["C:/rgraph/node_modules/ioredis/built/cluster/index.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst commands_1 = require(\"@ioredis/commands\");\nconst events_1 = require(\"events\");\nconst redis_errors_1 = require(\"redis-errors\");\nconst standard_as_callback_1 = require(\"standard-as-callback\");\nconst Command_1 = require(\"../Command\");\nconst ClusterAllFailedError_1 = require(\"../errors/ClusterAllFailedError\");\nconst Redis_1 = require(\"../Redis\");\nconst ScanStream_1 = require(\"../ScanStream\");\nconst transaction_1 = require(\"../transaction\");\nconst utils_1 = require(\"../utils\");\nconst applyMixin_1 = require(\"../utils/applyMixin\");\nconst Commander_1 = require(\"../utils/Commander\");\nconst ClusterOptions_1 = require(\"./ClusterOptions\");\nconst ClusterSubscriber_1 = require(\"./ClusterSubscriber\");\nconst ConnectionPool_1 = require(\"./ConnectionPool\");\nconst DelayQueue_1 = require(\"./DelayQueue\");\nconst util_1 = require(\"./util\");\nconst Deque = require(\"denque\");\nconst debug = (0, utils_1.Debug)(\"cluster\");\nconst REJECT_OVERWRITTEN_COMMANDS = new WeakSet();\n/**\n * Client for the official Redis Cluster\n */\nclass Cluster extends Commander_1.default {\n    /**\n     * Creates an instance of Cluster.\n     */\n    constructor(startupNodes, options = {}) {\n        super();\n        this.slots = [];\n        /**\n         * @ignore\n         */\n        this._groupsIds = {};\n        /**\n         * @ignore\n         */\n        this._groupsBySlot = Array(16384);\n        /**\n         * @ignore\n         */\n        this.isCluster = true;\n        this.retryAttempts = 0;\n        this.delayQueue = new DelayQueue_1.default();\n        this.offlineQueue = new Deque();\n        this.isRefreshing = false;\n        this._refreshSlotsCacheCallbacks = [];\n        this._autoPipelines = new Map();\n        this._runningAutoPipelines = new Set();\n        this._readyDelayedCallbacks = [];\n        /**\n         * Every time Cluster#connect() is called, this value will be\n         * auto-incrementing. The purpose of this value is used for\n         * discarding previous connect attampts when creating a new\n         * connection.\n         */\n        this.connectionEpoch = 0;\n        events_1.EventEmitter.call(this);\n        this.startupNodes = startupNodes;\n        this.options = (0, utils_1.defaults)({}, options, ClusterOptions_1.DEFAULT_CLUSTER_OPTIONS, this.options);\n        if (this.options.redisOptions &&\n            this.options.redisOptions.keyPrefix &&\n            !this.options.keyPrefix) {\n            this.options.keyPrefix = this.options.redisOptions.keyPrefix;\n        }\n        // validate options\n        if (typeof this.options.scaleReads !== \"function\" &&\n            [\"all\", \"master\", \"slave\"].indexOf(this.options.scaleReads) === -1) {\n            throw new Error('Invalid option scaleReads \"' +\n                this.options.scaleReads +\n                '\". Expected \"all\", \"master\", \"slave\" or a custom function');\n        }\n        this.connectionPool = new ConnectionPool_1.default(this.options.redisOptions);\n        this.connectionPool.on(\"-node\", (redis, key) => {\n            this.emit(\"-node\", redis);\n        });\n        this.connectionPool.on(\"+node\", (redis) => {\n            this.emit(\"+node\", redis);\n        });\n        this.connectionPool.on(\"drain\", () => {\n            this.setStatus(\"close\");\n        });\n        this.connectionPool.on(\"nodeError\", (error, key) => {\n            this.emit(\"node error\", error, key);\n        });\n        this.subscriber = new ClusterSubscriber_1.default(this.connectionPool, this);\n        if (this.options.scripts) {\n            Object.entries(this.options.scripts).forEach(([name, definition]) => {\n                this.defineCommand(name, definition);\n            });\n        }\n        if (this.options.lazyConnect) {\n            this.setStatus(\"wait\");\n        }\n        else {\n            this.connect().catch((err) => {\n                debug(\"connecting failed: %s\", err);\n            });\n        }\n    }\n    /**\n     * Connect to a cluster\n     */\n    connect() {\n        return new Promise((resolve, reject) => {\n            if (this.status === \"connecting\" ||\n                this.status === \"connect\" ||\n                this.status === \"ready\") {\n                reject(new Error(\"Redis is already connecting/connected\"));\n                return;\n            }\n            const epoch = ++this.connectionEpoch;\n            this.setStatus(\"connecting\");\n            this.resolveStartupNodeHostnames()\n                .then((nodes) => {\n                if (this.connectionEpoch !== epoch) {\n                    debug(\"discard connecting after resolving startup nodes because epoch not match: %d != %d\", epoch, this.connectionEpoch);\n                    reject(new redis_errors_1.RedisError(\"Connection is discarded because a new connection is made\"));\n                    return;\n                }\n                if (this.status !== \"connecting\") {\n                    debug(\"discard connecting after resolving startup nodes because the status changed to %s\", this.status);\n                    reject(new redis_errors_1.RedisError(\"Connection is aborted\"));\n                    return;\n                }\n                this.connectionPool.reset(nodes);\n                const readyHandler = () => {\n                    this.setStatus(\"ready\");\n                    this.retryAttempts = 0;\n                    this.executeOfflineCommands();\n                    this.resetNodesRefreshInterval();\n                    resolve();\n                };\n                let closeListener = undefined;\n                const refreshListener = () => {\n                    this.invokeReadyDelayedCallbacks(undefined);\n                    this.removeListener(\"close\", closeListener);\n                    this.manuallyClosing = false;\n                    this.setStatus(\"connect\");\n                    if (this.options.enableReadyCheck) {\n                        this.readyCheck((err, fail) => {\n                            if (err || fail) {\n                                debug(\"Ready check failed (%s). Reconnecting...\", err || fail);\n                                if (this.status === \"connect\") {\n                                    this.disconnect(true);\n                                }\n                            }\n                            else {\n                                readyHandler();\n                            }\n                        });\n                    }\n                    else {\n                        readyHandler();\n                    }\n                };\n                closeListener = () => {\n                    const error = new Error(\"None of startup nodes is available\");\n                    this.removeListener(\"refresh\", refreshListener);\n                    this.invokeReadyDelayedCallbacks(error);\n                    reject(error);\n                };\n                this.once(\"refresh\", refreshListener);\n                this.once(\"close\", closeListener);\n                this.once(\"close\", this.handleCloseEvent.bind(this));\n                this.refreshSlotsCache((err) => {\n                    if (err && err.message === ClusterAllFailedError_1.default.defaultMessage) {\n                        Redis_1.default.prototype.silentEmit.call(this, \"error\", err);\n                        this.connectionPool.reset([]);\n                    }\n                });\n                this.subscriber.start();\n            })\n                .catch((err) => {\n                this.setStatus(\"close\");\n                this.handleCloseEvent(err);\n                this.invokeReadyDelayedCallbacks(err);\n                reject(err);\n            });\n        });\n    }\n    /**\n     * Disconnect from every node in the cluster.\n     */\n    disconnect(reconnect = false) {\n        const status = this.status;\n        this.setStatus(\"disconnecting\");\n        if (!reconnect) {\n            this.manuallyClosing = true;\n        }\n        if (this.reconnectTimeout && !reconnect) {\n            clearTimeout(this.reconnectTimeout);\n            this.reconnectTimeout = null;\n            debug(\"Canceled reconnecting attempts\");\n        }\n        this.clearNodesRefreshInterval();\n        this.subscriber.stop();\n        if (status === \"wait\") {\n            this.setStatus(\"close\");\n            this.handleCloseEvent();\n        }\n        else {\n            this.connectionPool.reset([]);\n        }\n    }\n    /**\n     * Quit the cluster gracefully.\n     */\n    quit(callback) {\n        const status = this.status;\n        this.setStatus(\"disconnecting\");\n        this.manuallyClosing = true;\n        if (this.reconnectTimeout) {\n            clearTimeout(this.reconnectTimeout);\n            this.reconnectTimeout = null;\n        }\n        this.clearNodesRefreshInterval();\n        this.subscriber.stop();\n        if (status === \"wait\") {\n            const ret = (0, standard_as_callback_1.default)(Promise.resolve(\"OK\"), callback);\n            // use setImmediate to make sure \"close\" event\n            // being emitted after quit() is returned\n            setImmediate(function () {\n                this.setStatus(\"close\");\n                this.handleCloseEvent();\n            }.bind(this));\n            return ret;\n        }\n        return (0, standard_as_callback_1.default)(Promise.all(this.nodes().map((node) => node.quit().catch((err) => {\n            // Ignore the error caused by disconnecting since\n            // we're disconnecting...\n            if (err.message === utils_1.CONNECTION_CLOSED_ERROR_MSG) {\n                return \"OK\";\n            }\n            throw err;\n        }))).then(() => \"OK\"), callback);\n    }\n    /**\n     * Create a new instance with the same startup nodes and options as the current one.\n     *\n     * @example\n     * ```js\n     * var cluster = new Redis.Cluster([{ host: \"127.0.0.1\", port: \"30001\" }]);\n     * var anotherCluster = cluster.duplicate();\n     * ```\n     */\n    duplicate(overrideStartupNodes = [], overrideOptions = {}) {\n        const startupNodes = overrideStartupNodes.length > 0\n            ? overrideStartupNodes\n            : this.startupNodes.slice(0);\n        const options = Object.assign({}, this.options, overrideOptions);\n        return new Cluster(startupNodes, options);\n    }\n    /**\n     * Get nodes with the specified role\n     */\n    nodes(role = \"all\") {\n        if (role !== \"all\" && role !== \"master\" && role !== \"slave\") {\n            throw new Error('Invalid role \"' + role + '\". Expected \"all\", \"master\" or \"slave\"');\n        }\n        return this.connectionPool.getNodes(role);\n    }\n    /**\n     * This is needed in order not to install a listener for each auto pipeline\n     *\n     * @ignore\n     */\n    delayUntilReady(callback) {\n        this._readyDelayedCallbacks.push(callback);\n    }\n    /**\n     * Get the number of commands queued in automatic pipelines.\n     *\n     * This is not available (and returns 0) until the cluster is connected and slots information have been received.\n     */\n    get autoPipelineQueueSize() {\n        let queued = 0;\n        for (const pipeline of this._autoPipelines.values()) {\n            queued += pipeline.length;\n        }\n        return queued;\n    }\n    /**\n     * Refresh the slot cache\n     *\n     * @ignore\n     */\n    refreshSlotsCache(callback) {\n        if (callback) {\n            this._refreshSlotsCacheCallbacks.push(callback);\n        }\n        if (this.isRefreshing) {\n            return;\n        }\n        this.isRefreshing = true;\n        const _this = this;\n        const wrapper = (error) => {\n            this.isRefreshing = false;\n            for (const callback of this._refreshSlotsCacheCallbacks) {\n                callback(error);\n            }\n            this._refreshSlotsCacheCallbacks = [];\n        };\n        const nodes = (0, utils_1.shuffle)(this.connectionPool.getNodes());\n        let lastNodeError = null;\n        function tryNode(index) {\n            if (index === nodes.length) {\n                const error = new ClusterAllFailedError_1.default(ClusterAllFailedError_1.default.defaultMessage, lastNodeError);\n                return wrapper(error);\n            }\n            const node = nodes[index];\n            const key = `${node.options.host}:${node.options.port}`;\n            debug(\"getting slot cache from %s\", key);\n            _this.getInfoFromNode(node, function (err) {\n                switch (_this.status) {\n                    case \"close\":\n                    case \"end\":\n                        return wrapper(new Error(\"Cluster is disconnected.\"));\n                    case \"disconnecting\":\n                        return wrapper(new Error(\"Cluster is disconnecting.\"));\n                }\n                if (err) {\n                    _this.emit(\"node error\", err, key);\n                    lastNodeError = err;\n                    tryNode(index + 1);\n                }\n                else {\n                    _this.emit(\"refresh\");\n                    wrapper();\n                }\n            });\n        }\n        tryNode(0);\n    }\n    /**\n     * @ignore\n     */\n    sendCommand(command, stream, node) {\n        if (this.status === \"wait\") {\n            this.connect().catch(utils_1.noop);\n        }\n        if (this.status === \"end\") {\n            command.reject(new Error(utils_1.CONNECTION_CLOSED_ERROR_MSG));\n            return command.promise;\n        }\n        let to = this.options.scaleReads;\n        if (to !== \"master\") {\n            const isCommandReadOnly = command.isReadOnly ||\n                ((0, commands_1.exists)(command.name) && (0, commands_1.hasFlag)(command.name, \"readonly\"));\n            if (!isCommandReadOnly) {\n                to = \"master\";\n            }\n        }\n        let targetSlot = node ? node.slot : command.getSlot();\n        const ttl = {};\n        const _this = this;\n        if (!node && !REJECT_OVERWRITTEN_COMMANDS.has(command)) {\n            REJECT_OVERWRITTEN_COMMANDS.add(command);\n            const reject = command.reject;\n            command.reject = function (err) {\n                const partialTry = tryConnection.bind(null, true);\n                _this.handleError(err, ttl, {\n                    moved: function (slot, key) {\n                        debug(\"command %s is moved to %s\", command.name, key);\n                        targetSlot = Number(slot);\n                        if (_this.slots[slot]) {\n                            _this.slots[slot][0] = key;\n                        }\n                        else {\n                            _this.slots[slot] = [key];\n                        }\n                        _this._groupsBySlot[slot] =\n                            _this._groupsIds[_this.slots[slot].join(\";\")];\n                        _this.connectionPool.findOrCreate(_this.natMapper(key));\n                        tryConnection();\n                        debug(\"refreshing slot caches... (triggered by MOVED error)\");\n                        _this.refreshSlotsCache();\n                    },\n                    ask: function (slot, key) {\n                        debug(\"command %s is required to ask %s:%s\", command.name, key);\n                        const mapped = _this.natMapper(key);\n                        _this.connectionPool.findOrCreate(mapped);\n                        tryConnection(false, `${mapped.host}:${mapped.port}`);\n                    },\n                    tryagain: partialTry,\n                    clusterDown: partialTry,\n                    connectionClosed: partialTry,\n                    maxRedirections: function (redirectionError) {\n                        reject.call(command, redirectionError);\n                    },\n                    defaults: function () {\n                        reject.call(command, err);\n                    },\n                });\n            };\n        }\n        tryConnection();\n        function tryConnection(random, asking) {\n            if (_this.status === \"end\") {\n                command.reject(new redis_errors_1.AbortError(\"Cluster is ended.\"));\n                return;\n            }\n            let redis;\n            if (_this.status === \"ready\" || command.name === \"cluster\") {\n                if (node && node.redis) {\n                    redis = node.redis;\n                }\n                else if (Command_1.default.checkFlag(\"ENTER_SUBSCRIBER_MODE\", command.name) ||\n                    Command_1.default.checkFlag(\"EXIT_SUBSCRIBER_MODE\", command.name)) {\n                    redis = _this.subscriber.getInstance();\n                    if (!redis) {\n                        command.reject(new redis_errors_1.AbortError(\"No subscriber for the cluster\"));\n                        return;\n                    }\n                }\n                else {\n                    if (!random) {\n                        if (typeof targetSlot === \"number\" && _this.slots[targetSlot]) {\n                            const nodeKeys = _this.slots[targetSlot];\n                            if (typeof to === \"function\") {\n                                const nodes = nodeKeys.map(function (key) {\n                                    return _this.connectionPool.getInstanceByKey(key);\n                                });\n                                redis = to(nodes, command);\n                                if (Array.isArray(redis)) {\n                                    redis = (0, utils_1.sample)(redis);\n                                }\n                                if (!redis) {\n                                    redis = nodes[0];\n                                }\n                            }\n                            else {\n                                let key;\n                                if (to === \"all\") {\n                                    key = (0, utils_1.sample)(nodeKeys);\n                                }\n                                else if (to === \"slave\" && nodeKeys.length > 1) {\n                                    key = (0, utils_1.sample)(nodeKeys, 1);\n                                }\n                                else {\n                                    key = nodeKeys[0];\n                                }\n                                redis = _this.connectionPool.getInstanceByKey(key);\n                            }\n                        }\n                        if (asking) {\n                            redis = _this.connectionPool.getInstanceByKey(asking);\n                            redis.asking();\n                        }\n                    }\n                    if (!redis) {\n                        redis =\n                            (typeof to === \"function\"\n                                ? null\n                                : _this.connectionPool.getSampleInstance(to)) ||\n                                _this.connectionPool.getSampleInstance(\"all\");\n                    }\n                }\n                if (node && !node.redis) {\n                    node.redis = redis;\n                }\n            }\n            if (redis) {\n                redis.sendCommand(command, stream);\n            }\n            else if (_this.options.enableOfflineQueue) {\n                _this.offlineQueue.push({\n                    command: command,\n                    stream: stream,\n                    node: node,\n                });\n            }\n            else {\n                command.reject(new Error(\"Cluster isn't ready and enableOfflineQueue options is false\"));\n            }\n        }\n        return command.promise;\n    }\n    sscanStream(key, options) {\n        return this.createScanStream(\"sscan\", { key, options });\n    }\n    sscanBufferStream(key, options) {\n        return this.createScanStream(\"sscanBuffer\", { key, options });\n    }\n    hscanStream(key, options) {\n        return this.createScanStream(\"hscan\", { key, options });\n    }\n    hscanBufferStream(key, options) {\n        return this.createScanStream(\"hscanBuffer\", { key, options });\n    }\n    zscanStream(key, options) {\n        return this.createScanStream(\"zscan\", { key, options });\n    }\n    zscanBufferStream(key, options) {\n        return this.createScanStream(\"zscanBuffer\", { key, options });\n    }\n    /**\n     * @ignore\n     */\n    handleError(error, ttl, handlers) {\n        if (typeof ttl.value === \"undefined\") {\n            ttl.value = this.options.maxRedirections;\n        }\n        else {\n            ttl.value -= 1;\n        }\n        if (ttl.value <= 0) {\n            handlers.maxRedirections(new Error(\"Too many Cluster redirections. Last error: \" + error));\n            return;\n        }\n        const errv = error.message.split(\" \");\n        if (errv[0] === \"MOVED\") {\n            const timeout = this.options.retryDelayOnMoved;\n            if (timeout && typeof timeout === \"number\") {\n                this.delayQueue.push(\"moved\", handlers.moved.bind(null, errv[1], errv[2]), { timeout });\n            }\n            else {\n                handlers.moved(errv[1], errv[2]);\n            }\n        }\n        else if (errv[0] === \"ASK\") {\n            handlers.ask(errv[1], errv[2]);\n        }\n        else if (errv[0] === \"TRYAGAIN\") {\n            this.delayQueue.push(\"tryagain\", handlers.tryagain, {\n                timeout: this.options.retryDelayOnTryAgain,\n            });\n        }\n        else if (errv[0] === \"CLUSTERDOWN\" &&\n            this.options.retryDelayOnClusterDown > 0) {\n            this.delayQueue.push(\"clusterdown\", handlers.connectionClosed, {\n                timeout: this.options.retryDelayOnClusterDown,\n                callback: this.refreshSlotsCache.bind(this),\n            });\n        }\n        else if (error.message === utils_1.CONNECTION_CLOSED_ERROR_MSG &&\n            this.options.retryDelayOnFailover > 0 &&\n            this.status === \"ready\") {\n            this.delayQueue.push(\"failover\", handlers.connectionClosed, {\n                timeout: this.options.retryDelayOnFailover,\n                callback: this.refreshSlotsCache.bind(this),\n            });\n        }\n        else {\n            handlers.defaults();\n        }\n    }\n    resetOfflineQueue() {\n        this.offlineQueue = new Deque();\n    }\n    clearNodesRefreshInterval() {\n        if (this.slotsTimer) {\n            clearTimeout(this.slotsTimer);\n            this.slotsTimer = null;\n        }\n    }\n    resetNodesRefreshInterval() {\n        if (this.slotsTimer || !this.options.slotsRefreshInterval) {\n            return;\n        }\n        const nextRound = () => {\n            this.slotsTimer = setTimeout(() => {\n                debug('refreshing slot caches... (triggered by \"slotsRefreshInterval\" option)');\n                this.refreshSlotsCache(() => {\n                    nextRound();\n                });\n            }, this.options.slotsRefreshInterval);\n        };\n        nextRound();\n    }\n    /**\n     * Change cluster instance's status\n     */\n    setStatus(status) {\n        debug(\"status: %s -> %s\", this.status || \"[empty]\", status);\n        this.status = status;\n        process.nextTick(() => {\n            this.emit(status);\n        });\n    }\n    /**\n     * Called when closed to check whether a reconnection should be made\n     */\n    handleCloseEvent(reason) {\n        if (reason) {\n            debug(\"closed because %s\", reason);\n        }\n        let retryDelay;\n        if (!this.manuallyClosing &&\n            typeof this.options.clusterRetryStrategy === \"function\") {\n            retryDelay = this.options.clusterRetryStrategy.call(this, ++this.retryAttempts, reason);\n        }\n        if (typeof retryDelay === \"number\") {\n            this.setStatus(\"reconnecting\");\n            this.reconnectTimeout = setTimeout(() => {\n                this.reconnectTimeout = null;\n                debug(\"Cluster is disconnected. Retrying after %dms\", retryDelay);\n                this.connect().catch(function (err) {\n                    debug(\"Got error %s when reconnecting. Ignoring...\", err);\n                });\n            }, retryDelay);\n        }\n        else {\n            this.setStatus(\"end\");\n            this.flushQueue(new Error(\"None of startup nodes is available\"));\n        }\n    }\n    /**\n     * Flush offline queue with error.\n     */\n    flushQueue(error) {\n        let item;\n        while ((item = this.offlineQueue.shift())) {\n            item.command.reject(error);\n        }\n    }\n    executeOfflineCommands() {\n        if (this.offlineQueue.length) {\n            debug(\"send %d commands in offline queue\", this.offlineQueue.length);\n            const offlineQueue = this.offlineQueue;\n            this.resetOfflineQueue();\n            let item;\n            while ((item = offlineQueue.shift())) {\n                this.sendCommand(item.command, item.stream, item.node);\n            }\n        }\n    }\n    natMapper(nodeKey) {\n        if (this.options.natMap && typeof this.options.natMap === \"object\") {\n            const key = typeof nodeKey === \"string\"\n                ? nodeKey\n                : `${nodeKey.host}:${nodeKey.port}`;\n            const mapped = this.options.natMap[key];\n            if (mapped) {\n                debug(\"NAT mapping %s -> %O\", key, mapped);\n                return Object.assign({}, mapped);\n            }\n        }\n        return typeof nodeKey === \"string\"\n            ? (0, util_1.nodeKeyToRedisOptions)(nodeKey)\n            : nodeKey;\n    }\n    getInfoFromNode(redis, callback) {\n        if (!redis) {\n            return callback(new Error(\"Node is disconnected\"));\n        }\n        // Use a duplication of the connection to avoid\n        // timeouts when the connection is in the blocking\n        // mode (e.g. waiting for BLPOP).\n        const duplicatedConnection = redis.duplicate({\n            enableOfflineQueue: true,\n            enableReadyCheck: false,\n            retryStrategy: null,\n            connectionName: (0, util_1.getConnectionName)(\"refresher\", this.options.redisOptions && this.options.redisOptions.connectionName),\n        });\n        // Ignore error events since we will handle\n        // exceptions for the CLUSTER SLOTS command.\n        duplicatedConnection.on(\"error\", utils_1.noop);\n        duplicatedConnection.cluster(\"SLOTS\", (0, utils_1.timeout)((err, result) => {\n            duplicatedConnection.disconnect();\n            if (err) {\n                return callback(err);\n            }\n            if (this.status === \"disconnecting\" ||\n                this.status === \"close\" ||\n                this.status === \"end\") {\n                debug(\"ignore CLUSTER.SLOTS results (count: %d) since cluster status is %s\", result.length, this.status);\n                callback();\n                return;\n            }\n            const nodes = [];\n            debug(\"cluster slots result count: %d\", result.length);\n            for (let i = 0; i < result.length; ++i) {\n                const items = result[i];\n                const slotRangeStart = items[0];\n                const slotRangeEnd = items[1];\n                const keys = [];\n                for (let j = 2; j < items.length; j++) {\n                    if (!items[j][0]) {\n                        continue;\n                    }\n                    const node = this.natMapper({\n                        host: items[j][0],\n                        port: items[j][1],\n                    });\n                    node.readOnly = j !== 2;\n                    nodes.push(node);\n                    keys.push(node.host + \":\" + node.port);\n                }\n                debug(\"cluster slots result [%d]: slots %d~%d served by %s\", i, slotRangeStart, slotRangeEnd, keys);\n                for (let slot = slotRangeStart; slot <= slotRangeEnd; slot++) {\n                    this.slots[slot] = keys;\n                }\n            }\n            // Assign to each node keys a numeric value to make autopipeline comparison faster.\n            this._groupsIds = Object.create(null);\n            let j = 0;\n            for (let i = 0; i < 16384; i++) {\n                const target = (this.slots[i] || []).join(\";\");\n                if (!target.length) {\n                    this._groupsBySlot[i] = undefined;\n                    continue;\n                }\n                if (!this._groupsIds[target]) {\n                    this._groupsIds[target] = ++j;\n                }\n                this._groupsBySlot[i] = this._groupsIds[target];\n            }\n            this.connectionPool.reset(nodes);\n            callback();\n        }, this.options.slotsRefreshTimeout));\n    }\n    invokeReadyDelayedCallbacks(err) {\n        for (const c of this._readyDelayedCallbacks) {\n            process.nextTick(c, err);\n        }\n        this._readyDelayedCallbacks = [];\n    }\n    /**\n     * Check whether Cluster is able to process commands\n     */\n    readyCheck(callback) {\n        this.cluster(\"INFO\", (err, res) => {\n            if (err) {\n                return callback(err);\n            }\n            if (typeof res !== \"string\") {\n                return callback();\n            }\n            let state;\n            const lines = res.split(\"\\r\\n\");\n            for (let i = 0; i < lines.length; ++i) {\n                const parts = lines[i].split(\":\");\n                if (parts[0] === \"cluster_state\") {\n                    state = parts[1];\n                    break;\n                }\n            }\n            if (state === \"fail\") {\n                debug(\"cluster state not ok (%s)\", state);\n                callback(null, state);\n            }\n            else {\n                callback();\n            }\n        });\n    }\n    resolveSrv(hostname) {\n        return new Promise((resolve, reject) => {\n            this.options.resolveSrv(hostname, (err, records) => {\n                if (err) {\n                    return reject(err);\n                }\n                const self = this, groupedRecords = (0, util_1.groupSrvRecords)(records), sortedKeys = Object.keys(groupedRecords).sort((a, b) => parseInt(a) - parseInt(b));\n                function tryFirstOne(err) {\n                    if (!sortedKeys.length) {\n                        return reject(err);\n                    }\n                    const key = sortedKeys[0], group = groupedRecords[key], record = (0, util_1.weightSrvRecords)(group);\n                    if (!group.records.length) {\n                        sortedKeys.shift();\n                    }\n                    self.dnsLookup(record.name).then((host) => resolve({\n                        host,\n                        port: record.port,\n                    }), tryFirstOne);\n                }\n                tryFirstOne();\n            });\n        });\n    }\n    dnsLookup(hostname) {\n        return new Promise((resolve, reject) => {\n            this.options.dnsLookup(hostname, (err, address) => {\n                if (err) {\n                    debug(\"failed to resolve hostname %s to IP: %s\", hostname, err.message);\n                    reject(err);\n                }\n                else {\n                    debug(\"resolved hostname %s to IP %s\", hostname, address);\n                    resolve(address);\n                }\n            });\n        });\n    }\n    /**\n     * Normalize startup nodes, and resolving hostnames to IPs.\n     *\n     * This process happens every time when #connect() is called since\n     * #startupNodes and DNS records may chanage.\n     */\n    async resolveStartupNodeHostnames() {\n        if (!Array.isArray(this.startupNodes) || this.startupNodes.length === 0) {\n            throw new Error(\"`startupNodes` should contain at least one node.\");\n        }\n        const startupNodes = (0, util_1.normalizeNodeOptions)(this.startupNodes);\n        const hostnames = (0, util_1.getUniqueHostnamesFromOptions)(startupNodes);\n        if (hostnames.length === 0) {\n            return startupNodes;\n        }\n        const configs = await Promise.all(hostnames.map((this.options.useSRVRecords ? this.resolveSrv : this.dnsLookup).bind(this)));\n        const hostnameToConfig = (0, utils_1.zipMap)(hostnames, configs);\n        return startupNodes.map((node) => {\n            const config = hostnameToConfig.get(node.host);\n            if (!config) {\n                return node;\n            }\n            if (this.options.useSRVRecords) {\n                return Object.assign({}, node, config);\n            }\n            return Object.assign({}, node, { host: config });\n        });\n    }\n    createScanStream(command, { key, options = {} }) {\n        return new ScanStream_1.default({\n            objectMode: true,\n            key: key,\n            redis: this,\n            command: command,\n            ...options,\n        });\n    }\n}\n(0, applyMixin_1.default)(Cluster, events_1.EventEmitter);\n(0, transaction_1.addTransactionSupport)(Cluster.prototype);\nexports.default = Cluster;\n"],"mappings":"AAAA,YAAY;;AACZA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7D,MAAMC,UAAU,GAAGC,OAAO,CAAC,mBAAmB,CAAC;AAC/C,MAAMC,QAAQ,GAAGD,OAAO,CAAC,QAAQ,CAAC;AAClC,MAAME,cAAc,GAAGF,OAAO,CAAC,cAAc,CAAC;AAC9C,MAAMG,sBAAsB,GAAGH,OAAO,CAAC,sBAAsB,CAAC;AAC9D,MAAMI,SAAS,GAAGJ,OAAO,CAAC,YAAY,CAAC;AACvC,MAAMK,uBAAuB,GAAGL,OAAO,CAAC,iCAAiC,CAAC;AAC1E,MAAMM,OAAO,GAAGN,OAAO,CAAC,UAAU,CAAC;AACnC,MAAMO,YAAY,GAAGP,OAAO,CAAC,eAAe,CAAC;AAC7C,MAAMQ,aAAa,GAAGR,OAAO,CAAC,gBAAgB,CAAC;AAC/C,MAAMS,OAAO,GAAGT,OAAO,CAAC,UAAU,CAAC;AACnC,MAAMU,YAAY,GAAGV,OAAO,CAAC,qBAAqB,CAAC;AACnD,MAAMW,WAAW,GAAGX,OAAO,CAAC,oBAAoB,CAAC;AACjD,MAAMY,gBAAgB,GAAGZ,OAAO,CAAC,kBAAkB,CAAC;AACpD,MAAMa,mBAAmB,GAAGb,OAAO,CAAC,qBAAqB,CAAC;AAC1D,MAAMc,gBAAgB,GAAGd,OAAO,CAAC,kBAAkB,CAAC;AACpD,MAAMe,YAAY,GAAGf,OAAO,CAAC,cAAc,CAAC;AAC5C,MAAMgB,MAAM,GAAGhB,OAAO,CAAC,QAAQ,CAAC;AAChC,MAAMiB,KAAK,GAAGjB,OAAO,CAAC,QAAQ,CAAC;AAC/B,MAAMkB,KAAK,GAAG,CAAC,CAAC,EAAET,OAAO,CAACU,KAAK,EAAE,SAAS,CAAC;AAC3C,MAAMC,2BAA2B,GAAG,IAAIC,OAAO,CAAC,CAAC;AACjD;AACA;AACA;AACA,MAAMC,OAAO,SAASX,WAAW,CAACY,OAAO,CAAC;EACtC;AACJ;AACA;EACIC,WAAWA,CAACC,YAAY,EAAEC,OAAO,GAAG,CAAC,CAAC,EAAE;IACpC,KAAK,CAAC,CAAC;IACP,IAAI,CAACC,KAAK,GAAG,EAAE;IACf;AACR;AACA;IACQ,IAAI,CAACC,UAAU,GAAG,CAAC,CAAC;IACpB;AACR;AACA;IACQ,IAAI,CAACC,aAAa,GAAGC,KAAK,CAAC,KAAK,CAAC;IACjC;AACR;AACA;IACQ,IAAI,CAACC,SAAS,GAAG,IAAI;IACrB,IAAI,CAACC,aAAa,GAAG,CAAC;IACtB,IAAI,CAACC,UAAU,GAAG,IAAIlB,YAAY,CAACQ,OAAO,CAAC,CAAC;IAC5C,IAAI,CAACW,YAAY,GAAG,IAAIjB,KAAK,CAAC,CAAC;IAC/B,IAAI,CAACkB,YAAY,GAAG,KAAK;IACzB,IAAI,CAACC,2BAA2B,GAAG,EAAE;IACrC,IAAI,CAACC,cAAc,GAAG,IAAIC,GAAG,CAAC,CAAC;IAC/B,IAAI,CAACC,qBAAqB,GAAG,IAAIC,GAAG,CAAC,CAAC;IACtC,IAAI,CAACC,sBAAsB,GAAG,EAAE;IAChC;AACR;AACA;AACA;AACA;AACA;IACQ,IAAI,CAACC,eAAe,GAAG,CAAC;IACxBzC,QAAQ,CAAC0C,YAAY,CAACC,IAAI,CAAC,IAAI,CAAC;IAChC,IAAI,CAACnB,YAAY,GAAGA,YAAY;IAChC,IAAI,CAACC,OAAO,GAAG,CAAC,CAAC,EAAEjB,OAAO,CAACoC,QAAQ,EAAE,CAAC,CAAC,EAAEnB,OAAO,EAAEd,gBAAgB,CAACkC,uBAAuB,EAAE,IAAI,CAACpB,OAAO,CAAC;IACzG,IAAI,IAAI,CAACA,OAAO,CAACqB,YAAY,IACzB,IAAI,CAACrB,OAAO,CAACqB,YAAY,CAACC,SAAS,IACnC,CAAC,IAAI,CAACtB,OAAO,CAACsB,SAAS,EAAE;MACzB,IAAI,CAACtB,OAAO,CAACsB,SAAS,GAAG,IAAI,CAACtB,OAAO,CAACqB,YAAY,CAACC,SAAS;IAChE;IACA;IACA,IAAI,OAAO,IAAI,CAACtB,OAAO,CAACuB,UAAU,KAAK,UAAU,IAC7C,CAAC,KAAK,EAAE,QAAQ,EAAE,OAAO,CAAC,CAACC,OAAO,CAAC,IAAI,CAACxB,OAAO,CAACuB,UAAU,CAAC,KAAK,CAAC,CAAC,EAAE;MACpE,MAAM,IAAIE,KAAK,CAAC,6BAA6B,GACzC,IAAI,CAACzB,OAAO,CAACuB,UAAU,GACvB,2DAA2D,CAAC;IACpE;IACA,IAAI,CAACG,cAAc,GAAG,IAAItC,gBAAgB,CAACS,OAAO,CAAC,IAAI,CAACG,OAAO,CAACqB,YAAY,CAAC;IAC7E,IAAI,CAACK,cAAc,CAACC,EAAE,CAAC,OAAO,EAAE,CAACC,KAAK,EAAEC,GAAG,KAAK;MAC5C,IAAI,CAACC,IAAI,CAAC,OAAO,EAAEF,KAAK,CAAC;IAC7B,CAAC,CAAC;IACF,IAAI,CAACF,cAAc,CAACC,EAAE,CAAC,OAAO,EAAGC,KAAK,IAAK;MACvC,IAAI,CAACE,IAAI,CAAC,OAAO,EAAEF,KAAK,CAAC;IAC7B,CAAC,CAAC;IACF,IAAI,CAACF,cAAc,CAACC,EAAE,CAAC,OAAO,EAAE,MAAM;MAClC,IAAI,CAACI,SAAS,CAAC,OAAO,CAAC;IAC3B,CAAC,CAAC;IACF,IAAI,CAACL,cAAc,CAACC,EAAE,CAAC,WAAW,EAAE,CAACK,KAAK,EAAEH,GAAG,KAAK;MAChD,IAAI,CAACC,IAAI,CAAC,YAAY,EAAEE,KAAK,EAAEH,GAAG,CAAC;IACvC,CAAC,CAAC;IACF,IAAI,CAACI,UAAU,GAAG,IAAI9C,mBAAmB,CAACU,OAAO,CAAC,IAAI,CAAC6B,cAAc,EAAE,IAAI,CAAC;IAC5E,IAAI,IAAI,CAAC1B,OAAO,CAACkC,OAAO,EAAE;MACtBjE,MAAM,CAACkE,OAAO,CAAC,IAAI,CAACnC,OAAO,CAACkC,OAAO,CAAC,CAACE,OAAO,CAAC,CAAC,CAACC,IAAI,EAAEC,UAAU,CAAC,KAAK;QACjE,IAAI,CAACC,aAAa,CAACF,IAAI,EAAEC,UAAU,CAAC;MACxC,CAAC,CAAC;IACN;IACA,IAAI,IAAI,CAACtC,OAAO,CAACwC,WAAW,EAAE;MAC1B,IAAI,CAACT,SAAS,CAAC,MAAM,CAAC;IAC1B,CAAC,MACI;MACD,IAAI,CAACU,OAAO,CAAC,CAAC,CAACC,KAAK,CAAEC,GAAG,IAAK;QAC1BnD,KAAK,CAAC,uBAAuB,EAAEmD,GAAG,CAAC;MACvC,CAAC,CAAC;IACN;EACJ;EACA;AACJ;AACA;EACIF,OAAOA,CAAA,EAAG;IACN,OAAO,IAAIG,OAAO,CAAC,CAACC,OAAO,EAAEC,MAAM,KAAK;MACpC,IAAI,IAAI,CAACC,MAAM,KAAK,YAAY,IAC5B,IAAI,CAACA,MAAM,KAAK,SAAS,IACzB,IAAI,CAACA,MAAM,KAAK,OAAO,EAAE;QACzBD,MAAM,CAAC,IAAIrB,KAAK,CAAC,uCAAuC,CAAC,CAAC;QAC1D;MACJ;MACA,MAAMuB,KAAK,GAAG,EAAE,IAAI,CAAChC,eAAe;MACpC,IAAI,CAACe,SAAS,CAAC,YAAY,CAAC;MAC5B,IAAI,CAACkB,2BAA2B,CAAC,CAAC,CAC7BC,IAAI,CAAEC,KAAK,IAAK;QACjB,IAAI,IAAI,CAACnC,eAAe,KAAKgC,KAAK,EAAE;UAChCxD,KAAK,CAAC,oFAAoF,EAAEwD,KAAK,EAAE,IAAI,CAAChC,eAAe,CAAC;UACxH8B,MAAM,CAAC,IAAItE,cAAc,CAAC4E,UAAU,CAAC,0DAA0D,CAAC,CAAC;UACjG;QACJ;QACA,IAAI,IAAI,CAACL,MAAM,KAAK,YAAY,EAAE;UAC9BvD,KAAK,CAAC,mFAAmF,EAAE,IAAI,CAACuD,MAAM,CAAC;UACvGD,MAAM,CAAC,IAAItE,cAAc,CAAC4E,UAAU,CAAC,uBAAuB,CAAC,CAAC;UAC9D;QACJ;QACA,IAAI,CAAC1B,cAAc,CAAC2B,KAAK,CAACF,KAAK,CAAC;QAChC,MAAMG,YAAY,GAAGA,CAAA,KAAM;UACvB,IAAI,CAACvB,SAAS,CAAC,OAAO,CAAC;UACvB,IAAI,CAACzB,aAAa,GAAG,CAAC;UACtB,IAAI,CAACiD,sBAAsB,CAAC,CAAC;UAC7B,IAAI,CAACC,yBAAyB,CAAC,CAAC;UAChCX,OAAO,CAAC,CAAC;QACb,CAAC;QACD,IAAIY,aAAa,GAAGC,SAAS;QAC7B,MAAMC,eAAe,GAAGA,CAAA,KAAM;UAC1B,IAAI,CAACC,2BAA2B,CAACF,SAAS,CAAC;UAC3C,IAAI,CAACG,cAAc,CAAC,OAAO,EAAEJ,aAAa,CAAC;UAC3C,IAAI,CAACK,eAAe,GAAG,KAAK;UAC5B,IAAI,CAAC/B,SAAS,CAAC,SAAS,CAAC;UACzB,IAAI,IAAI,CAAC/B,OAAO,CAAC+D,gBAAgB,EAAE;YAC/B,IAAI,CAACC,UAAU,CAAC,CAACrB,GAAG,EAAEsB,IAAI,KAAK;cAC3B,IAAItB,GAAG,IAAIsB,IAAI,EAAE;gBACbzE,KAAK,CAAC,0CAA0C,EAAEmD,GAAG,IAAIsB,IAAI,CAAC;gBAC9D,IAAI,IAAI,CAAClB,MAAM,KAAK,SAAS,EAAE;kBAC3B,IAAI,CAACmB,UAAU,CAAC,IAAI,CAAC;gBACzB;cACJ,CAAC,MACI;gBACDZ,YAAY,CAAC,CAAC;cAClB;YACJ,CAAC,CAAC;UACN,CAAC,MACI;YACDA,YAAY,CAAC,CAAC;UAClB;QACJ,CAAC;QACDG,aAAa,GAAGA,CAAA,KAAM;UAClB,MAAMzB,KAAK,GAAG,IAAIP,KAAK,CAAC,oCAAoC,CAAC;UAC7D,IAAI,CAACoC,cAAc,CAAC,SAAS,EAAEF,eAAe,CAAC;UAC/C,IAAI,CAACC,2BAA2B,CAAC5B,KAAK,CAAC;UACvCc,MAAM,CAACd,KAAK,CAAC;QACjB,CAAC;QACD,IAAI,CAACmC,IAAI,CAAC,SAAS,EAAER,eAAe,CAAC;QACrC,IAAI,CAACQ,IAAI,CAAC,OAAO,EAAEV,aAAa,CAAC;QACjC,IAAI,CAACU,IAAI,CAAC,OAAO,EAAE,IAAI,CAACC,gBAAgB,CAACC,IAAI,CAAC,IAAI,CAAC,CAAC;QACpD,IAAI,CAACC,iBAAiB,CAAE3B,GAAG,IAAK;UAC5B,IAAIA,GAAG,IAAIA,GAAG,CAAC4B,OAAO,KAAK5F,uBAAuB,CAACkB,OAAO,CAAC2E,cAAc,EAAE;YACvE5F,OAAO,CAACiB,OAAO,CAAC4E,SAAS,CAACC,UAAU,CAACxD,IAAI,CAAC,IAAI,EAAE,OAAO,EAAEyB,GAAG,CAAC;YAC7D,IAAI,CAACjB,cAAc,CAAC2B,KAAK,CAAC,EAAE,CAAC;UACjC;QACJ,CAAC,CAAC;QACF,IAAI,CAACpB,UAAU,CAAC0C,KAAK,CAAC,CAAC;MAC3B,CAAC,CAAC,CACGjC,KAAK,CAAEC,GAAG,IAAK;QAChB,IAAI,CAACZ,SAAS,CAAC,OAAO,CAAC;QACvB,IAAI,CAACqC,gBAAgB,CAACzB,GAAG,CAAC;QAC1B,IAAI,CAACiB,2BAA2B,CAACjB,GAAG,CAAC;QACrCG,MAAM,CAACH,GAAG,CAAC;MACf,CAAC,CAAC;IACN,CAAC,CAAC;EACN;EACA;AACJ;AACA;EACIuB,UAAUA,CAACU,SAAS,GAAG,KAAK,EAAE;IAC1B,MAAM7B,MAAM,GAAG,IAAI,CAACA,MAAM;IAC1B,IAAI,CAAChB,SAAS,CAAC,eAAe,CAAC;IAC/B,IAAI,CAAC6C,SAAS,EAAE;MACZ,IAAI,CAACd,eAAe,GAAG,IAAI;IAC/B;IACA,IAAI,IAAI,CAACe,gBAAgB,IAAI,CAACD,SAAS,EAAE;MACrCE,YAAY,CAAC,IAAI,CAACD,gBAAgB,CAAC;MACnC,IAAI,CAACA,gBAAgB,GAAG,IAAI;MAC5BrF,KAAK,CAAC,gCAAgC,CAAC;IAC3C;IACA,IAAI,CAACuF,yBAAyB,CAAC,CAAC;IAChC,IAAI,CAAC9C,UAAU,CAAC+C,IAAI,CAAC,CAAC;IACtB,IAAIjC,MAAM,KAAK,MAAM,EAAE;MACnB,IAAI,CAAChB,SAAS,CAAC,OAAO,CAAC;MACvB,IAAI,CAACqC,gBAAgB,CAAC,CAAC;IAC3B,CAAC,MACI;MACD,IAAI,CAAC1C,cAAc,CAAC2B,KAAK,CAAC,EAAE,CAAC;IACjC;EACJ;EACA;AACJ;AACA;EACI4B,IAAIA,CAACC,QAAQ,EAAE;IACX,MAAMnC,MAAM,GAAG,IAAI,CAACA,MAAM;IAC1B,IAAI,CAAChB,SAAS,CAAC,eAAe,CAAC;IAC/B,IAAI,CAAC+B,eAAe,GAAG,IAAI;IAC3B,IAAI,IAAI,CAACe,gBAAgB,EAAE;MACvBC,YAAY,CAAC,IAAI,CAACD,gBAAgB,CAAC;MACnC,IAAI,CAACA,gBAAgB,GAAG,IAAI;IAChC;IACA,IAAI,CAACE,yBAAyB,CAAC,CAAC;IAChC,IAAI,CAAC9C,UAAU,CAAC+C,IAAI,CAAC,CAAC;IACtB,IAAIjC,MAAM,KAAK,MAAM,EAAE;MACnB,MAAMoC,GAAG,GAAG,CAAC,CAAC,EAAE1G,sBAAsB,CAACoB,OAAO,EAAE+C,OAAO,CAACC,OAAO,CAAC,IAAI,CAAC,EAAEqC,QAAQ,CAAC;MAChF;MACA;MACAE,YAAY,CAAC,YAAY;QACrB,IAAI,CAACrD,SAAS,CAAC,OAAO,CAAC;QACvB,IAAI,CAACqC,gBAAgB,CAAC,CAAC;MAC3B,CAAC,CAACC,IAAI,CAAC,IAAI,CAAC,CAAC;MACb,OAAOc,GAAG;IACd;IACA,OAAO,CAAC,CAAC,EAAE1G,sBAAsB,CAACoB,OAAO,EAAE+C,OAAO,CAACyC,GAAG,CAAC,IAAI,CAAClC,KAAK,CAAC,CAAC,CAACmC,GAAG,CAAEC,IAAI,IAAKA,IAAI,CAACN,IAAI,CAAC,CAAC,CAACvC,KAAK,CAAEC,GAAG,IAAK;MACzG;MACA;MACA,IAAIA,GAAG,CAAC4B,OAAO,KAAKxF,OAAO,CAACyG,2BAA2B,EAAE;QACrD,OAAO,IAAI;MACf;MACA,MAAM7C,GAAG;IACb,CAAC,CAAC,CAAC,CAAC,CAACO,IAAI,CAAC,MAAM,IAAI,CAAC,EAAEgC,QAAQ,CAAC;EACpC;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIO,SAASA,CAACC,oBAAoB,GAAG,EAAE,EAAEC,eAAe,GAAG,CAAC,CAAC,EAAE;IACvD,MAAM5F,YAAY,GAAG2F,oBAAoB,CAACE,MAAM,GAAG,CAAC,GAC9CF,oBAAoB,GACpB,IAAI,CAAC3F,YAAY,CAAC8F,KAAK,CAAC,CAAC,CAAC;IAChC,MAAM7F,OAAO,GAAG/B,MAAM,CAAC6H,MAAM,CAAC,CAAC,CAAC,EAAE,IAAI,CAAC9F,OAAO,EAAE2F,eAAe,CAAC;IAChE,OAAO,IAAI/F,OAAO,CAACG,YAAY,EAAEC,OAAO,CAAC;EAC7C;EACA;AACJ;AACA;EACImD,KAAKA,CAAC4C,IAAI,GAAG,KAAK,EAAE;IAChB,IAAIA,IAAI,KAAK,KAAK,IAAIA,IAAI,KAAK,QAAQ,IAAIA,IAAI,KAAK,OAAO,EAAE;MACzD,MAAM,IAAItE,KAAK,CAAC,gBAAgB,GAAGsE,IAAI,GAAG,wCAAwC,CAAC;IACvF;IACA,OAAO,IAAI,CAACrE,cAAc,CAACsE,QAAQ,CAACD,IAAI,CAAC;EAC7C;EACA;AACJ;AACA;AACA;AACA;EACIE,eAAeA,CAACf,QAAQ,EAAE;IACtB,IAAI,CAACnE,sBAAsB,CAACmF,IAAI,CAAChB,QAAQ,CAAC;EAC9C;EACA;AACJ;AACA;AACA;AACA;EACI,IAAIiB,qBAAqBA,CAAA,EAAG;IACxB,IAAIC,MAAM,GAAG,CAAC;IACd,KAAK,MAAMC,QAAQ,IAAI,IAAI,CAAC1F,cAAc,CAAC2F,MAAM,CAAC,CAAC,EAAE;MACjDF,MAAM,IAAIC,QAAQ,CAACT,MAAM;IAC7B;IACA,OAAOQ,MAAM;EACjB;EACA;AACJ;AACA;AACA;AACA;EACI9B,iBAAiBA,CAACY,QAAQ,EAAE;IACxB,IAAIA,QAAQ,EAAE;MACV,IAAI,CAACxE,2BAA2B,CAACwF,IAAI,CAAChB,QAAQ,CAAC;IACnD;IACA,IAAI,IAAI,CAACzE,YAAY,EAAE;MACnB;IACJ;IACA,IAAI,CAACA,YAAY,GAAG,IAAI;IACxB,MAAM8F,KAAK,GAAG,IAAI;IAClB,MAAMC,OAAO,GAAIxE,KAAK,IAAK;MACvB,IAAI,CAACvB,YAAY,GAAG,KAAK;MACzB,KAAK,MAAMyE,QAAQ,IAAI,IAAI,CAACxE,2BAA2B,EAAE;QACrDwE,QAAQ,CAAClD,KAAK,CAAC;MACnB;MACA,IAAI,CAACtB,2BAA2B,GAAG,EAAE;IACzC,CAAC;IACD,MAAMyC,KAAK,GAAG,CAAC,CAAC,EAAEpE,OAAO,CAAC0H,OAAO,EAAE,IAAI,CAAC/E,cAAc,CAACsE,QAAQ,CAAC,CAAC,CAAC;IAClE,IAAIU,aAAa,GAAG,IAAI;IACxB,SAASC,OAAOA,CAACC,KAAK,EAAE;MACpB,IAAIA,KAAK,KAAKzD,KAAK,CAACyC,MAAM,EAAE;QACxB,MAAM5D,KAAK,GAAG,IAAIrD,uBAAuB,CAACkB,OAAO,CAAClB,uBAAuB,CAACkB,OAAO,CAAC2E,cAAc,EAAEkC,aAAa,CAAC;QAChH,OAAOF,OAAO,CAACxE,KAAK,CAAC;MACzB;MACA,MAAMuD,IAAI,GAAGpC,KAAK,CAACyD,KAAK,CAAC;MACzB,MAAM/E,GAAG,GAAG,GAAG0D,IAAI,CAACvF,OAAO,CAAC6G,IAAI,IAAItB,IAAI,CAACvF,OAAO,CAAC8G,IAAI,EAAE;MACvDtH,KAAK,CAAC,4BAA4B,EAAEqC,GAAG,CAAC;MACxC0E,KAAK,CAACQ,eAAe,CAACxB,IAAI,EAAE,UAAU5C,GAAG,EAAE;QACvC,QAAQ4D,KAAK,CAACxD,MAAM;UAChB,KAAK,OAAO;UACZ,KAAK,KAAK;YACN,OAAOyD,OAAO,CAAC,IAAI/E,KAAK,CAAC,0BAA0B,CAAC,CAAC;UACzD,KAAK,eAAe;YAChB,OAAO+E,OAAO,CAAC,IAAI/E,KAAK,CAAC,2BAA2B,CAAC,CAAC;QAC9D;QACA,IAAIkB,GAAG,EAAE;UACL4D,KAAK,CAACzE,IAAI,CAAC,YAAY,EAAEa,GAAG,EAAEd,GAAG,CAAC;UAClC6E,aAAa,GAAG/D,GAAG;UACnBgE,OAAO,CAACC,KAAK,GAAG,CAAC,CAAC;QACtB,CAAC,MACI;UACDL,KAAK,CAACzE,IAAI,CAAC,SAAS,CAAC;UACrB0E,OAAO,CAAC,CAAC;QACb;MACJ,CAAC,CAAC;IACN;IACAG,OAAO,CAAC,CAAC,CAAC;EACd;EACA;AACJ;AACA;EACIK,WAAWA,CAACC,OAAO,EAAEC,MAAM,EAAE3B,IAAI,EAAE;IAC/B,IAAI,IAAI,CAACxC,MAAM,KAAK,MAAM,EAAE;MACxB,IAAI,CAACN,OAAO,CAAC,CAAC,CAACC,KAAK,CAAC3D,OAAO,CAACoI,IAAI,CAAC;IACtC;IACA,IAAI,IAAI,CAACpE,MAAM,KAAK,KAAK,EAAE;MACvBkE,OAAO,CAACnE,MAAM,CAAC,IAAIrB,KAAK,CAAC1C,OAAO,CAACyG,2BAA2B,CAAC,CAAC;MAC9D,OAAOyB,OAAO,CAACG,OAAO;IAC1B;IACA,IAAIC,EAAE,GAAG,IAAI,CAACrH,OAAO,CAACuB,UAAU;IAChC,IAAI8F,EAAE,KAAK,QAAQ,EAAE;MACjB,MAAMC,iBAAiB,GAAGL,OAAO,CAACM,UAAU,IACvC,CAAC,CAAC,EAAElJ,UAAU,CAACmJ,MAAM,EAAEP,OAAO,CAAC5E,IAAI,CAAC,IAAI,CAAC,CAAC,EAAEhE,UAAU,CAACoJ,OAAO,EAAER,OAAO,CAAC5E,IAAI,EAAE,UAAU,CAAE;MAC/F,IAAI,CAACiF,iBAAiB,EAAE;QACpBD,EAAE,GAAG,QAAQ;MACjB;IACJ;IACA,IAAIK,UAAU,GAAGnC,IAAI,GAAGA,IAAI,CAACoC,IAAI,GAAGV,OAAO,CAACW,OAAO,CAAC,CAAC;IACrD,MAAMC,GAAG,GAAG,CAAC,CAAC;IACd,MAAMtB,KAAK,GAAG,IAAI;IAClB,IAAI,CAAChB,IAAI,IAAI,CAAC7F,2BAA2B,CAACoI,GAAG,CAACb,OAAO,CAAC,EAAE;MACpDvH,2BAA2B,CAACqI,GAAG,CAACd,OAAO,CAAC;MACxC,MAAMnE,MAAM,GAAGmE,OAAO,CAACnE,MAAM;MAC7BmE,OAAO,CAACnE,MAAM,GAAG,UAAUH,GAAG,EAAE;QAC5B,MAAMqF,UAAU,GAAGC,aAAa,CAAC5D,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC;QACjDkC,KAAK,CAAC2B,WAAW,CAACvF,GAAG,EAAEkF,GAAG,EAAE;UACxBM,KAAK,EAAE,SAAAA,CAAUR,IAAI,EAAE9F,GAAG,EAAE;YACxBrC,KAAK,CAAC,2BAA2B,EAAEyH,OAAO,CAAC5E,IAAI,EAAER,GAAG,CAAC;YACrD6F,UAAU,GAAGU,MAAM,CAACT,IAAI,CAAC;YACzB,IAAIpB,KAAK,CAACtG,KAAK,CAAC0H,IAAI,CAAC,EAAE;cACnBpB,KAAK,CAACtG,KAAK,CAAC0H,IAAI,CAAC,CAAC,CAAC,CAAC,GAAG9F,GAAG;YAC9B,CAAC,MACI;cACD0E,KAAK,CAACtG,KAAK,CAAC0H,IAAI,CAAC,GAAG,CAAC9F,GAAG,CAAC;YAC7B;YACA0E,KAAK,CAACpG,aAAa,CAACwH,IAAI,CAAC,GACrBpB,KAAK,CAACrG,UAAU,CAACqG,KAAK,CAACtG,KAAK,CAAC0H,IAAI,CAAC,CAACU,IAAI,CAAC,GAAG,CAAC,CAAC;YACjD9B,KAAK,CAAC7E,cAAc,CAAC4G,YAAY,CAAC/B,KAAK,CAACgC,SAAS,CAAC1G,GAAG,CAAC,CAAC;YACvDoG,aAAa,CAAC,CAAC;YACfzI,KAAK,CAAC,sDAAsD,CAAC;YAC7D+G,KAAK,CAACjC,iBAAiB,CAAC,CAAC;UAC7B,CAAC;UACDkE,GAAG,EAAE,SAAAA,CAAUb,IAAI,EAAE9F,GAAG,EAAE;YACtBrC,KAAK,CAAC,qCAAqC,EAAEyH,OAAO,CAAC5E,IAAI,EAAER,GAAG,CAAC;YAC/D,MAAM4G,MAAM,GAAGlC,KAAK,CAACgC,SAAS,CAAC1G,GAAG,CAAC;YACnC0E,KAAK,CAAC7E,cAAc,CAAC4G,YAAY,CAACG,MAAM,CAAC;YACzCR,aAAa,CAAC,KAAK,EAAE,GAAGQ,MAAM,CAAC5B,IAAI,IAAI4B,MAAM,CAAC3B,IAAI,EAAE,CAAC;UACzD,CAAC;UACD4B,QAAQ,EAAEV,UAAU;UACpBW,WAAW,EAAEX,UAAU;UACvBY,gBAAgB,EAAEZ,UAAU;UAC5Ba,eAAe,EAAE,SAAAA,CAAUC,gBAAgB,EAAE;YACzChG,MAAM,CAAC5B,IAAI,CAAC+F,OAAO,EAAE6B,gBAAgB,CAAC;UAC1C,CAAC;UACD3H,QAAQ,EAAE,SAAAA,CAAA,EAAY;YAClB2B,MAAM,CAAC5B,IAAI,CAAC+F,OAAO,EAAEtE,GAAG,CAAC;UAC7B;QACJ,CAAC,CAAC;MACN,CAAC;IACL;IACAsF,aAAa,CAAC,CAAC;IACf,SAASA,aAAaA,CAACc,MAAM,EAAEC,MAAM,EAAE;MACnC,IAAIzC,KAAK,CAACxD,MAAM,KAAK,KAAK,EAAE;QACxBkE,OAAO,CAACnE,MAAM,CAAC,IAAItE,cAAc,CAACyK,UAAU,CAAC,mBAAmB,CAAC,CAAC;QAClE;MACJ;MACA,IAAIrH,KAAK;MACT,IAAI2E,KAAK,CAACxD,MAAM,KAAK,OAAO,IAAIkE,OAAO,CAAC5E,IAAI,KAAK,SAAS,EAAE;QACxD,IAAIkD,IAAI,IAAIA,IAAI,CAAC3D,KAAK,EAAE;UACpBA,KAAK,GAAG2D,IAAI,CAAC3D,KAAK;QACtB,CAAC,MACI,IAAIlD,SAAS,CAACmB,OAAO,CAACqJ,SAAS,CAAC,uBAAuB,EAAEjC,OAAO,CAAC5E,IAAI,CAAC,IACvE3D,SAAS,CAACmB,OAAO,CAACqJ,SAAS,CAAC,sBAAsB,EAAEjC,OAAO,CAAC5E,IAAI,CAAC,EAAE;UACnET,KAAK,GAAG2E,KAAK,CAACtE,UAAU,CAACkH,WAAW,CAAC,CAAC;UACtC,IAAI,CAACvH,KAAK,EAAE;YACRqF,OAAO,CAACnE,MAAM,CAAC,IAAItE,cAAc,CAACyK,UAAU,CAAC,+BAA+B,CAAC,CAAC;YAC9E;UACJ;QACJ,CAAC,MACI;UACD,IAAI,CAACF,MAAM,EAAE;YACT,IAAI,OAAOrB,UAAU,KAAK,QAAQ,IAAInB,KAAK,CAACtG,KAAK,CAACyH,UAAU,CAAC,EAAE;cAC3D,MAAM0B,QAAQ,GAAG7C,KAAK,CAACtG,KAAK,CAACyH,UAAU,CAAC;cACxC,IAAI,OAAOL,EAAE,KAAK,UAAU,EAAE;gBAC1B,MAAMlE,KAAK,GAAGiG,QAAQ,CAAC9D,GAAG,CAAC,UAAUzD,GAAG,EAAE;kBACtC,OAAO0E,KAAK,CAAC7E,cAAc,CAAC2H,gBAAgB,CAACxH,GAAG,CAAC;gBACrD,CAAC,CAAC;gBACFD,KAAK,GAAGyF,EAAE,CAAClE,KAAK,EAAE8D,OAAO,CAAC;gBAC1B,IAAI7G,KAAK,CAACkJ,OAAO,CAAC1H,KAAK,CAAC,EAAE;kBACtBA,KAAK,GAAG,CAAC,CAAC,EAAE7C,OAAO,CAACwK,MAAM,EAAE3H,KAAK,CAAC;gBACtC;gBACA,IAAI,CAACA,KAAK,EAAE;kBACRA,KAAK,GAAGuB,KAAK,CAAC,CAAC,CAAC;gBACpB;cACJ,CAAC,MACI;gBACD,IAAItB,GAAG;gBACP,IAAIwF,EAAE,KAAK,KAAK,EAAE;kBACdxF,GAAG,GAAG,CAAC,CAAC,EAAE9C,OAAO,CAACwK,MAAM,EAAEH,QAAQ,CAAC;gBACvC,CAAC,MACI,IAAI/B,EAAE,KAAK,OAAO,IAAI+B,QAAQ,CAACxD,MAAM,GAAG,CAAC,EAAE;kBAC5C/D,GAAG,GAAG,CAAC,CAAC,EAAE9C,OAAO,CAACwK,MAAM,EAAEH,QAAQ,EAAE,CAAC,CAAC;gBAC1C,CAAC,MACI;kBACDvH,GAAG,GAAGuH,QAAQ,CAAC,CAAC,CAAC;gBACrB;gBACAxH,KAAK,GAAG2E,KAAK,CAAC7E,cAAc,CAAC2H,gBAAgB,CAACxH,GAAG,CAAC;cACtD;YACJ;YACA,IAAImH,MAAM,EAAE;cACRpH,KAAK,GAAG2E,KAAK,CAAC7E,cAAc,CAAC2H,gBAAgB,CAACL,MAAM,CAAC;cACrDpH,KAAK,CAACoH,MAAM,CAAC,CAAC;YAClB;UACJ;UACA,IAAI,CAACpH,KAAK,EAAE;YACRA,KAAK,GACD,CAAC,OAAOyF,EAAE,KAAK,UAAU,GACnB,IAAI,GACJd,KAAK,CAAC7E,cAAc,CAAC8H,iBAAiB,CAACnC,EAAE,CAAC,KAC5Cd,KAAK,CAAC7E,cAAc,CAAC8H,iBAAiB,CAAC,KAAK,CAAC;UACzD;QACJ;QACA,IAAIjE,IAAI,IAAI,CAACA,IAAI,CAAC3D,KAAK,EAAE;UACrB2D,IAAI,CAAC3D,KAAK,GAAGA,KAAK;QACtB;MACJ;MACA,IAAIA,KAAK,EAAE;QACPA,KAAK,CAACoF,WAAW,CAACC,OAAO,EAAEC,MAAM,CAAC;MACtC,CAAC,MACI,IAAIX,KAAK,CAACvG,OAAO,CAACyJ,kBAAkB,EAAE;QACvClD,KAAK,CAAC/F,YAAY,CAAC0F,IAAI,CAAC;UACpBe,OAAO,EAAEA,OAAO;UAChBC,MAAM,EAAEA,MAAM;UACd3B,IAAI,EAAEA;QACV,CAAC,CAAC;MACN,CAAC,MACI;QACD0B,OAAO,CAACnE,MAAM,CAAC,IAAIrB,KAAK,CAAC,6DAA6D,CAAC,CAAC;MAC5F;IACJ;IACA,OAAOwF,OAAO,CAACG,OAAO;EAC1B;EACAsC,WAAWA,CAAC7H,GAAG,EAAE7B,OAAO,EAAE;IACtB,OAAO,IAAI,CAAC2J,gBAAgB,CAAC,OAAO,EAAE;MAAE9H,GAAG;MAAE7B;IAAQ,CAAC,CAAC;EAC3D;EACA4J,iBAAiBA,CAAC/H,GAAG,EAAE7B,OAAO,EAAE;IAC5B,OAAO,IAAI,CAAC2J,gBAAgB,CAAC,aAAa,EAAE;MAAE9H,GAAG;MAAE7B;IAAQ,CAAC,CAAC;EACjE;EACA6J,WAAWA,CAAChI,GAAG,EAAE7B,OAAO,EAAE;IACtB,OAAO,IAAI,CAAC2J,gBAAgB,CAAC,OAAO,EAAE;MAAE9H,GAAG;MAAE7B;IAAQ,CAAC,CAAC;EAC3D;EACA8J,iBAAiBA,CAACjI,GAAG,EAAE7B,OAAO,EAAE;IAC5B,OAAO,IAAI,CAAC2J,gBAAgB,CAAC,aAAa,EAAE;MAAE9H,GAAG;MAAE7B;IAAQ,CAAC,CAAC;EACjE;EACA+J,WAAWA,CAAClI,GAAG,EAAE7B,OAAO,EAAE;IACtB,OAAO,IAAI,CAAC2J,gBAAgB,CAAC,OAAO,EAAE;MAAE9H,GAAG;MAAE7B;IAAQ,CAAC,CAAC;EAC3D;EACAgK,iBAAiBA,CAACnI,GAAG,EAAE7B,OAAO,EAAE;IAC5B,OAAO,IAAI,CAAC2J,gBAAgB,CAAC,aAAa,EAAE;MAAE9H,GAAG;MAAE7B;IAAQ,CAAC,CAAC;EACjE;EACA;AACJ;AACA;EACIkI,WAAWA,CAAClG,KAAK,EAAE6F,GAAG,EAAEoC,QAAQ,EAAE;IAC9B,IAAI,OAAOpC,GAAG,CAACzJ,KAAK,KAAK,WAAW,EAAE;MAClCyJ,GAAG,CAACzJ,KAAK,GAAG,IAAI,CAAC4B,OAAO,CAAC6I,eAAe;IAC5C,CAAC,MACI;MACDhB,GAAG,CAACzJ,KAAK,IAAI,CAAC;IAClB;IACA,IAAIyJ,GAAG,CAACzJ,KAAK,IAAI,CAAC,EAAE;MAChB6L,QAAQ,CAACpB,eAAe,CAAC,IAAIpH,KAAK,CAAC,6CAA6C,GAAGO,KAAK,CAAC,CAAC;MAC1F;IACJ;IACA,MAAMkI,IAAI,GAAGlI,KAAK,CAACuC,OAAO,CAAC4F,KAAK,CAAC,GAAG,CAAC;IACrC,IAAID,IAAI,CAAC,CAAC,CAAC,KAAK,OAAO,EAAE;MACrB,MAAME,OAAO,GAAG,IAAI,CAACpK,OAAO,CAACqK,iBAAiB;MAC9C,IAAID,OAAO,IAAI,OAAOA,OAAO,KAAK,QAAQ,EAAE;QACxC,IAAI,CAAC7J,UAAU,CAAC2F,IAAI,CAAC,OAAO,EAAE+D,QAAQ,CAAC9B,KAAK,CAAC9D,IAAI,CAAC,IAAI,EAAE6F,IAAI,CAAC,CAAC,CAAC,EAAEA,IAAI,CAAC,CAAC,CAAC,CAAC,EAAE;UAAEE;QAAQ,CAAC,CAAC;MAC3F,CAAC,MACI;QACDH,QAAQ,CAAC9B,KAAK,CAAC+B,IAAI,CAAC,CAAC,CAAC,EAAEA,IAAI,CAAC,CAAC,CAAC,CAAC;MACpC;IACJ,CAAC,MACI,IAAIA,IAAI,CAAC,CAAC,CAAC,KAAK,KAAK,EAAE;MACxBD,QAAQ,CAACzB,GAAG,CAAC0B,IAAI,CAAC,CAAC,CAAC,EAAEA,IAAI,CAAC,CAAC,CAAC,CAAC;IAClC,CAAC,MACI,IAAIA,IAAI,CAAC,CAAC,CAAC,KAAK,UAAU,EAAE;MAC7B,IAAI,CAAC3J,UAAU,CAAC2F,IAAI,CAAC,UAAU,EAAE+D,QAAQ,CAACvB,QAAQ,EAAE;QAChD0B,OAAO,EAAE,IAAI,CAACpK,OAAO,CAACsK;MAC1B,CAAC,CAAC;IACN,CAAC,MACI,IAAIJ,IAAI,CAAC,CAAC,CAAC,KAAK,aAAa,IAC9B,IAAI,CAAClK,OAAO,CAACuK,uBAAuB,GAAG,CAAC,EAAE;MAC1C,IAAI,CAAChK,UAAU,CAAC2F,IAAI,CAAC,aAAa,EAAE+D,QAAQ,CAACrB,gBAAgB,EAAE;QAC3DwB,OAAO,EAAE,IAAI,CAACpK,OAAO,CAACuK,uBAAuB;QAC7CrF,QAAQ,EAAE,IAAI,CAACZ,iBAAiB,CAACD,IAAI,CAAC,IAAI;MAC9C,CAAC,CAAC;IACN,CAAC,MACI,IAAIrC,KAAK,CAACuC,OAAO,KAAKxF,OAAO,CAACyG,2BAA2B,IAC1D,IAAI,CAACxF,OAAO,CAACwK,oBAAoB,GAAG,CAAC,IACrC,IAAI,CAACzH,MAAM,KAAK,OAAO,EAAE;MACzB,IAAI,CAACxC,UAAU,CAAC2F,IAAI,CAAC,UAAU,EAAE+D,QAAQ,CAACrB,gBAAgB,EAAE;QACxDwB,OAAO,EAAE,IAAI,CAACpK,OAAO,CAACwK,oBAAoB;QAC1CtF,QAAQ,EAAE,IAAI,CAACZ,iBAAiB,CAACD,IAAI,CAAC,IAAI;MAC9C,CAAC,CAAC;IACN,CAAC,MACI;MACD4F,QAAQ,CAAC9I,QAAQ,CAAC,CAAC;IACvB;EACJ;EACAsJ,iBAAiBA,CAAA,EAAG;IAChB,IAAI,CAACjK,YAAY,GAAG,IAAIjB,KAAK,CAAC,CAAC;EACnC;EACAwF,yBAAyBA,CAAA,EAAG;IACxB,IAAI,IAAI,CAAC2F,UAAU,EAAE;MACjB5F,YAAY,CAAC,IAAI,CAAC4F,UAAU,CAAC;MAC7B,IAAI,CAACA,UAAU,GAAG,IAAI;IAC1B;EACJ;EACAlH,yBAAyBA,CAAA,EAAG;IACxB,IAAI,IAAI,CAACkH,UAAU,IAAI,CAAC,IAAI,CAAC1K,OAAO,CAAC2K,oBAAoB,EAAE;MACvD;IACJ;IACA,MAAMC,SAAS,GAAGA,CAAA,KAAM;MACpB,IAAI,CAACF,UAAU,GAAGG,UAAU,CAAC,MAAM;QAC/BrL,KAAK,CAAC,wEAAwE,CAAC;QAC/E,IAAI,CAAC8E,iBAAiB,CAAC,MAAM;UACzBsG,SAAS,CAAC,CAAC;QACf,CAAC,CAAC;MACN,CAAC,EAAE,IAAI,CAAC5K,OAAO,CAAC2K,oBAAoB,CAAC;IACzC,CAAC;IACDC,SAAS,CAAC,CAAC;EACf;EACA;AACJ;AACA;EACI7I,SAASA,CAACgB,MAAM,EAAE;IACdvD,KAAK,CAAC,kBAAkB,EAAE,IAAI,CAACuD,MAAM,IAAI,SAAS,EAAEA,MAAM,CAAC;IAC3D,IAAI,CAACA,MAAM,GAAGA,MAAM;IACpB+H,OAAO,CAACC,QAAQ,CAAC,MAAM;MACnB,IAAI,CAACjJ,IAAI,CAACiB,MAAM,CAAC;IACrB,CAAC,CAAC;EACN;EACA;AACJ;AACA;EACIqB,gBAAgBA,CAAC4G,MAAM,EAAE;IACrB,IAAIA,MAAM,EAAE;MACRxL,KAAK,CAAC,mBAAmB,EAAEwL,MAAM,CAAC;IACtC;IACA,IAAIC,UAAU;IACd,IAAI,CAAC,IAAI,CAACnH,eAAe,IACrB,OAAO,IAAI,CAAC9D,OAAO,CAACkL,oBAAoB,KAAK,UAAU,EAAE;MACzDD,UAAU,GAAG,IAAI,CAACjL,OAAO,CAACkL,oBAAoB,CAAChK,IAAI,CAAC,IAAI,EAAE,EAAE,IAAI,CAACZ,aAAa,EAAE0K,MAAM,CAAC;IAC3F;IACA,IAAI,OAAOC,UAAU,KAAK,QAAQ,EAAE;MAChC,IAAI,CAAClJ,SAAS,CAAC,cAAc,CAAC;MAC9B,IAAI,CAAC8C,gBAAgB,GAAGgG,UAAU,CAAC,MAAM;QACrC,IAAI,CAAChG,gBAAgB,GAAG,IAAI;QAC5BrF,KAAK,CAAC,8CAA8C,EAAEyL,UAAU,CAAC;QACjE,IAAI,CAACxI,OAAO,CAAC,CAAC,CAACC,KAAK,CAAC,UAAUC,GAAG,EAAE;UAChCnD,KAAK,CAAC,6CAA6C,EAAEmD,GAAG,CAAC;QAC7D,CAAC,CAAC;MACN,CAAC,EAAEsI,UAAU,CAAC;IAClB,CAAC,MACI;MACD,IAAI,CAAClJ,SAAS,CAAC,KAAK,CAAC;MACrB,IAAI,CAACoJ,UAAU,CAAC,IAAI1J,KAAK,CAAC,oCAAoC,CAAC,CAAC;IACpE;EACJ;EACA;AACJ;AACA;EACI0J,UAAUA,CAACnJ,KAAK,EAAE;IACd,IAAIoJ,IAAI;IACR,OAAQA,IAAI,GAAG,IAAI,CAAC5K,YAAY,CAAC6K,KAAK,CAAC,CAAC,EAAG;MACvCD,IAAI,CAACnE,OAAO,CAACnE,MAAM,CAACd,KAAK,CAAC;IAC9B;EACJ;EACAuB,sBAAsBA,CAAA,EAAG;IACrB,IAAI,IAAI,CAAC/C,YAAY,CAACoF,MAAM,EAAE;MAC1BpG,KAAK,CAAC,mCAAmC,EAAE,IAAI,CAACgB,YAAY,CAACoF,MAAM,CAAC;MACpE,MAAMpF,YAAY,GAAG,IAAI,CAACA,YAAY;MACtC,IAAI,CAACiK,iBAAiB,CAAC,CAAC;MACxB,IAAIW,IAAI;MACR,OAAQA,IAAI,GAAG5K,YAAY,CAAC6K,KAAK,CAAC,CAAC,EAAG;QAClC,IAAI,CAACrE,WAAW,CAACoE,IAAI,CAACnE,OAAO,EAAEmE,IAAI,CAAClE,MAAM,EAAEkE,IAAI,CAAC7F,IAAI,CAAC;MAC1D;IACJ;EACJ;EACAgD,SAASA,CAAC+C,OAAO,EAAE;IACf,IAAI,IAAI,CAACtL,OAAO,CAACuL,MAAM,IAAI,OAAO,IAAI,CAACvL,OAAO,CAACuL,MAAM,KAAK,QAAQ,EAAE;MAChE,MAAM1J,GAAG,GAAG,OAAOyJ,OAAO,KAAK,QAAQ,GACjCA,OAAO,GACP,GAAGA,OAAO,CAACzE,IAAI,IAAIyE,OAAO,CAACxE,IAAI,EAAE;MACvC,MAAM2B,MAAM,GAAG,IAAI,CAACzI,OAAO,CAACuL,MAAM,CAAC1J,GAAG,CAAC;MACvC,IAAI4G,MAAM,EAAE;QACRjJ,KAAK,CAAC,sBAAsB,EAAEqC,GAAG,EAAE4G,MAAM,CAAC;QAC1C,OAAOxK,MAAM,CAAC6H,MAAM,CAAC,CAAC,CAAC,EAAE2C,MAAM,CAAC;MACpC;IACJ;IACA,OAAO,OAAO6C,OAAO,KAAK,QAAQ,GAC5B,CAAC,CAAC,EAAEhM,MAAM,CAACkM,qBAAqB,EAAEF,OAAO,CAAC,GAC1CA,OAAO;EACjB;EACAvE,eAAeA,CAACnF,KAAK,EAAEsD,QAAQ,EAAE;IAC7B,IAAI,CAACtD,KAAK,EAAE;MACR,OAAOsD,QAAQ,CAAC,IAAIzD,KAAK,CAAC,sBAAsB,CAAC,CAAC;IACtD;IACA;IACA;IACA;IACA,MAAMgK,oBAAoB,GAAG7J,KAAK,CAAC6D,SAAS,CAAC;MACzCgE,kBAAkB,EAAE,IAAI;MACxB1F,gBAAgB,EAAE,KAAK;MACvB2H,aAAa,EAAE,IAAI;MACnBC,cAAc,EAAE,CAAC,CAAC,EAAErM,MAAM,CAACsM,iBAAiB,EAAE,WAAW,EAAE,IAAI,CAAC5L,OAAO,CAACqB,YAAY,IAAI,IAAI,CAACrB,OAAO,CAACqB,YAAY,CAACsK,cAAc;IACpI,CAAC,CAAC;IACF;IACA;IACAF,oBAAoB,CAAC9J,EAAE,CAAC,OAAO,EAAE5C,OAAO,CAACoI,IAAI,CAAC;IAC9CsE,oBAAoB,CAACI,OAAO,CAAC,OAAO,EAAE,CAAC,CAAC,EAAE9M,OAAO,CAACqL,OAAO,EAAE,CAACzH,GAAG,EAAEmJ,MAAM,KAAK;MACxEL,oBAAoB,CAACvH,UAAU,CAAC,CAAC;MACjC,IAAIvB,GAAG,EAAE;QACL,OAAOuC,QAAQ,CAACvC,GAAG,CAAC;MACxB;MACA,IAAI,IAAI,CAACI,MAAM,KAAK,eAAe,IAC/B,IAAI,CAACA,MAAM,KAAK,OAAO,IACvB,IAAI,CAACA,MAAM,KAAK,KAAK,EAAE;QACvBvD,KAAK,CAAC,qEAAqE,EAAEsM,MAAM,CAAClG,MAAM,EAAE,IAAI,CAAC7C,MAAM,CAAC;QACxGmC,QAAQ,CAAC,CAAC;QACV;MACJ;MACA,MAAM/B,KAAK,GAAG,EAAE;MAChB3D,KAAK,CAAC,gCAAgC,EAAEsM,MAAM,CAAClG,MAAM,CAAC;MACtD,KAAK,IAAImG,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGD,MAAM,CAAClG,MAAM,EAAE,EAAEmG,CAAC,EAAE;QACpC,MAAMC,KAAK,GAAGF,MAAM,CAACC,CAAC,CAAC;QACvB,MAAME,cAAc,GAAGD,KAAK,CAAC,CAAC,CAAC;QAC/B,MAAME,YAAY,GAAGF,KAAK,CAAC,CAAC,CAAC;QAC7B,MAAMG,IAAI,GAAG,EAAE;QACf,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGJ,KAAK,CAACpG,MAAM,EAAEwG,CAAC,EAAE,EAAE;UACnC,IAAI,CAACJ,KAAK,CAACI,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE;YACd;UACJ;UACA,MAAM7G,IAAI,GAAG,IAAI,CAACgD,SAAS,CAAC;YACxB1B,IAAI,EAAEmF,KAAK,CAACI,CAAC,CAAC,CAAC,CAAC,CAAC;YACjBtF,IAAI,EAAEkF,KAAK,CAACI,CAAC,CAAC,CAAC,CAAC;UACpB,CAAC,CAAC;UACF7G,IAAI,CAAC8G,QAAQ,GAAGD,CAAC,KAAK,CAAC;UACvBjJ,KAAK,CAAC+C,IAAI,CAACX,IAAI,CAAC;UAChB4G,IAAI,CAACjG,IAAI,CAACX,IAAI,CAACsB,IAAI,GAAG,GAAG,GAAGtB,IAAI,CAACuB,IAAI,CAAC;QAC1C;QACAtH,KAAK,CAAC,qDAAqD,EAAEuM,CAAC,EAAEE,cAAc,EAAEC,YAAY,EAAEC,IAAI,CAAC;QACnG,KAAK,IAAIxE,IAAI,GAAGsE,cAAc,EAAEtE,IAAI,IAAIuE,YAAY,EAAEvE,IAAI,EAAE,EAAE;UAC1D,IAAI,CAAC1H,KAAK,CAAC0H,IAAI,CAAC,GAAGwE,IAAI;QAC3B;MACJ;MACA;MACA,IAAI,CAACjM,UAAU,GAAGjC,MAAM,CAACqO,MAAM,CAAC,IAAI,CAAC;MACrC,IAAIF,CAAC,GAAG,CAAC;MACT,KAAK,IAAIL,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,KAAK,EAAEA,CAAC,EAAE,EAAE;QAC5B,MAAMQ,MAAM,GAAG,CAAC,IAAI,CAACtM,KAAK,CAAC8L,CAAC,CAAC,IAAI,EAAE,EAAE1D,IAAI,CAAC,GAAG,CAAC;QAC9C,IAAI,CAACkE,MAAM,CAAC3G,MAAM,EAAE;UAChB,IAAI,CAACzF,aAAa,CAAC4L,CAAC,CAAC,GAAGrI,SAAS;UACjC;QACJ;QACA,IAAI,CAAC,IAAI,CAACxD,UAAU,CAACqM,MAAM,CAAC,EAAE;UAC1B,IAAI,CAACrM,UAAU,CAACqM,MAAM,CAAC,GAAG,EAAEH,CAAC;QACjC;QACA,IAAI,CAACjM,aAAa,CAAC4L,CAAC,CAAC,GAAG,IAAI,CAAC7L,UAAU,CAACqM,MAAM,CAAC;MACnD;MACA,IAAI,CAAC7K,cAAc,CAAC2B,KAAK,CAACF,KAAK,CAAC;MAChC+B,QAAQ,CAAC,CAAC;IACd,CAAC,EAAE,IAAI,CAAClF,OAAO,CAACwM,mBAAmB,CAAC,CAAC;EACzC;EACA5I,2BAA2BA,CAACjB,GAAG,EAAE;IAC7B,KAAK,MAAM8J,CAAC,IAAI,IAAI,CAAC1L,sBAAsB,EAAE;MACzC+J,OAAO,CAACC,QAAQ,CAAC0B,CAAC,EAAE9J,GAAG,CAAC;IAC5B;IACA,IAAI,CAAC5B,sBAAsB,GAAG,EAAE;EACpC;EACA;AACJ;AACA;EACIiD,UAAUA,CAACkB,QAAQ,EAAE;IACjB,IAAI,CAAC2G,OAAO,CAAC,MAAM,EAAE,CAAClJ,GAAG,EAAE+J,GAAG,KAAK;MAC/B,IAAI/J,GAAG,EAAE;QACL,OAAOuC,QAAQ,CAACvC,GAAG,CAAC;MACxB;MACA,IAAI,OAAO+J,GAAG,KAAK,QAAQ,EAAE;QACzB,OAAOxH,QAAQ,CAAC,CAAC;MACrB;MACA,IAAIyH,KAAK;MACT,MAAMC,KAAK,GAAGF,GAAG,CAACvC,KAAK,CAAC,MAAM,CAAC;MAC/B,KAAK,IAAI4B,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGa,KAAK,CAAChH,MAAM,EAAE,EAAEmG,CAAC,EAAE;QACnC,MAAMc,KAAK,GAAGD,KAAK,CAACb,CAAC,CAAC,CAAC5B,KAAK,CAAC,GAAG,CAAC;QACjC,IAAI0C,KAAK,CAAC,CAAC,CAAC,KAAK,eAAe,EAAE;UAC9BF,KAAK,GAAGE,KAAK,CAAC,CAAC,CAAC;UAChB;QACJ;MACJ;MACA,IAAIF,KAAK,KAAK,MAAM,EAAE;QAClBnN,KAAK,CAAC,2BAA2B,EAAEmN,KAAK,CAAC;QACzCzH,QAAQ,CAAC,IAAI,EAAEyH,KAAK,CAAC;MACzB,CAAC,MACI;QACDzH,QAAQ,CAAC,CAAC;MACd;IACJ,CAAC,CAAC;EACN;EACA4H,UAAUA,CAACC,QAAQ,EAAE;IACjB,OAAO,IAAInK,OAAO,CAAC,CAACC,OAAO,EAAEC,MAAM,KAAK;MACpC,IAAI,CAAC9C,OAAO,CAAC8M,UAAU,CAACC,QAAQ,EAAE,CAACpK,GAAG,EAAEqK,OAAO,KAAK;QAChD,IAAIrK,GAAG,EAAE;UACL,OAAOG,MAAM,CAACH,GAAG,CAAC;QACtB;QACA,MAAMsK,IAAI,GAAG,IAAI;UAAEC,cAAc,GAAG,CAAC,CAAC,EAAE5N,MAAM,CAAC6N,eAAe,EAAEH,OAAO,CAAC;UAAEI,UAAU,GAAGnP,MAAM,CAACkO,IAAI,CAACe,cAAc,CAAC,CAACG,IAAI,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAKC,QAAQ,CAACF,CAAC,CAAC,GAAGE,QAAQ,CAACD,CAAC,CAAC,CAAC;QAC5J,SAASE,WAAWA,CAAC9K,GAAG,EAAE;UACtB,IAAI,CAACyK,UAAU,CAACxH,MAAM,EAAE;YACpB,OAAO9C,MAAM,CAACH,GAAG,CAAC;UACtB;UACA,MAAMd,GAAG,GAAGuL,UAAU,CAAC,CAAC,CAAC;YAAEM,KAAK,GAAGR,cAAc,CAACrL,GAAG,CAAC;YAAE8L,MAAM,GAAG,CAAC,CAAC,EAAErO,MAAM,CAACsO,gBAAgB,EAAEF,KAAK,CAAC;UACpG,IAAI,CAACA,KAAK,CAACV,OAAO,CAACpH,MAAM,EAAE;YACvBwH,UAAU,CAAC/B,KAAK,CAAC,CAAC;UACtB;UACA4B,IAAI,CAACY,SAAS,CAACF,MAAM,CAACtL,IAAI,CAAC,CAACa,IAAI,CAAE2D,IAAI,IAAKhE,OAAO,CAAC;YAC/CgE,IAAI;YACJC,IAAI,EAAE6G,MAAM,CAAC7G;UACjB,CAAC,CAAC,EAAE2G,WAAW,CAAC;QACpB;QACAA,WAAW,CAAC,CAAC;MACjB,CAAC,CAAC;IACN,CAAC,CAAC;EACN;EACAI,SAASA,CAACd,QAAQ,EAAE;IAChB,OAAO,IAAInK,OAAO,CAAC,CAACC,OAAO,EAAEC,MAAM,KAAK;MACpC,IAAI,CAAC9C,OAAO,CAAC6N,SAAS,CAACd,QAAQ,EAAE,CAACpK,GAAG,EAAEmL,OAAO,KAAK;QAC/C,IAAInL,GAAG,EAAE;UACLnD,KAAK,CAAC,yCAAyC,EAAEuN,QAAQ,EAAEpK,GAAG,CAAC4B,OAAO,CAAC;UACvEzB,MAAM,CAACH,GAAG,CAAC;QACf,CAAC,MACI;UACDnD,KAAK,CAAC,+BAA+B,EAAEuN,QAAQ,EAAEe,OAAO,CAAC;UACzDjL,OAAO,CAACiL,OAAO,CAAC;QACpB;MACJ,CAAC,CAAC;IACN,CAAC,CAAC;EACN;EACA;AACJ;AACA;AACA;AACA;AACA;EACI,MAAM7K,2BAA2BA,CAAA,EAAG;IAChC,IAAI,CAAC7C,KAAK,CAACkJ,OAAO,CAAC,IAAI,CAACvJ,YAAY,CAAC,IAAI,IAAI,CAACA,YAAY,CAAC6F,MAAM,KAAK,CAAC,EAAE;MACrE,MAAM,IAAInE,KAAK,CAAC,kDAAkD,CAAC;IACvE;IACA,MAAM1B,YAAY,GAAG,CAAC,CAAC,EAAET,MAAM,CAACyO,oBAAoB,EAAE,IAAI,CAAChO,YAAY,CAAC;IACxE,MAAMiO,SAAS,GAAG,CAAC,CAAC,EAAE1O,MAAM,CAAC2O,6BAA6B,EAAElO,YAAY,CAAC;IACzE,IAAIiO,SAAS,CAACpI,MAAM,KAAK,CAAC,EAAE;MACxB,OAAO7F,YAAY;IACvB;IACA,MAAMmO,OAAO,GAAG,MAAMtL,OAAO,CAACyC,GAAG,CAAC2I,SAAS,CAAC1I,GAAG,CAAC,CAAC,IAAI,CAACtF,OAAO,CAACmO,aAAa,GAAG,IAAI,CAACrB,UAAU,GAAG,IAAI,CAACe,SAAS,EAAExJ,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;IAC5H,MAAM+J,gBAAgB,GAAG,CAAC,CAAC,EAAErP,OAAO,CAACsP,MAAM,EAAEL,SAAS,EAAEE,OAAO,CAAC;IAChE,OAAOnO,YAAY,CAACuF,GAAG,CAAEC,IAAI,IAAK;MAC9B,MAAM+I,MAAM,GAAGF,gBAAgB,CAACG,GAAG,CAAChJ,IAAI,CAACsB,IAAI,CAAC;MAC9C,IAAI,CAACyH,MAAM,EAAE;QACT,OAAO/I,IAAI;MACf;MACA,IAAI,IAAI,CAACvF,OAAO,CAACmO,aAAa,EAAE;QAC5B,OAAOlQ,MAAM,CAAC6H,MAAM,CAAC,CAAC,CAAC,EAAEP,IAAI,EAAE+I,MAAM,CAAC;MAC1C;MACA,OAAOrQ,MAAM,CAAC6H,MAAM,CAAC,CAAC,CAAC,EAAEP,IAAI,EAAE;QAAEsB,IAAI,EAAEyH;MAAO,CAAC,CAAC;IACpD,CAAC,CAAC;EACN;EACA3E,gBAAgBA,CAAC1C,OAAO,EAAE;IAAEpF,GAAG;IAAE7B,OAAO,GAAG,CAAC;EAAE,CAAC,EAAE;IAC7C,OAAO,IAAInB,YAAY,CAACgB,OAAO,CAAC;MAC5B2O,UAAU,EAAE,IAAI;MAChB3M,GAAG,EAAEA,GAAG;MACRD,KAAK,EAAE,IAAI;MACXqF,OAAO,EAAEA,OAAO;MAChB,GAAGjH;IACP,CAAC,CAAC;EACN;AACJ;AACA,CAAC,CAAC,EAAEhB,YAAY,CAACa,OAAO,EAAED,OAAO,EAAErB,QAAQ,CAAC0C,YAAY,CAAC;AACzD,CAAC,CAAC,EAAEnC,aAAa,CAAC2P,qBAAqB,EAAE7O,OAAO,CAAC6E,SAAS,CAAC;AAC3DtG,OAAO,CAAC0B,OAAO,GAAGD,OAAO","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}