{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst events_1 = require(\"events\");\nconst utils_1 = require(\"../utils\");\nconst util_1 = require(\"./util\");\nconst Redis_1 = require(\"../Redis\");\nconst debug = (0, utils_1.Debug)(\"cluster:connectionPool\");\nclass ConnectionPool extends events_1.EventEmitter {\n  constructor(redisOptions) {\n    super();\n    this.redisOptions = redisOptions;\n    // master + slave = all\n    this.nodes = {\n      all: {},\n      master: {},\n      slave: {}\n    };\n    this.specifiedOptions = {};\n  }\n  getNodes(role = \"all\") {\n    const nodes = this.nodes[role];\n    return Object.keys(nodes).map(key => nodes[key]);\n  }\n  getInstanceByKey(key) {\n    return this.nodes.all[key];\n  }\n  getSampleInstance(role) {\n    const keys = Object.keys(this.nodes[role]);\n    const sampleKey = (0, utils_1.sample)(keys);\n    return this.nodes[role][sampleKey];\n  }\n  /**\n   * Find or create a connection to the node\n   */\n  findOrCreate(node, readOnly = false) {\n    const key = (0, util_1.getNodeKey)(node);\n    readOnly = Boolean(readOnly);\n    if (this.specifiedOptions[key]) {\n      Object.assign(node, this.specifiedOptions[key]);\n    } else {\n      this.specifiedOptions[key] = node;\n    }\n    let redis;\n    if (this.nodes.all[key]) {\n      redis = this.nodes.all[key];\n      if (redis.options.readOnly !== readOnly) {\n        redis.options.readOnly = readOnly;\n        debug(\"Change role of %s to %s\", key, readOnly ? \"slave\" : \"master\");\n        redis[readOnly ? \"readonly\" : \"readwrite\"]().catch(utils_1.noop);\n        if (readOnly) {\n          delete this.nodes.master[key];\n          this.nodes.slave[key] = redis;\n        } else {\n          delete this.nodes.slave[key];\n          this.nodes.master[key] = redis;\n        }\n      }\n    } else {\n      debug(\"Connecting to %s as %s\", key, readOnly ? \"slave\" : \"master\");\n      redis = new Redis_1.default((0, utils_1.defaults)({\n        // Never try to reconnect when a node is lose,\n        // instead, waiting for a `MOVED` error and\n        // fetch the slots again.\n        retryStrategy: null,\n        // Offline queue should be enabled so that\n        // we don't need to wait for the `ready` event\n        // before sending commands to the node.\n        enableOfflineQueue: true,\n        readOnly: readOnly\n      }, node, this.redisOptions, {\n        lazyConnect: true\n      }));\n      this.nodes.all[key] = redis;\n      this.nodes[readOnly ? \"slave\" : \"master\"][key] = redis;\n      redis.once(\"end\", () => {\n        this.removeNode(key);\n        this.emit(\"-node\", redis, key);\n        if (!Object.keys(this.nodes.all).length) {\n          this.emit(\"drain\");\n        }\n      });\n      this.emit(\"+node\", redis, key);\n      redis.on(\"error\", function (error) {\n        this.emit(\"nodeError\", error, key);\n      });\n    }\n    return redis;\n  }\n  /**\n   * Reset the pool with a set of nodes.\n   * The old node will be removed.\n   */\n  reset(nodes) {\n    debug(\"Reset with %O\", nodes);\n    const newNodes = {};\n    nodes.forEach(node => {\n      const key = (0, util_1.getNodeKey)(node);\n      // Don't override the existing (master) node\n      // when the current one is slave.\n      if (!(node.readOnly && newNodes[key])) {\n        newNodes[key] = node;\n      }\n    });\n    Object.keys(this.nodes.all).forEach(key => {\n      if (!newNodes[key]) {\n        debug(\"Disconnect %s because the node does not hold any slot\", key);\n        this.nodes.all[key].disconnect();\n        this.removeNode(key);\n      }\n    });\n    Object.keys(newNodes).forEach(key => {\n      const node = newNodes[key];\n      this.findOrCreate(node, node.readOnly);\n    });\n  }\n  /**\n   * Remove a node from the pool.\n   */\n  removeNode(key) {\n    const {\n      nodes\n    } = this;\n    if (nodes.all[key]) {\n      debug(\"Remove %s from the pool\", key);\n      delete nodes.all[key];\n    }\n    delete nodes.master[key];\n    delete nodes.slave[key];\n  }\n}\nexports.default = ConnectionPool;","map":{"version":3,"names":["Object","defineProperty","exports","value","events_1","require","utils_1","util_1","Redis_1","debug","Debug","ConnectionPool","EventEmitter","constructor","redisOptions","nodes","all","master","slave","specifiedOptions","getNodes","role","keys","map","key","getInstanceByKey","getSampleInstance","sampleKey","sample","findOrCreate","node","readOnly","getNodeKey","Boolean","assign","redis","options","catch","noop","default","defaults","retryStrategy","enableOfflineQueue","lazyConnect","once","removeNode","emit","length","on","error","reset","newNodes","forEach","disconnect"],"sources":["C:/rgraph/node_modules/ioredis/built/cluster/ConnectionPool.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst events_1 = require(\"events\");\nconst utils_1 = require(\"../utils\");\nconst util_1 = require(\"./util\");\nconst Redis_1 = require(\"../Redis\");\nconst debug = (0, utils_1.Debug)(\"cluster:connectionPool\");\nclass ConnectionPool extends events_1.EventEmitter {\n    constructor(redisOptions) {\n        super();\n        this.redisOptions = redisOptions;\n        // master + slave = all\n        this.nodes = {\n            all: {},\n            master: {},\n            slave: {},\n        };\n        this.specifiedOptions = {};\n    }\n    getNodes(role = \"all\") {\n        const nodes = this.nodes[role];\n        return Object.keys(nodes).map((key) => nodes[key]);\n    }\n    getInstanceByKey(key) {\n        return this.nodes.all[key];\n    }\n    getSampleInstance(role) {\n        const keys = Object.keys(this.nodes[role]);\n        const sampleKey = (0, utils_1.sample)(keys);\n        return this.nodes[role][sampleKey];\n    }\n    /**\n     * Find or create a connection to the node\n     */\n    findOrCreate(node, readOnly = false) {\n        const key = (0, util_1.getNodeKey)(node);\n        readOnly = Boolean(readOnly);\n        if (this.specifiedOptions[key]) {\n            Object.assign(node, this.specifiedOptions[key]);\n        }\n        else {\n            this.specifiedOptions[key] = node;\n        }\n        let redis;\n        if (this.nodes.all[key]) {\n            redis = this.nodes.all[key];\n            if (redis.options.readOnly !== readOnly) {\n                redis.options.readOnly = readOnly;\n                debug(\"Change role of %s to %s\", key, readOnly ? \"slave\" : \"master\");\n                redis[readOnly ? \"readonly\" : \"readwrite\"]().catch(utils_1.noop);\n                if (readOnly) {\n                    delete this.nodes.master[key];\n                    this.nodes.slave[key] = redis;\n                }\n                else {\n                    delete this.nodes.slave[key];\n                    this.nodes.master[key] = redis;\n                }\n            }\n        }\n        else {\n            debug(\"Connecting to %s as %s\", key, readOnly ? \"slave\" : \"master\");\n            redis = new Redis_1.default((0, utils_1.defaults)({\n                // Never try to reconnect when a node is lose,\n                // instead, waiting for a `MOVED` error and\n                // fetch the slots again.\n                retryStrategy: null,\n                // Offline queue should be enabled so that\n                // we don't need to wait for the `ready` event\n                // before sending commands to the node.\n                enableOfflineQueue: true,\n                readOnly: readOnly,\n            }, node, this.redisOptions, { lazyConnect: true }));\n            this.nodes.all[key] = redis;\n            this.nodes[readOnly ? \"slave\" : \"master\"][key] = redis;\n            redis.once(\"end\", () => {\n                this.removeNode(key);\n                this.emit(\"-node\", redis, key);\n                if (!Object.keys(this.nodes.all).length) {\n                    this.emit(\"drain\");\n                }\n            });\n            this.emit(\"+node\", redis, key);\n            redis.on(\"error\", function (error) {\n                this.emit(\"nodeError\", error, key);\n            });\n        }\n        return redis;\n    }\n    /**\n     * Reset the pool with a set of nodes.\n     * The old node will be removed.\n     */\n    reset(nodes) {\n        debug(\"Reset with %O\", nodes);\n        const newNodes = {};\n        nodes.forEach((node) => {\n            const key = (0, util_1.getNodeKey)(node);\n            // Don't override the existing (master) node\n            // when the current one is slave.\n            if (!(node.readOnly && newNodes[key])) {\n                newNodes[key] = node;\n            }\n        });\n        Object.keys(this.nodes.all).forEach((key) => {\n            if (!newNodes[key]) {\n                debug(\"Disconnect %s because the node does not hold any slot\", key);\n                this.nodes.all[key].disconnect();\n                this.removeNode(key);\n            }\n        });\n        Object.keys(newNodes).forEach((key) => {\n            const node = newNodes[key];\n            this.findOrCreate(node, node.readOnly);\n        });\n    }\n    /**\n     * Remove a node from the pool.\n     */\n    removeNode(key) {\n        const { nodes } = this;\n        if (nodes.all[key]) {\n            debug(\"Remove %s from the pool\", key);\n            delete nodes.all[key];\n        }\n        delete nodes.master[key];\n        delete nodes.slave[key];\n    }\n}\nexports.default = ConnectionPool;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}