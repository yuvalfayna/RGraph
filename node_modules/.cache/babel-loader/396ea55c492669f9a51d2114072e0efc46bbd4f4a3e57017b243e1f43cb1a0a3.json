{"ast":null,"code":"\"use strict\";\n\n/**\n * Creates an interator for a DoublyLinkedList starting at the given node\n * It's internal cursor will remains relative to the last \"iterated\" node as that\n * node moves through the list until it either iterates to the end of the list,\n * or the the node it's tracking is removed from the list. Until the first 'next'\n * call it tracks the head/tail of the linked list. This means that one can create\n * an iterator on an empty list, then add nodes, and then the iterator will follow\n * those nodes. Because the DoublyLinkedList nodes don't track their owning \"list\" and\n * it's highly inefficient to walk the list for every iteration, the iterator won't know\n * if the node has been detached from one List and added to another list, or if the iterator\n *\n * The created object is an es6 compatible iterator\n */\nclass DoublyLinkedListIterator {\n  /**\n   * @param  {Object} doublyLinkedList     a node that is part of a doublyLinkedList\n   * @param  {Boolean} [reverse=false]     is this a reverse iterator? default: false\n   */\n  constructor(doublyLinkedList, reverse) {\n    this._list = doublyLinkedList;\n    // NOTE: these key names are tied to the DoublyLinkedListIterator\n    this._direction = reverse === true ? \"prev\" : \"next\";\n    this._startPosition = reverse === true ? \"tail\" : \"head\";\n    this._started = false;\n    this._cursor = null;\n    this._done = false;\n  }\n  _start() {\n    this._cursor = this._list[this._startPosition];\n    this._started = true;\n  }\n  _advanceCursor() {\n    if (this._started === false) {\n      this._started = true;\n      this._cursor = this._list[this._startPosition];\n      return;\n    }\n    this._cursor = this._cursor[this._direction];\n  }\n  reset() {\n    this._done = false;\n    this._started = false;\n    this._cursor = null;\n  }\n  remove() {\n    if (this._started === false || this._done === true || this._isCursorDetached()) {\n      return false;\n    }\n    this._list.remove(this._cursor);\n  }\n  next() {\n    if (this._done === true) {\n      return {\n        done: true\n      };\n    }\n    this._advanceCursor();\n\n    // if there is no node at the cursor or the node at the cursor is no longer part of\n    // a doubly linked list then we are done/finished/kaput\n    if (this._cursor === null || this._isCursorDetached()) {\n      this._done = true;\n      return {\n        done: true\n      };\n    }\n    return {\n      value: this._cursor,\n      done: false\n    };\n  }\n\n  /**\n   * Is the node detached from a list?\n   * NOTE: you can trick/bypass/confuse this check by removing a node from one DoublyLinkedList\n   * and adding it to another.\n   * TODO: We can make this smarter by checking the direction of travel and only checking\n   * the required next/prev/head/tail rather than all of them\n   * @return {Boolean}      [description]\n   */\n  _isCursorDetached() {\n    return this._cursor.prev === null && this._cursor.next === null && this._list.tail !== this._cursor && this._list.head !== this._cursor;\n  }\n}\nmodule.exports = DoublyLinkedListIterator;","map":{"version":3,"names":["DoublyLinkedListIterator","constructor","doublyLinkedList","reverse","_list","_direction","_startPosition","_started","_cursor","_done","_start","_advanceCursor","reset","remove","_isCursorDetached","next","done","value","prev","tail","head","module","exports"],"sources":["C:/rgraph/node_modules/generic-pool/lib/DoublyLinkedListIterator.js"],"sourcesContent":["\"use strict\";\n\n/**\n * Creates an interator for a DoublyLinkedList starting at the given node\n * It's internal cursor will remains relative to the last \"iterated\" node as that\n * node moves through the list until it either iterates to the end of the list,\n * or the the node it's tracking is removed from the list. Until the first 'next'\n * call it tracks the head/tail of the linked list. This means that one can create\n * an iterator on an empty list, then add nodes, and then the iterator will follow\n * those nodes. Because the DoublyLinkedList nodes don't track their owning \"list\" and\n * it's highly inefficient to walk the list for every iteration, the iterator won't know\n * if the node has been detached from one List and added to another list, or if the iterator\n *\n * The created object is an es6 compatible iterator\n */\nclass DoublyLinkedListIterator {\n  /**\n   * @param  {Object} doublyLinkedList     a node that is part of a doublyLinkedList\n   * @param  {Boolean} [reverse=false]     is this a reverse iterator? default: false\n   */\n  constructor(doublyLinkedList, reverse) {\n    this._list = doublyLinkedList;\n    // NOTE: these key names are tied to the DoublyLinkedListIterator\n    this._direction = reverse === true ? \"prev\" : \"next\";\n    this._startPosition = reverse === true ? \"tail\" : \"head\";\n    this._started = false;\n    this._cursor = null;\n    this._done = false;\n  }\n\n  _start() {\n    this._cursor = this._list[this._startPosition];\n    this._started = true;\n  }\n\n  _advanceCursor() {\n    if (this._started === false) {\n      this._started = true;\n      this._cursor = this._list[this._startPosition];\n      return;\n    }\n    this._cursor = this._cursor[this._direction];\n  }\n\n  reset() {\n    this._done = false;\n    this._started = false;\n    this._cursor = null;\n  }\n\n  remove() {\n    if (\n      this._started === false ||\n      this._done === true ||\n      this._isCursorDetached()\n    ) {\n      return false;\n    }\n    this._list.remove(this._cursor);\n  }\n\n  next() {\n    if (this._done === true) {\n      return { done: true };\n    }\n\n    this._advanceCursor();\n\n    // if there is no node at the cursor or the node at the cursor is no longer part of\n    // a doubly linked list then we are done/finished/kaput\n    if (this._cursor === null || this._isCursorDetached()) {\n      this._done = true;\n      return { done: true };\n    }\n\n    return {\n      value: this._cursor,\n      done: false\n    };\n  }\n\n  /**\n   * Is the node detached from a list?\n   * NOTE: you can trick/bypass/confuse this check by removing a node from one DoublyLinkedList\n   * and adding it to another.\n   * TODO: We can make this smarter by checking the direction of travel and only checking\n   * the required next/prev/head/tail rather than all of them\n   * @return {Boolean}      [description]\n   */\n  _isCursorDetached() {\n    return (\n      this._cursor.prev === null &&\n      this._cursor.next === null &&\n      this._list.tail !== this._cursor &&\n      this._list.head !== this._cursor\n    );\n  }\n}\n\nmodule.exports = DoublyLinkedListIterator;\n"],"mappings":"AAAA,YAAY;;AAEZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMA,wBAAwB,CAAC;EAC7B;AACF;AACA;AACA;EACEC,WAAWA,CAACC,gBAAgB,EAAEC,OAAO,EAAE;IACrC,IAAI,CAACC,KAAK,GAAGF,gBAAgB;IAC7B;IACA,IAAI,CAACG,UAAU,GAAGF,OAAO,KAAK,IAAI,GAAG,MAAM,GAAG,MAAM;IACpD,IAAI,CAACG,cAAc,GAAGH,OAAO,KAAK,IAAI,GAAG,MAAM,GAAG,MAAM;IACxD,IAAI,CAACI,QAAQ,GAAG,KAAK;IACrB,IAAI,CAACC,OAAO,GAAG,IAAI;IACnB,IAAI,CAACC,KAAK,GAAG,KAAK;EACpB;EAEAC,MAAMA,CAAA,EAAG;IACP,IAAI,CAACF,OAAO,GAAG,IAAI,CAACJ,KAAK,CAAC,IAAI,CAACE,cAAc,CAAC;IAC9C,IAAI,CAACC,QAAQ,GAAG,IAAI;EACtB;EAEAI,cAAcA,CAAA,EAAG;IACf,IAAI,IAAI,CAACJ,QAAQ,KAAK,KAAK,EAAE;MAC3B,IAAI,CAACA,QAAQ,GAAG,IAAI;MACpB,IAAI,CAACC,OAAO,GAAG,IAAI,CAACJ,KAAK,CAAC,IAAI,CAACE,cAAc,CAAC;MAC9C;IACF;IACA,IAAI,CAACE,OAAO,GAAG,IAAI,CAACA,OAAO,CAAC,IAAI,CAACH,UAAU,CAAC;EAC9C;EAEAO,KAAKA,CAAA,EAAG;IACN,IAAI,CAACH,KAAK,GAAG,KAAK;IAClB,IAAI,CAACF,QAAQ,GAAG,KAAK;IACrB,IAAI,CAACC,OAAO,GAAG,IAAI;EACrB;EAEAK,MAAMA,CAAA,EAAG;IACP,IACE,IAAI,CAACN,QAAQ,KAAK,KAAK,IACvB,IAAI,CAACE,KAAK,KAAK,IAAI,IACnB,IAAI,CAACK,iBAAiB,CAAC,CAAC,EACxB;MACA,OAAO,KAAK;IACd;IACA,IAAI,CAACV,KAAK,CAACS,MAAM,CAAC,IAAI,CAACL,OAAO,CAAC;EACjC;EAEAO,IAAIA,CAAA,EAAG;IACL,IAAI,IAAI,CAACN,KAAK,KAAK,IAAI,EAAE;MACvB,OAAO;QAAEO,IAAI,EAAE;MAAK,CAAC;IACvB;IAEA,IAAI,CAACL,cAAc,CAAC,CAAC;;IAErB;IACA;IACA,IAAI,IAAI,CAACH,OAAO,KAAK,IAAI,IAAI,IAAI,CAACM,iBAAiB,CAAC,CAAC,EAAE;MACrD,IAAI,CAACL,KAAK,GAAG,IAAI;MACjB,OAAO;QAAEO,IAAI,EAAE;MAAK,CAAC;IACvB;IAEA,OAAO;MACLC,KAAK,EAAE,IAAI,CAACT,OAAO;MACnBQ,IAAI,EAAE;IACR,CAAC;EACH;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACEF,iBAAiBA,CAAA,EAAG;IAClB,OACE,IAAI,CAACN,OAAO,CAACU,IAAI,KAAK,IAAI,IAC1B,IAAI,CAACV,OAAO,CAACO,IAAI,KAAK,IAAI,IAC1B,IAAI,CAACX,KAAK,CAACe,IAAI,KAAK,IAAI,CAACX,OAAO,IAChC,IAAI,CAACJ,KAAK,CAACgB,IAAI,KAAK,IAAI,CAACZ,OAAO;EAEpC;AACF;AAEAa,MAAM,CAACC,OAAO,GAAGtB,wBAAwB","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}