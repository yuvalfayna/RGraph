{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SentinelIterator = void 0;\nconst net_1 = require(\"net\");\nconst utils_1 = require(\"../../utils\");\nconst tls_1 = require(\"tls\");\nconst SentinelIterator_1 = require(\"./SentinelIterator\");\nexports.SentinelIterator = SentinelIterator_1.default;\nconst AbstractConnector_1 = require(\"../AbstractConnector\");\nconst Redis_1 = require(\"../../Redis\");\nconst FailoverDetector_1 = require(\"./FailoverDetector\");\nconst debug = (0, utils_1.Debug)(\"SentinelConnector\");\nclass SentinelConnector extends AbstractConnector_1.default {\n  constructor(options) {\n    super(options.disconnectTimeout);\n    this.options = options;\n    this.emitter = null;\n    this.failoverDetector = null;\n    if (!this.options.sentinels.length) {\n      throw new Error(\"Requires at least one sentinel to connect to.\");\n    }\n    if (!this.options.name) {\n      throw new Error(\"Requires the name of master.\");\n    }\n    this.sentinelIterator = new SentinelIterator_1.default(this.options.sentinels);\n  }\n  check(info) {\n    const roleMatches = !info.role || this.options.role === info.role;\n    if (!roleMatches) {\n      debug(\"role invalid, expected %s, but got %s\", this.options.role, info.role);\n      // Start from the next item.\n      // Note that `reset` will move the cursor to the previous element,\n      // so we advance two steps here.\n      this.sentinelIterator.next();\n      this.sentinelIterator.next();\n      this.sentinelIterator.reset(true);\n    }\n    return roleMatches;\n  }\n  disconnect() {\n    super.disconnect();\n    if (this.failoverDetector) {\n      this.failoverDetector.cleanup();\n    }\n  }\n  connect(eventEmitter) {\n    this.connecting = true;\n    this.retryAttempts = 0;\n    let lastError;\n    const connectToNext = async () => {\n      const endpoint = this.sentinelIterator.next();\n      if (endpoint.done) {\n        this.sentinelIterator.reset(false);\n        const retryDelay = typeof this.options.sentinelRetryStrategy === \"function\" ? this.options.sentinelRetryStrategy(++this.retryAttempts) : null;\n        let errorMsg = typeof retryDelay !== \"number\" ? \"All sentinels are unreachable and retry is disabled.\" : `All sentinels are unreachable. Retrying from scratch after ${retryDelay}ms.`;\n        if (lastError) {\n          errorMsg += ` Last error: ${lastError.message}`;\n        }\n        debug(errorMsg);\n        const error = new Error(errorMsg);\n        if (typeof retryDelay === \"number\") {\n          eventEmitter(\"error\", error);\n          await new Promise(resolve => setTimeout(resolve, retryDelay));\n          return connectToNext();\n        } else {\n          throw error;\n        }\n      }\n      let resolved = null;\n      let err = null;\n      try {\n        resolved = await this.resolve(endpoint.value);\n      } catch (error) {\n        err = error;\n      }\n      if (!this.connecting) {\n        throw new Error(utils_1.CONNECTION_CLOSED_ERROR_MSG);\n      }\n      const endpointAddress = endpoint.value.host + \":\" + endpoint.value.port;\n      if (resolved) {\n        debug(\"resolved: %s:%s from sentinel %s\", resolved.host, resolved.port, endpointAddress);\n        if (this.options.enableTLSForSentinelMode && this.options.tls) {\n          Object.assign(resolved, this.options.tls);\n          this.stream = (0, tls_1.connect)(resolved);\n          this.stream.once(\"secureConnect\", this.initFailoverDetector.bind(this));\n        } else {\n          this.stream = (0, net_1.createConnection)(resolved);\n          this.stream.once(\"connect\", this.initFailoverDetector.bind(this));\n        }\n        this.stream.once(\"error\", err => {\n          this.firstError = err;\n        });\n        return this.stream;\n      } else {\n        const errorMsg = err ? \"failed to connect to sentinel \" + endpointAddress + \" because \" + err.message : \"connected to sentinel \" + endpointAddress + \" successfully, but got an invalid reply: \" + resolved;\n        debug(errorMsg);\n        eventEmitter(\"sentinelError\", new Error(errorMsg));\n        if (err) {\n          lastError = err;\n        }\n        return connectToNext();\n      }\n    };\n    return connectToNext();\n  }\n  async updateSentinels(client) {\n    if (!this.options.updateSentinels) {\n      return;\n    }\n    const result = await client.sentinel(\"sentinels\", this.options.name);\n    if (!Array.isArray(result)) {\n      return;\n    }\n    result.map(utils_1.packObject).forEach(sentinel => {\n      const flags = sentinel.flags ? sentinel.flags.split(\",\") : [];\n      if (flags.indexOf(\"disconnected\") === -1 && sentinel.ip && sentinel.port) {\n        const endpoint = this.sentinelNatResolve(addressResponseToAddress(sentinel));\n        if (this.sentinelIterator.add(endpoint)) {\n          debug(\"adding sentinel %s:%s\", endpoint.host, endpoint.port);\n        }\n      }\n    });\n    debug(\"Updated internal sentinels: %s\", this.sentinelIterator);\n  }\n  async resolveMaster(client) {\n    const result = await client.sentinel(\"get-master-addr-by-name\", this.options.name);\n    await this.updateSentinels(client);\n    return this.sentinelNatResolve(Array.isArray(result) ? {\n      host: result[0],\n      port: Number(result[1])\n    } : null);\n  }\n  async resolveSlave(client) {\n    const result = await client.sentinel(\"slaves\", this.options.name);\n    if (!Array.isArray(result)) {\n      return null;\n    }\n    const availableSlaves = result.map(utils_1.packObject).filter(slave => slave.flags && !slave.flags.match(/(disconnected|s_down|o_down)/));\n    return this.sentinelNatResolve(selectPreferredSentinel(availableSlaves, this.options.preferredSlaves));\n  }\n  sentinelNatResolve(item) {\n    if (!item || !this.options.natMap) return item;\n    return this.options.natMap[`${item.host}:${item.port}`] || item;\n  }\n  connectToSentinel(endpoint, options) {\n    const redis = new Redis_1.default({\n      port: endpoint.port || 26379,\n      host: endpoint.host,\n      username: this.options.sentinelUsername || null,\n      password: this.options.sentinelPassword || null,\n      family: endpoint.family || (\n      // @ts-expect-error\n      \"path\" in this.options && this.options.path ? undefined :\n      // @ts-expect-error\n      this.options.family),\n      tls: this.options.sentinelTLS,\n      retryStrategy: null,\n      enableReadyCheck: false,\n      connectTimeout: this.options.connectTimeout,\n      commandTimeout: this.options.sentinelCommandTimeout,\n      ...options\n    });\n    // @ts-expect-error\n    return redis;\n  }\n  async resolve(endpoint) {\n    const client = this.connectToSentinel(endpoint);\n    // ignore the errors since resolve* methods will handle them\n    client.on(\"error\", noop);\n    try {\n      if (this.options.role === \"slave\") {\n        return await this.resolveSlave(client);\n      } else {\n        return await this.resolveMaster(client);\n      }\n    } finally {\n      client.disconnect();\n    }\n  }\n  async initFailoverDetector() {\n    var _a;\n    if (!this.options.failoverDetector) {\n      return;\n    }\n    // Move the current sentinel to the first position\n    this.sentinelIterator.reset(true);\n    const sentinels = [];\n    // In case of a large amount of sentinels, limit the number of concurrent connections\n    while (sentinels.length < this.options.sentinelMaxConnections) {\n      const {\n        done,\n        value\n      } = this.sentinelIterator.next();\n      if (done) {\n        break;\n      }\n      const client = this.connectToSentinel(value, {\n        lazyConnect: true,\n        retryStrategy: this.options.sentinelReconnectStrategy\n      });\n      client.on(\"reconnecting\", () => {\n        var _a;\n        // Tests listen to this event\n        (_a = this.emitter) === null || _a === void 0 ? void 0 : _a.emit(\"sentinelReconnecting\");\n      });\n      sentinels.push({\n        address: value,\n        client\n      });\n    }\n    this.sentinelIterator.reset(false);\n    if (this.failoverDetector) {\n      // Clean up previous detector\n      this.failoverDetector.cleanup();\n    }\n    this.failoverDetector = new FailoverDetector_1.FailoverDetector(this, sentinels);\n    await this.failoverDetector.subscribe();\n    // Tests listen to this event\n    (_a = this.emitter) === null || _a === void 0 ? void 0 : _a.emit(\"failoverSubscribed\");\n  }\n}\nexports.default = SentinelConnector;\nfunction selectPreferredSentinel(availableSlaves, preferredSlaves) {\n  if (availableSlaves.length === 0) {\n    return null;\n  }\n  let selectedSlave;\n  if (typeof preferredSlaves === \"function\") {\n    selectedSlave = preferredSlaves(availableSlaves);\n  } else if (preferredSlaves !== null && typeof preferredSlaves === \"object\") {\n    const preferredSlavesArray = Array.isArray(preferredSlaves) ? preferredSlaves : [preferredSlaves];\n    // sort by priority\n    preferredSlavesArray.sort((a, b) => {\n      // default the priority to 1\n      if (!a.prio) {\n        a.prio = 1;\n      }\n      if (!b.prio) {\n        b.prio = 1;\n      }\n      // lowest priority first\n      if (a.prio < b.prio) {\n        return -1;\n      }\n      if (a.prio > b.prio) {\n        return 1;\n      }\n      return 0;\n    });\n    // loop over preferred slaves and return the first match\n    for (let p = 0; p < preferredSlavesArray.length; p++) {\n      for (let a = 0; a < availableSlaves.length; a++) {\n        const slave = availableSlaves[a];\n        if (slave.ip === preferredSlavesArray[p].ip) {\n          if (slave.port === preferredSlavesArray[p].port) {\n            selectedSlave = slave;\n            break;\n          }\n        }\n      }\n      if (selectedSlave) {\n        break;\n      }\n    }\n  }\n  // if none of the preferred slaves are available, a random available slave is returned\n  if (!selectedSlave) {\n    selectedSlave = (0, utils_1.sample)(availableSlaves);\n  }\n  return addressResponseToAddress(selectedSlave);\n}\nfunction addressResponseToAddress(input) {\n  return {\n    host: input.ip,\n    port: Number(input.port)\n  };\n}\nfunction noop() {}","map":{"version":3,"names":["Object","defineProperty","exports","value","SentinelIterator","net_1","require","utils_1","tls_1","SentinelIterator_1","default","AbstractConnector_1","Redis_1","FailoverDetector_1","debug","Debug","SentinelConnector","constructor","options","disconnectTimeout","emitter","failoverDetector","sentinels","length","Error","name","sentinelIterator","check","info","roleMatches","role","next","reset","disconnect","cleanup","connect","eventEmitter","connecting","retryAttempts","lastError","connectToNext","endpoint","done","retryDelay","sentinelRetryStrategy","errorMsg","message","error","Promise","resolve","setTimeout","resolved","err","CONNECTION_CLOSED_ERROR_MSG","endpointAddress","host","port","enableTLSForSentinelMode","tls","assign","stream","once","initFailoverDetector","bind","createConnection","firstError","updateSentinels","client","result","sentinel","Array","isArray","map","packObject","forEach","flags","split","indexOf","ip","sentinelNatResolve","addressResponseToAddress","add","resolveMaster","Number","resolveSlave","availableSlaves","filter","slave","match","selectPreferredSentinel","preferredSlaves","item","natMap","connectToSentinel","redis","username","sentinelUsername","password","sentinelPassword","family","path","undefined","sentinelTLS","retryStrategy","enableReadyCheck","connectTimeout","commandTimeout","sentinelCommandTimeout","on","noop","_a","sentinelMaxConnections","lazyConnect","sentinelReconnectStrategy","emit","push","address","FailoverDetector","subscribe","selectedSlave","preferredSlavesArray","sort","a","b","prio","p","sample","input"],"sources":["C:/rgraph/node_modules/ioredis/built/connectors/SentinelConnector/index.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SentinelIterator = void 0;\nconst net_1 = require(\"net\");\nconst utils_1 = require(\"../../utils\");\nconst tls_1 = require(\"tls\");\nconst SentinelIterator_1 = require(\"./SentinelIterator\");\nexports.SentinelIterator = SentinelIterator_1.default;\nconst AbstractConnector_1 = require(\"../AbstractConnector\");\nconst Redis_1 = require(\"../../Redis\");\nconst FailoverDetector_1 = require(\"./FailoverDetector\");\nconst debug = (0, utils_1.Debug)(\"SentinelConnector\");\nclass SentinelConnector extends AbstractConnector_1.default {\n    constructor(options) {\n        super(options.disconnectTimeout);\n        this.options = options;\n        this.emitter = null;\n        this.failoverDetector = null;\n        if (!this.options.sentinels.length) {\n            throw new Error(\"Requires at least one sentinel to connect to.\");\n        }\n        if (!this.options.name) {\n            throw new Error(\"Requires the name of master.\");\n        }\n        this.sentinelIterator = new SentinelIterator_1.default(this.options.sentinels);\n    }\n    check(info) {\n        const roleMatches = !info.role || this.options.role === info.role;\n        if (!roleMatches) {\n            debug(\"role invalid, expected %s, but got %s\", this.options.role, info.role);\n            // Start from the next item.\n            // Note that `reset` will move the cursor to the previous element,\n            // so we advance two steps here.\n            this.sentinelIterator.next();\n            this.sentinelIterator.next();\n            this.sentinelIterator.reset(true);\n        }\n        return roleMatches;\n    }\n    disconnect() {\n        super.disconnect();\n        if (this.failoverDetector) {\n            this.failoverDetector.cleanup();\n        }\n    }\n    connect(eventEmitter) {\n        this.connecting = true;\n        this.retryAttempts = 0;\n        let lastError;\n        const connectToNext = async () => {\n            const endpoint = this.sentinelIterator.next();\n            if (endpoint.done) {\n                this.sentinelIterator.reset(false);\n                const retryDelay = typeof this.options.sentinelRetryStrategy === \"function\"\n                    ? this.options.sentinelRetryStrategy(++this.retryAttempts)\n                    : null;\n                let errorMsg = typeof retryDelay !== \"number\"\n                    ? \"All sentinels are unreachable and retry is disabled.\"\n                    : `All sentinels are unreachable. Retrying from scratch after ${retryDelay}ms.`;\n                if (lastError) {\n                    errorMsg += ` Last error: ${lastError.message}`;\n                }\n                debug(errorMsg);\n                const error = new Error(errorMsg);\n                if (typeof retryDelay === \"number\") {\n                    eventEmitter(\"error\", error);\n                    await new Promise((resolve) => setTimeout(resolve, retryDelay));\n                    return connectToNext();\n                }\n                else {\n                    throw error;\n                }\n            }\n            let resolved = null;\n            let err = null;\n            try {\n                resolved = await this.resolve(endpoint.value);\n            }\n            catch (error) {\n                err = error;\n            }\n            if (!this.connecting) {\n                throw new Error(utils_1.CONNECTION_CLOSED_ERROR_MSG);\n            }\n            const endpointAddress = endpoint.value.host + \":\" + endpoint.value.port;\n            if (resolved) {\n                debug(\"resolved: %s:%s from sentinel %s\", resolved.host, resolved.port, endpointAddress);\n                if (this.options.enableTLSForSentinelMode && this.options.tls) {\n                    Object.assign(resolved, this.options.tls);\n                    this.stream = (0, tls_1.connect)(resolved);\n                    this.stream.once(\"secureConnect\", this.initFailoverDetector.bind(this));\n                }\n                else {\n                    this.stream = (0, net_1.createConnection)(resolved);\n                    this.stream.once(\"connect\", this.initFailoverDetector.bind(this));\n                }\n                this.stream.once(\"error\", (err) => {\n                    this.firstError = err;\n                });\n                return this.stream;\n            }\n            else {\n                const errorMsg = err\n                    ? \"failed to connect to sentinel \" +\n                        endpointAddress +\n                        \" because \" +\n                        err.message\n                    : \"connected to sentinel \" +\n                        endpointAddress +\n                        \" successfully, but got an invalid reply: \" +\n                        resolved;\n                debug(errorMsg);\n                eventEmitter(\"sentinelError\", new Error(errorMsg));\n                if (err) {\n                    lastError = err;\n                }\n                return connectToNext();\n            }\n        };\n        return connectToNext();\n    }\n    async updateSentinels(client) {\n        if (!this.options.updateSentinels) {\n            return;\n        }\n        const result = await client.sentinel(\"sentinels\", this.options.name);\n        if (!Array.isArray(result)) {\n            return;\n        }\n        result\n            .map(utils_1.packObject)\n            .forEach((sentinel) => {\n            const flags = sentinel.flags ? sentinel.flags.split(\",\") : [];\n            if (flags.indexOf(\"disconnected\") === -1 &&\n                sentinel.ip &&\n                sentinel.port) {\n                const endpoint = this.sentinelNatResolve(addressResponseToAddress(sentinel));\n                if (this.sentinelIterator.add(endpoint)) {\n                    debug(\"adding sentinel %s:%s\", endpoint.host, endpoint.port);\n                }\n            }\n        });\n        debug(\"Updated internal sentinels: %s\", this.sentinelIterator);\n    }\n    async resolveMaster(client) {\n        const result = await client.sentinel(\"get-master-addr-by-name\", this.options.name);\n        await this.updateSentinels(client);\n        return this.sentinelNatResolve(Array.isArray(result)\n            ? { host: result[0], port: Number(result[1]) }\n            : null);\n    }\n    async resolveSlave(client) {\n        const result = await client.sentinel(\"slaves\", this.options.name);\n        if (!Array.isArray(result)) {\n            return null;\n        }\n        const availableSlaves = result\n            .map(utils_1.packObject)\n            .filter((slave) => slave.flags && !slave.flags.match(/(disconnected|s_down|o_down)/));\n        return this.sentinelNatResolve(selectPreferredSentinel(availableSlaves, this.options.preferredSlaves));\n    }\n    sentinelNatResolve(item) {\n        if (!item || !this.options.natMap)\n            return item;\n        return this.options.natMap[`${item.host}:${item.port}`] || item;\n    }\n    connectToSentinel(endpoint, options) {\n        const redis = new Redis_1.default({\n            port: endpoint.port || 26379,\n            host: endpoint.host,\n            username: this.options.sentinelUsername || null,\n            password: this.options.sentinelPassword || null,\n            family: endpoint.family ||\n                // @ts-expect-error\n                (\"path\" in this.options && this.options.path\n                    ? undefined\n                    : // @ts-expect-error\n                        this.options.family),\n            tls: this.options.sentinelTLS,\n            retryStrategy: null,\n            enableReadyCheck: false,\n            connectTimeout: this.options.connectTimeout,\n            commandTimeout: this.options.sentinelCommandTimeout,\n            ...options,\n        });\n        // @ts-expect-error\n        return redis;\n    }\n    async resolve(endpoint) {\n        const client = this.connectToSentinel(endpoint);\n        // ignore the errors since resolve* methods will handle them\n        client.on(\"error\", noop);\n        try {\n            if (this.options.role === \"slave\") {\n                return await this.resolveSlave(client);\n            }\n            else {\n                return await this.resolveMaster(client);\n            }\n        }\n        finally {\n            client.disconnect();\n        }\n    }\n    async initFailoverDetector() {\n        var _a;\n        if (!this.options.failoverDetector) {\n            return;\n        }\n        // Move the current sentinel to the first position\n        this.sentinelIterator.reset(true);\n        const sentinels = [];\n        // In case of a large amount of sentinels, limit the number of concurrent connections\n        while (sentinels.length < this.options.sentinelMaxConnections) {\n            const { done, value } = this.sentinelIterator.next();\n            if (done) {\n                break;\n            }\n            const client = this.connectToSentinel(value, {\n                lazyConnect: true,\n                retryStrategy: this.options.sentinelReconnectStrategy,\n            });\n            client.on(\"reconnecting\", () => {\n                var _a;\n                // Tests listen to this event\n                (_a = this.emitter) === null || _a === void 0 ? void 0 : _a.emit(\"sentinelReconnecting\");\n            });\n            sentinels.push({ address: value, client });\n        }\n        this.sentinelIterator.reset(false);\n        if (this.failoverDetector) {\n            // Clean up previous detector\n            this.failoverDetector.cleanup();\n        }\n        this.failoverDetector = new FailoverDetector_1.FailoverDetector(this, sentinels);\n        await this.failoverDetector.subscribe();\n        // Tests listen to this event\n        (_a = this.emitter) === null || _a === void 0 ? void 0 : _a.emit(\"failoverSubscribed\");\n    }\n}\nexports.default = SentinelConnector;\nfunction selectPreferredSentinel(availableSlaves, preferredSlaves) {\n    if (availableSlaves.length === 0) {\n        return null;\n    }\n    let selectedSlave;\n    if (typeof preferredSlaves === \"function\") {\n        selectedSlave = preferredSlaves(availableSlaves);\n    }\n    else if (preferredSlaves !== null && typeof preferredSlaves === \"object\") {\n        const preferredSlavesArray = Array.isArray(preferredSlaves)\n            ? preferredSlaves\n            : [preferredSlaves];\n        // sort by priority\n        preferredSlavesArray.sort((a, b) => {\n            // default the priority to 1\n            if (!a.prio) {\n                a.prio = 1;\n            }\n            if (!b.prio) {\n                b.prio = 1;\n            }\n            // lowest priority first\n            if (a.prio < b.prio) {\n                return -1;\n            }\n            if (a.prio > b.prio) {\n                return 1;\n            }\n            return 0;\n        });\n        // loop over preferred slaves and return the first match\n        for (let p = 0; p < preferredSlavesArray.length; p++) {\n            for (let a = 0; a < availableSlaves.length; a++) {\n                const slave = availableSlaves[a];\n                if (slave.ip === preferredSlavesArray[p].ip) {\n                    if (slave.port === preferredSlavesArray[p].port) {\n                        selectedSlave = slave;\n                        break;\n                    }\n                }\n            }\n            if (selectedSlave) {\n                break;\n            }\n        }\n    }\n    // if none of the preferred slaves are available, a random available slave is returned\n    if (!selectedSlave) {\n        selectedSlave = (0, utils_1.sample)(availableSlaves);\n    }\n    return addressResponseToAddress(selectedSlave);\n}\nfunction addressResponseToAddress(input) {\n    return { host: input.ip, port: Number(input.port) };\n}\nfunction noop() { }\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}