{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst net_1 = require(\"net\");\nconst tls_1 = require(\"tls\");\nconst utils_1 = require(\"../utils\");\nconst AbstractConnector_1 = require(\"./AbstractConnector\");\nclass StandaloneConnector extends AbstractConnector_1.default {\n  constructor(options) {\n    super(options.disconnectTimeout);\n    this.options = options;\n  }\n  connect(_) {\n    const {\n      options\n    } = this;\n    this.connecting = true;\n    let connectionOptions;\n    if (\"path\" in options && options.path) {\n      connectionOptions = {\n        path: options.path\n      };\n    } else {\n      connectionOptions = {};\n      if (\"port\" in options && options.port != null) {\n        connectionOptions.port = options.port;\n      }\n      if (\"host\" in options && options.host != null) {\n        connectionOptions.host = options.host;\n      }\n      if (\"family\" in options && options.family != null) {\n        connectionOptions.family = options.family;\n      }\n    }\n    if (options.tls) {\n      Object.assign(connectionOptions, options.tls);\n    }\n    // TODO:\n    // We use native Promise here since other Promise\n    // implementation may use different schedulers that\n    // cause issue when the stream is resolved in the\n    // next tick.\n    // Should use the provided promise in the next major\n    // version and do not connect before resolved.\n    return new Promise((resolve, reject) => {\n      process.nextTick(() => {\n        if (!this.connecting) {\n          reject(new Error(utils_1.CONNECTION_CLOSED_ERROR_MSG));\n          return;\n        }\n        try {\n          if (options.tls) {\n            this.stream = (0, tls_1.connect)(connectionOptions);\n          } else {\n            this.stream = (0, net_1.createConnection)(connectionOptions);\n          }\n        } catch (err) {\n          reject(err);\n          return;\n        }\n        this.stream.once(\"error\", err => {\n          this.firstError = err;\n        });\n        resolve(this.stream);\n      });\n    });\n  }\n}\nexports.default = StandaloneConnector;","map":{"version":3,"names":["Object","defineProperty","exports","value","net_1","require","tls_1","utils_1","AbstractConnector_1","StandaloneConnector","default","constructor","options","disconnectTimeout","connect","_","connecting","connectionOptions","path","port","host","family","tls","assign","Promise","resolve","reject","process","nextTick","Error","CONNECTION_CLOSED_ERROR_MSG","stream","createConnection","err","once","firstError"],"sources":["C:/rgraph/node_modules/ioredis/built/connectors/StandaloneConnector.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst net_1 = require(\"net\");\nconst tls_1 = require(\"tls\");\nconst utils_1 = require(\"../utils\");\nconst AbstractConnector_1 = require(\"./AbstractConnector\");\nclass StandaloneConnector extends AbstractConnector_1.default {\n    constructor(options) {\n        super(options.disconnectTimeout);\n        this.options = options;\n    }\n    connect(_) {\n        const { options } = this;\n        this.connecting = true;\n        let connectionOptions;\n        if (\"path\" in options && options.path) {\n            connectionOptions = {\n                path: options.path,\n            };\n        }\n        else {\n            connectionOptions = {};\n            if (\"port\" in options && options.port != null) {\n                connectionOptions.port = options.port;\n            }\n            if (\"host\" in options && options.host != null) {\n                connectionOptions.host = options.host;\n            }\n            if (\"family\" in options && options.family != null) {\n                connectionOptions.family = options.family;\n            }\n        }\n        if (options.tls) {\n            Object.assign(connectionOptions, options.tls);\n        }\n        // TODO:\n        // We use native Promise here since other Promise\n        // implementation may use different schedulers that\n        // cause issue when the stream is resolved in the\n        // next tick.\n        // Should use the provided promise in the next major\n        // version and do not connect before resolved.\n        return new Promise((resolve, reject) => {\n            process.nextTick(() => {\n                if (!this.connecting) {\n                    reject(new Error(utils_1.CONNECTION_CLOSED_ERROR_MSG));\n                    return;\n                }\n                try {\n                    if (options.tls) {\n                        this.stream = (0, tls_1.connect)(connectionOptions);\n                    }\n                    else {\n                        this.stream = (0, net_1.createConnection)(connectionOptions);\n                    }\n                }\n                catch (err) {\n                    reject(err);\n                    return;\n                }\n                this.stream.once(\"error\", (err) => {\n                    this.firstError = err;\n                });\n                resolve(this.stream);\n            });\n        });\n    }\n}\nexports.default = StandaloneConnector;\n"],"mappings":"AAAA,YAAY;;AACZA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7D,MAAMC,KAAK,GAAGC,OAAO,CAAC,KAAK,CAAC;AAC5B,MAAMC,KAAK,GAAGD,OAAO,CAAC,KAAK,CAAC;AAC5B,MAAME,OAAO,GAAGF,OAAO,CAAC,UAAU,CAAC;AACnC,MAAMG,mBAAmB,GAAGH,OAAO,CAAC,qBAAqB,CAAC;AAC1D,MAAMI,mBAAmB,SAASD,mBAAmB,CAACE,OAAO,CAAC;EAC1DC,WAAWA,CAACC,OAAO,EAAE;IACjB,KAAK,CAACA,OAAO,CAACC,iBAAiB,CAAC;IAChC,IAAI,CAACD,OAAO,GAAGA,OAAO;EAC1B;EACAE,OAAOA,CAACC,CAAC,EAAE;IACP,MAAM;MAAEH;IAAQ,CAAC,GAAG,IAAI;IACxB,IAAI,CAACI,UAAU,GAAG,IAAI;IACtB,IAAIC,iBAAiB;IACrB,IAAI,MAAM,IAAIL,OAAO,IAAIA,OAAO,CAACM,IAAI,EAAE;MACnCD,iBAAiB,GAAG;QAChBC,IAAI,EAAEN,OAAO,CAACM;MAClB,CAAC;IACL,CAAC,MACI;MACDD,iBAAiB,GAAG,CAAC,CAAC;MACtB,IAAI,MAAM,IAAIL,OAAO,IAAIA,OAAO,CAACO,IAAI,IAAI,IAAI,EAAE;QAC3CF,iBAAiB,CAACE,IAAI,GAAGP,OAAO,CAACO,IAAI;MACzC;MACA,IAAI,MAAM,IAAIP,OAAO,IAAIA,OAAO,CAACQ,IAAI,IAAI,IAAI,EAAE;QAC3CH,iBAAiB,CAACG,IAAI,GAAGR,OAAO,CAACQ,IAAI;MACzC;MACA,IAAI,QAAQ,IAAIR,OAAO,IAAIA,OAAO,CAACS,MAAM,IAAI,IAAI,EAAE;QAC/CJ,iBAAiB,CAACI,MAAM,GAAGT,OAAO,CAACS,MAAM;MAC7C;IACJ;IACA,IAAIT,OAAO,CAACU,GAAG,EAAE;MACbtB,MAAM,CAACuB,MAAM,CAACN,iBAAiB,EAAEL,OAAO,CAACU,GAAG,CAAC;IACjD;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,OAAO,IAAIE,OAAO,CAAC,CAACC,OAAO,EAAEC,MAAM,KAAK;MACpCC,OAAO,CAACC,QAAQ,CAAC,MAAM;QACnB,IAAI,CAAC,IAAI,CAACZ,UAAU,EAAE;UAClBU,MAAM,CAAC,IAAIG,KAAK,CAACtB,OAAO,CAACuB,2BAA2B,CAAC,CAAC;UACtD;QACJ;QACA,IAAI;UACA,IAAIlB,OAAO,CAACU,GAAG,EAAE;YACb,IAAI,CAACS,MAAM,GAAG,CAAC,CAAC,EAAEzB,KAAK,CAACQ,OAAO,EAAEG,iBAAiB,CAAC;UACvD,CAAC,MACI;YACD,IAAI,CAACc,MAAM,GAAG,CAAC,CAAC,EAAE3B,KAAK,CAAC4B,gBAAgB,EAAEf,iBAAiB,CAAC;UAChE;QACJ,CAAC,CACD,OAAOgB,GAAG,EAAE;UACRP,MAAM,CAACO,GAAG,CAAC;UACX;QACJ;QACA,IAAI,CAACF,MAAM,CAACG,IAAI,CAAC,OAAO,EAAGD,GAAG,IAAK;UAC/B,IAAI,CAACE,UAAU,GAAGF,GAAG;QACzB,CAAC,CAAC;QACFR,OAAO,CAAC,IAAI,CAACM,MAAM,CAAC;MACxB,CAAC,CAAC;IACN,CAAC,CAAC;EACN;AACJ;AACA7B,OAAO,CAACQ,OAAO,GAAGD,mBAAmB","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}