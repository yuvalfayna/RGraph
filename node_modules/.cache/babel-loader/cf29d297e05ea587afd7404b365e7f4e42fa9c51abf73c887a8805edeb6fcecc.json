{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst calculateSlot = require(\"cluster-key-slot\");\nconst commands_1 = require(\"@ioredis/commands\");\nconst standard_as_callback_1 = require(\"standard-as-callback\");\nconst util_1 = require(\"util\");\nconst Command_1 = require(\"./Command\");\nconst utils_1 = require(\"./utils\");\nconst Commander_1 = require(\"./utils/Commander\");\n/*\n  This function derives from the cluster-key-slot implementation.\n  Instead of checking that all keys have the same slot, it checks that all slots are served by the same set of nodes.\n  If this is satisfied, it returns the first key's slot.\n*/\nfunction generateMultiWithNodes(redis, keys) {\n  const slot = calculateSlot(keys[0]);\n  const target = redis._groupsBySlot[slot];\n  for (let i = 1; i < keys.length; i++) {\n    if (redis._groupsBySlot[calculateSlot(keys[i])] !== target) {\n      return -1;\n    }\n  }\n  return slot;\n}\nclass Pipeline extends Commander_1.default {\n  constructor(redis) {\n    super();\n    this.redis = redis;\n    this.isPipeline = true;\n    this.replyPending = 0;\n    this._queue = [];\n    this._result = [];\n    this._transactions = 0;\n    this._shaToScript = {};\n    this.isCluster = this.redis.constructor.name === \"Cluster\" || this.redis.isCluster;\n    this.options = redis.options;\n    Object.keys(redis.scriptsSet).forEach(name => {\n      const script = redis.scriptsSet[name];\n      this._shaToScript[script.sha] = script;\n      this[name] = redis[name];\n      this[name + \"Buffer\"] = redis[name + \"Buffer\"];\n    });\n    redis.addedBuiltinSet.forEach(name => {\n      this[name] = redis[name];\n      this[name + \"Buffer\"] = redis[name + \"Buffer\"];\n    });\n    this.promise = new Promise((resolve, reject) => {\n      this.resolve = resolve;\n      this.reject = reject;\n    });\n    const _this = this;\n    Object.defineProperty(this, \"length\", {\n      get: function () {\n        return _this._queue.length;\n      }\n    });\n  }\n  fillResult(value, position) {\n    if (this._queue[position].name === \"exec\" && Array.isArray(value[1])) {\n      const execLength = value[1].length;\n      for (let i = 0; i < execLength; i++) {\n        if (value[1][i] instanceof Error) {\n          continue;\n        }\n        const cmd = this._queue[position - (execLength - i)];\n        try {\n          value[1][i] = cmd.transformReply(value[1][i]);\n        } catch (err) {\n          value[1][i] = err;\n        }\n      }\n    }\n    this._result[position] = value;\n    if (--this.replyPending) {\n      return;\n    }\n    if (this.isCluster) {\n      let retriable = true;\n      let commonError;\n      for (let i = 0; i < this._result.length; ++i) {\n        const error = this._result[i][0];\n        const command = this._queue[i];\n        if (error) {\n          if (command.name === \"exec\" && error.message === \"EXECABORT Transaction discarded because of previous errors.\") {\n            continue;\n          }\n          if (!commonError) {\n            commonError = {\n              name: error.name,\n              message: error.message\n            };\n          } else if (commonError.name !== error.name || commonError.message !== error.message) {\n            retriable = false;\n            break;\n          }\n        } else if (!command.inTransaction) {\n          const isReadOnly = (0, commands_1.exists)(command.name) && (0, commands_1.hasFlag)(command.name, \"readonly\");\n          if (!isReadOnly) {\n            retriable = false;\n            break;\n          }\n        }\n      }\n      if (commonError && retriable) {\n        const _this = this;\n        const errv = commonError.message.split(\" \");\n        const queue = this._queue;\n        let inTransaction = false;\n        this._queue = [];\n        for (let i = 0; i < queue.length; ++i) {\n          if (errv[0] === \"ASK\" && !inTransaction && queue[i].name !== \"asking\" && (!queue[i - 1] || queue[i - 1].name !== \"asking\")) {\n            const asking = new Command_1.default(\"asking\");\n            asking.ignore = true;\n            this.sendCommand(asking);\n          }\n          queue[i].initPromise();\n          this.sendCommand(queue[i]);\n          inTransaction = queue[i].inTransaction;\n        }\n        let matched = true;\n        if (typeof this.leftRedirections === \"undefined\") {\n          this.leftRedirections = {};\n        }\n        const exec = function () {\n          _this.exec();\n        };\n        const cluster = this.redis;\n        cluster.handleError(commonError, this.leftRedirections, {\n          moved: function (_slot, key) {\n            _this.preferKey = key;\n            cluster.slots[errv[1]] = [key];\n            cluster._groupsBySlot[errv[1]] = cluster._groupsIds[cluster.slots[errv[1]].join(\";\")];\n            cluster.refreshSlotsCache();\n            _this.exec();\n          },\n          ask: function (_slot, key) {\n            _this.preferKey = key;\n            _this.exec();\n          },\n          tryagain: exec,\n          clusterDown: exec,\n          connectionClosed: exec,\n          maxRedirections: () => {\n            matched = false;\n          },\n          defaults: () => {\n            matched = false;\n          }\n        });\n        if (matched) {\n          return;\n        }\n      }\n    }\n    let ignoredCount = 0;\n    for (let i = 0; i < this._queue.length - ignoredCount; ++i) {\n      if (this._queue[i + ignoredCount].ignore) {\n        ignoredCount += 1;\n      }\n      this._result[i] = this._result[i + ignoredCount];\n    }\n    this.resolve(this._result.slice(0, this._result.length - ignoredCount));\n  }\n  sendCommand(command) {\n    if (this._transactions > 0) {\n      command.inTransaction = true;\n    }\n    const position = this._queue.length;\n    command.pipelineIndex = position;\n    command.promise.then(result => {\n      this.fillResult([null, result], position);\n    }).catch(error => {\n      this.fillResult([error], position);\n    });\n    this._queue.push(command);\n    return this;\n  }\n  addBatch(commands) {\n    let command, commandName, args;\n    for (let i = 0; i < commands.length; ++i) {\n      command = commands[i];\n      commandName = command[0];\n      args = command.slice(1);\n      this[commandName].apply(this, args);\n    }\n    return this;\n  }\n}\nexports.default = Pipeline;\n// @ts-expect-error\nconst multi = Pipeline.prototype.multi;\n// @ts-expect-error\nPipeline.prototype.multi = function () {\n  this._transactions += 1;\n  return multi.apply(this, arguments);\n};\n// @ts-expect-error\nconst execBuffer = Pipeline.prototype.execBuffer;\n// @ts-expect-error\nPipeline.prototype.execBuffer = (0, util_1.deprecate)(function () {\n  if (this._transactions > 0) {\n    this._transactions -= 1;\n  }\n  return execBuffer.apply(this, arguments);\n}, \"Pipeline#execBuffer: Use Pipeline#exec instead\");\n// NOTE: To avoid an unhandled promise rejection, this will unconditionally always return this.promise,\n// which always has the rejection handled by standard-as-callback\n// adding the provided rejection callback.\n//\n// If a different promise instance were returned, that promise would cause its own unhandled promise rejection\n// errors, even if that promise unconditionally resolved to **the resolved value of** this.promise.\nPipeline.prototype.exec = function (callback) {\n  // Wait for the cluster to be connected, since we need nodes information before continuing\n  if (this.isCluster && !this.redis.slots.length) {\n    if (this.redis.status === \"wait\") this.redis.connect().catch(utils_1.noop);\n    if (callback && !this.nodeifiedPromise) {\n      this.nodeifiedPromise = true;\n      (0, standard_as_callback_1.default)(this.promise, callback);\n    }\n    this.redis.delayUntilReady(err => {\n      if (err) {\n        this.reject(err);\n        return;\n      }\n      this.exec(callback);\n    });\n    return this.promise;\n  }\n  if (this._transactions > 0) {\n    this._transactions -= 1;\n    return execBuffer.apply(this, arguments);\n  }\n  if (!this.nodeifiedPromise) {\n    this.nodeifiedPromise = true;\n    (0, standard_as_callback_1.default)(this.promise, callback);\n  }\n  if (!this._queue.length) {\n    this.resolve([]);\n  }\n  let pipelineSlot;\n  if (this.isCluster) {\n    // List of the first key for each command\n    const sampleKeys = [];\n    for (let i = 0; i < this._queue.length; i++) {\n      const keys = this._queue[i].getKeys();\n      if (keys.length) {\n        sampleKeys.push(keys[0]);\n      }\n      // For each command, check that the keys belong to the same slot\n      if (keys.length && calculateSlot.generateMulti(keys) < 0) {\n        this.reject(new Error(\"All the keys in a pipeline command should belong to the same slot\"));\n        return this.promise;\n      }\n    }\n    if (sampleKeys.length) {\n      pipelineSlot = generateMultiWithNodes(this.redis, sampleKeys);\n      if (pipelineSlot < 0) {\n        this.reject(new Error(\"All keys in the pipeline should belong to the same slots allocation group\"));\n        return this.promise;\n      }\n    } else {\n      // Send the pipeline to a random node\n      pipelineSlot = Math.random() * 16384 | 0;\n    }\n  }\n  const _this = this;\n  execPipeline();\n  return this.promise;\n  function execPipeline() {\n    let writePending = _this.replyPending = _this._queue.length;\n    let node;\n    if (_this.isCluster) {\n      node = {\n        slot: pipelineSlot,\n        redis: _this.redis.connectionPool.nodes.all[_this.preferKey]\n      };\n    }\n    let data = \"\";\n    let buffers;\n    const stream = {\n      isPipeline: true,\n      destination: _this.isCluster ? node : {\n        redis: _this.redis\n      },\n      write(writable) {\n        if (typeof writable !== \"string\") {\n          if (!buffers) {\n            buffers = [];\n          }\n          if (data) {\n            buffers.push(Buffer.from(data, \"utf8\"));\n            data = \"\";\n          }\n          buffers.push(writable);\n        } else {\n          data += writable;\n        }\n        if (! --writePending) {\n          if (buffers) {\n            if (data) {\n              buffers.push(Buffer.from(data, \"utf8\"));\n            }\n            stream.destination.redis.stream.write(Buffer.concat(buffers));\n          } else {\n            stream.destination.redis.stream.write(data);\n          }\n          // Reset writePending for resending\n          writePending = _this._queue.length;\n          data = \"\";\n          buffers = undefined;\n        }\n      }\n    };\n    for (let i = 0; i < _this._queue.length; ++i) {\n      _this.redis.sendCommand(_this._queue[i], stream, node);\n    }\n    return _this.promise;\n  }\n};","map":{"version":3,"names":["Object","defineProperty","exports","value","calculateSlot","require","commands_1","standard_as_callback_1","util_1","Command_1","utils_1","Commander_1","generateMultiWithNodes","redis","keys","slot","target","_groupsBySlot","i","length","Pipeline","default","constructor","isPipeline","replyPending","_queue","_result","_transactions","_shaToScript","isCluster","name","options","scriptsSet","forEach","script","sha","addedBuiltinSet","promise","Promise","resolve","reject","_this","get","fillResult","position","Array","isArray","execLength","Error","cmd","transformReply","err","retriable","commonError","error","command","message","inTransaction","isReadOnly","exists","hasFlag","errv","split","queue","asking","ignore","sendCommand","initPromise","matched","leftRedirections","exec","cluster","handleError","moved","_slot","key","preferKey","slots","_groupsIds","join","refreshSlotsCache","ask","tryagain","clusterDown","connectionClosed","maxRedirections","defaults","ignoredCount","slice","pipelineIndex","then","result","catch","push","addBatch","commands","commandName","args","apply","multi","prototype","arguments","execBuffer","deprecate","callback","status","connect","noop","nodeifiedPromise","delayUntilReady","pipelineSlot","sampleKeys","getKeys","generateMulti","Math","random","execPipeline","writePending","node","connectionPool","nodes","all","data","buffers","stream","destination","write","writable","Buffer","from","concat","undefined"],"sources":["C:/rgraph/node_modules/ioredis/built/Pipeline.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst calculateSlot = require(\"cluster-key-slot\");\nconst commands_1 = require(\"@ioredis/commands\");\nconst standard_as_callback_1 = require(\"standard-as-callback\");\nconst util_1 = require(\"util\");\nconst Command_1 = require(\"./Command\");\nconst utils_1 = require(\"./utils\");\nconst Commander_1 = require(\"./utils/Commander\");\n/*\n  This function derives from the cluster-key-slot implementation.\n  Instead of checking that all keys have the same slot, it checks that all slots are served by the same set of nodes.\n  If this is satisfied, it returns the first key's slot.\n*/\nfunction generateMultiWithNodes(redis, keys) {\n    const slot = calculateSlot(keys[0]);\n    const target = redis._groupsBySlot[slot];\n    for (let i = 1; i < keys.length; i++) {\n        if (redis._groupsBySlot[calculateSlot(keys[i])] !== target) {\n            return -1;\n        }\n    }\n    return slot;\n}\nclass Pipeline extends Commander_1.default {\n    constructor(redis) {\n        super();\n        this.redis = redis;\n        this.isPipeline = true;\n        this.replyPending = 0;\n        this._queue = [];\n        this._result = [];\n        this._transactions = 0;\n        this._shaToScript = {};\n        this.isCluster =\n            this.redis.constructor.name === \"Cluster\" || this.redis.isCluster;\n        this.options = redis.options;\n        Object.keys(redis.scriptsSet).forEach((name) => {\n            const script = redis.scriptsSet[name];\n            this._shaToScript[script.sha] = script;\n            this[name] = redis[name];\n            this[name + \"Buffer\"] = redis[name + \"Buffer\"];\n        });\n        redis.addedBuiltinSet.forEach((name) => {\n            this[name] = redis[name];\n            this[name + \"Buffer\"] = redis[name + \"Buffer\"];\n        });\n        this.promise = new Promise((resolve, reject) => {\n            this.resolve = resolve;\n            this.reject = reject;\n        });\n        const _this = this;\n        Object.defineProperty(this, \"length\", {\n            get: function () {\n                return _this._queue.length;\n            },\n        });\n    }\n    fillResult(value, position) {\n        if (this._queue[position].name === \"exec\" && Array.isArray(value[1])) {\n            const execLength = value[1].length;\n            for (let i = 0; i < execLength; i++) {\n                if (value[1][i] instanceof Error) {\n                    continue;\n                }\n                const cmd = this._queue[position - (execLength - i)];\n                try {\n                    value[1][i] = cmd.transformReply(value[1][i]);\n                }\n                catch (err) {\n                    value[1][i] = err;\n                }\n            }\n        }\n        this._result[position] = value;\n        if (--this.replyPending) {\n            return;\n        }\n        if (this.isCluster) {\n            let retriable = true;\n            let commonError;\n            for (let i = 0; i < this._result.length; ++i) {\n                const error = this._result[i][0];\n                const command = this._queue[i];\n                if (error) {\n                    if (command.name === \"exec\" &&\n                        error.message ===\n                            \"EXECABORT Transaction discarded because of previous errors.\") {\n                        continue;\n                    }\n                    if (!commonError) {\n                        commonError = {\n                            name: error.name,\n                            message: error.message,\n                        };\n                    }\n                    else if (commonError.name !== error.name ||\n                        commonError.message !== error.message) {\n                        retriable = false;\n                        break;\n                    }\n                }\n                else if (!command.inTransaction) {\n                    const isReadOnly = (0, commands_1.exists)(command.name) && (0, commands_1.hasFlag)(command.name, \"readonly\");\n                    if (!isReadOnly) {\n                        retriable = false;\n                        break;\n                    }\n                }\n            }\n            if (commonError && retriable) {\n                const _this = this;\n                const errv = commonError.message.split(\" \");\n                const queue = this._queue;\n                let inTransaction = false;\n                this._queue = [];\n                for (let i = 0; i < queue.length; ++i) {\n                    if (errv[0] === \"ASK\" &&\n                        !inTransaction &&\n                        queue[i].name !== \"asking\" &&\n                        (!queue[i - 1] || queue[i - 1].name !== \"asking\")) {\n                        const asking = new Command_1.default(\"asking\");\n                        asking.ignore = true;\n                        this.sendCommand(asking);\n                    }\n                    queue[i].initPromise();\n                    this.sendCommand(queue[i]);\n                    inTransaction = queue[i].inTransaction;\n                }\n                let matched = true;\n                if (typeof this.leftRedirections === \"undefined\") {\n                    this.leftRedirections = {};\n                }\n                const exec = function () {\n                    _this.exec();\n                };\n                const cluster = this.redis;\n                cluster.handleError(commonError, this.leftRedirections, {\n                    moved: function (_slot, key) {\n                        _this.preferKey = key;\n                        cluster.slots[errv[1]] = [key];\n                        cluster._groupsBySlot[errv[1]] =\n                            cluster._groupsIds[cluster.slots[errv[1]].join(\";\")];\n                        cluster.refreshSlotsCache();\n                        _this.exec();\n                    },\n                    ask: function (_slot, key) {\n                        _this.preferKey = key;\n                        _this.exec();\n                    },\n                    tryagain: exec,\n                    clusterDown: exec,\n                    connectionClosed: exec,\n                    maxRedirections: () => {\n                        matched = false;\n                    },\n                    defaults: () => {\n                        matched = false;\n                    },\n                });\n                if (matched) {\n                    return;\n                }\n            }\n        }\n        let ignoredCount = 0;\n        for (let i = 0; i < this._queue.length - ignoredCount; ++i) {\n            if (this._queue[i + ignoredCount].ignore) {\n                ignoredCount += 1;\n            }\n            this._result[i] = this._result[i + ignoredCount];\n        }\n        this.resolve(this._result.slice(0, this._result.length - ignoredCount));\n    }\n    sendCommand(command) {\n        if (this._transactions > 0) {\n            command.inTransaction = true;\n        }\n        const position = this._queue.length;\n        command.pipelineIndex = position;\n        command.promise\n            .then((result) => {\n            this.fillResult([null, result], position);\n        })\n            .catch((error) => {\n            this.fillResult([error], position);\n        });\n        this._queue.push(command);\n        return this;\n    }\n    addBatch(commands) {\n        let command, commandName, args;\n        for (let i = 0; i < commands.length; ++i) {\n            command = commands[i];\n            commandName = command[0];\n            args = command.slice(1);\n            this[commandName].apply(this, args);\n        }\n        return this;\n    }\n}\nexports.default = Pipeline;\n// @ts-expect-error\nconst multi = Pipeline.prototype.multi;\n// @ts-expect-error\nPipeline.prototype.multi = function () {\n    this._transactions += 1;\n    return multi.apply(this, arguments);\n};\n// @ts-expect-error\nconst execBuffer = Pipeline.prototype.execBuffer;\n// @ts-expect-error\nPipeline.prototype.execBuffer = (0, util_1.deprecate)(function () {\n    if (this._transactions > 0) {\n        this._transactions -= 1;\n    }\n    return execBuffer.apply(this, arguments);\n}, \"Pipeline#execBuffer: Use Pipeline#exec instead\");\n// NOTE: To avoid an unhandled promise rejection, this will unconditionally always return this.promise,\n// which always has the rejection handled by standard-as-callback\n// adding the provided rejection callback.\n//\n// If a different promise instance were returned, that promise would cause its own unhandled promise rejection\n// errors, even if that promise unconditionally resolved to **the resolved value of** this.promise.\nPipeline.prototype.exec = function (callback) {\n    // Wait for the cluster to be connected, since we need nodes information before continuing\n    if (this.isCluster && !this.redis.slots.length) {\n        if (this.redis.status === \"wait\")\n            this.redis.connect().catch(utils_1.noop);\n        if (callback && !this.nodeifiedPromise) {\n            this.nodeifiedPromise = true;\n            (0, standard_as_callback_1.default)(this.promise, callback);\n        }\n        this.redis.delayUntilReady((err) => {\n            if (err) {\n                this.reject(err);\n                return;\n            }\n            this.exec(callback);\n        });\n        return this.promise;\n    }\n    if (this._transactions > 0) {\n        this._transactions -= 1;\n        return execBuffer.apply(this, arguments);\n    }\n    if (!this.nodeifiedPromise) {\n        this.nodeifiedPromise = true;\n        (0, standard_as_callback_1.default)(this.promise, callback);\n    }\n    if (!this._queue.length) {\n        this.resolve([]);\n    }\n    let pipelineSlot;\n    if (this.isCluster) {\n        // List of the first key for each command\n        const sampleKeys = [];\n        for (let i = 0; i < this._queue.length; i++) {\n            const keys = this._queue[i].getKeys();\n            if (keys.length) {\n                sampleKeys.push(keys[0]);\n            }\n            // For each command, check that the keys belong to the same slot\n            if (keys.length && calculateSlot.generateMulti(keys) < 0) {\n                this.reject(new Error(\"All the keys in a pipeline command should belong to the same slot\"));\n                return this.promise;\n            }\n        }\n        if (sampleKeys.length) {\n            pipelineSlot = generateMultiWithNodes(this.redis, sampleKeys);\n            if (pipelineSlot < 0) {\n                this.reject(new Error(\"All keys in the pipeline should belong to the same slots allocation group\"));\n                return this.promise;\n            }\n        }\n        else {\n            // Send the pipeline to a random node\n            pipelineSlot = (Math.random() * 16384) | 0;\n        }\n    }\n    const _this = this;\n    execPipeline();\n    return this.promise;\n    function execPipeline() {\n        let writePending = (_this.replyPending = _this._queue.length);\n        let node;\n        if (_this.isCluster) {\n            node = {\n                slot: pipelineSlot,\n                redis: _this.redis.connectionPool.nodes.all[_this.preferKey],\n            };\n        }\n        let data = \"\";\n        let buffers;\n        const stream = {\n            isPipeline: true,\n            destination: _this.isCluster ? node : { redis: _this.redis },\n            write(writable) {\n                if (typeof writable !== \"string\") {\n                    if (!buffers) {\n                        buffers = [];\n                    }\n                    if (data) {\n                        buffers.push(Buffer.from(data, \"utf8\"));\n                        data = \"\";\n                    }\n                    buffers.push(writable);\n                }\n                else {\n                    data += writable;\n                }\n                if (!--writePending) {\n                    if (buffers) {\n                        if (data) {\n                            buffers.push(Buffer.from(data, \"utf8\"));\n                        }\n                        stream.destination.redis.stream.write(Buffer.concat(buffers));\n                    }\n                    else {\n                        stream.destination.redis.stream.write(data);\n                    }\n                    // Reset writePending for resending\n                    writePending = _this._queue.length;\n                    data = \"\";\n                    buffers = undefined;\n                }\n            },\n        };\n        for (let i = 0; i < _this._queue.length; ++i) {\n            _this.redis.sendCommand(_this._queue[i], stream, node);\n        }\n        return _this.promise;\n    }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}