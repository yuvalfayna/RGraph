{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.executeWithAutoPipelining = exports.getFirstValueInFlattenedArray = exports.shouldUseAutoPipelining = exports.notAllowedAutoPipelineCommands = exports.kCallbacks = exports.kExec = void 0;\nconst lodash_1 = require(\"./utils/lodash\");\nconst calculateSlot = require(\"cluster-key-slot\");\nconst standard_as_callback_1 = require(\"standard-as-callback\");\nexports.kExec = Symbol(\"exec\");\nexports.kCallbacks = Symbol(\"callbacks\");\nexports.notAllowedAutoPipelineCommands = [\"auth\", \"info\", \"script\", \"quit\", \"cluster\", \"pipeline\", \"multi\", \"subscribe\", \"psubscribe\", \"unsubscribe\", \"unpsubscribe\", \"select\"];\nfunction executeAutoPipeline(client, slotKey) {\n  /*\n    If a pipeline is already executing, keep queueing up commands\n    since ioredis won't serve two pipelines at the same time\n  */\n  if (client._runningAutoPipelines.has(slotKey)) {\n    return;\n  }\n  if (!client._autoPipelines.has(slotKey)) {\n    /*\n      Rare edge case. Somehow, something has deleted this running autopipeline in an immediate\n      call to executeAutoPipeline.\n     \n      Maybe the callback in the pipeline.exec is sometimes called in the same tick,\n      e.g. if redis is disconnected?\n    */\n    return;\n  }\n  client._runningAutoPipelines.add(slotKey);\n  // Get the pipeline and immediately delete it so that new commands are queued on a new pipeline\n  const pipeline = client._autoPipelines.get(slotKey);\n  client._autoPipelines.delete(slotKey);\n  const callbacks = pipeline[exports.kCallbacks];\n  // Stop keeping a reference to callbacks immediately after the callbacks stop being used.\n  // This allows the GC to reclaim objects referenced by callbacks, especially with 16384 slots\n  // in Redis.Cluster\n  pipeline[exports.kCallbacks] = null;\n  // Perform the call\n  pipeline.exec(function (err, results) {\n    client._runningAutoPipelines.delete(slotKey);\n    /*\n      Invoke all callback in nextTick so the stack is cleared\n      and callbacks can throw errors without affecting other callbacks.\n    */\n    if (err) {\n      for (let i = 0; i < callbacks.length; i++) {\n        process.nextTick(callbacks[i], err);\n      }\n    } else {\n      for (let i = 0; i < callbacks.length; i++) {\n        process.nextTick(callbacks[i], ...results[i]);\n      }\n    }\n    // If there is another pipeline on the same node, immediately execute it without waiting for nextTick\n    if (client._autoPipelines.has(slotKey)) {\n      executeAutoPipeline(client, slotKey);\n    }\n  });\n}\nfunction shouldUseAutoPipelining(client, functionName, commandName) {\n  return functionName && client.options.enableAutoPipelining && !client.isPipeline && !exports.notAllowedAutoPipelineCommands.includes(commandName) && !client.options.autoPipeliningIgnoredCommands.includes(commandName);\n}\nexports.shouldUseAutoPipelining = shouldUseAutoPipelining;\nfunction getFirstValueInFlattenedArray(args) {\n  for (let i = 0; i < args.length; i++) {\n    const arg = args[i];\n    if (typeof arg === \"string\") {\n      return arg;\n    } else if (Array.isArray(arg) || (0, lodash_1.isArguments)(arg)) {\n      if (arg.length === 0) {\n        continue;\n      }\n      return arg[0];\n    }\n    const flattened = [arg].flat();\n    if (flattened.length > 0) {\n      return flattened[0];\n    }\n  }\n  return undefined;\n}\nexports.getFirstValueInFlattenedArray = getFirstValueInFlattenedArray;\nfunction executeWithAutoPipelining(client, functionName, commandName, args, callback) {\n  // On cluster mode let's wait for slots to be available\n  if (client.isCluster && !client.slots.length) {\n    if (client.status === \"wait\") client.connect().catch(lodash_1.noop);\n    return (0, standard_as_callback_1.default)(new Promise(function (resolve, reject) {\n      client.delayUntilReady(err => {\n        if (err) {\n          reject(err);\n          return;\n        }\n        executeWithAutoPipelining(client, functionName, commandName, args, null).then(resolve, reject);\n      });\n    }), callback);\n  }\n  // If we have slot information, we can improve routing by grouping slots served by the same subset of nodes\n  // Note that the first value in args may be a (possibly empty) array.\n  // ioredis will only flatten one level of the array, in the Command constructor.\n  const prefix = client.options.keyPrefix || \"\";\n  const slotKey = client.isCluster ? client.slots[calculateSlot(`${prefix}${getFirstValueInFlattenedArray(args)}`)].join(\",\") : \"main\";\n  if (!client._autoPipelines.has(slotKey)) {\n    const pipeline = client.pipeline();\n    pipeline[exports.kExec] = false;\n    pipeline[exports.kCallbacks] = [];\n    client._autoPipelines.set(slotKey, pipeline);\n  }\n  const pipeline = client._autoPipelines.get(slotKey);\n  /*\n    Mark the pipeline as scheduled.\n    The symbol will make sure that the pipeline is only scheduled once per tick.\n    New commands are appended to an already scheduled pipeline.\n  */\n  if (!pipeline[exports.kExec]) {\n    pipeline[exports.kExec] = true;\n    /*\n      Deferring with setImmediate so we have a chance to capture multiple\n      commands that can be scheduled by I/O events already in the event loop queue.\n    */\n    setImmediate(executeAutoPipeline, client, slotKey);\n  }\n  // Create the promise which will execute the command in the pipeline.\n  const autoPipelinePromise = new Promise(function (resolve, reject) {\n    pipeline[exports.kCallbacks].push(function (err, value) {\n      if (err) {\n        reject(err);\n        return;\n      }\n      resolve(value);\n    });\n    if (functionName === \"call\") {\n      args.unshift(commandName);\n    }\n    pipeline[functionName](...args);\n  });\n  return (0, standard_as_callback_1.default)(autoPipelinePromise, callback);\n}\nexports.executeWithAutoPipelining = executeWithAutoPipelining;","map":{"version":3,"names":["Object","defineProperty","exports","value","executeWithAutoPipelining","getFirstValueInFlattenedArray","shouldUseAutoPipelining","notAllowedAutoPipelineCommands","kCallbacks","kExec","lodash_1","require","calculateSlot","standard_as_callback_1","Symbol","executeAutoPipeline","client","slotKey","_runningAutoPipelines","has","_autoPipelines","add","pipeline","get","delete","callbacks","exec","err","results","i","length","process","nextTick","functionName","commandName","options","enableAutoPipelining","isPipeline","includes","autoPipeliningIgnoredCommands","args","arg","Array","isArray","isArguments","flattened","flat","undefined","callback","isCluster","slots","status","connect","catch","noop","default","Promise","resolve","reject","delayUntilReady","then","prefix","keyPrefix","join","set","setImmediate","autoPipelinePromise","push","unshift"],"sources":["C:/rgraph/node_modules/ioredis/built/autoPipelining.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.executeWithAutoPipelining = exports.getFirstValueInFlattenedArray = exports.shouldUseAutoPipelining = exports.notAllowedAutoPipelineCommands = exports.kCallbacks = exports.kExec = void 0;\nconst lodash_1 = require(\"./utils/lodash\");\nconst calculateSlot = require(\"cluster-key-slot\");\nconst standard_as_callback_1 = require(\"standard-as-callback\");\nexports.kExec = Symbol(\"exec\");\nexports.kCallbacks = Symbol(\"callbacks\");\nexports.notAllowedAutoPipelineCommands = [\n    \"auth\",\n    \"info\",\n    \"script\",\n    \"quit\",\n    \"cluster\",\n    \"pipeline\",\n    \"multi\",\n    \"subscribe\",\n    \"psubscribe\",\n    \"unsubscribe\",\n    \"unpsubscribe\",\n    \"select\",\n];\nfunction executeAutoPipeline(client, slotKey) {\n    /*\n      If a pipeline is already executing, keep queueing up commands\n      since ioredis won't serve two pipelines at the same time\n    */\n    if (client._runningAutoPipelines.has(slotKey)) {\n        return;\n    }\n    if (!client._autoPipelines.has(slotKey)) {\n        /*\n          Rare edge case. Somehow, something has deleted this running autopipeline in an immediate\n          call to executeAutoPipeline.\n         \n          Maybe the callback in the pipeline.exec is sometimes called in the same tick,\n          e.g. if redis is disconnected?\n        */\n        return;\n    }\n    client._runningAutoPipelines.add(slotKey);\n    // Get the pipeline and immediately delete it so that new commands are queued on a new pipeline\n    const pipeline = client._autoPipelines.get(slotKey);\n    client._autoPipelines.delete(slotKey);\n    const callbacks = pipeline[exports.kCallbacks];\n    // Stop keeping a reference to callbacks immediately after the callbacks stop being used.\n    // This allows the GC to reclaim objects referenced by callbacks, especially with 16384 slots\n    // in Redis.Cluster\n    pipeline[exports.kCallbacks] = null;\n    // Perform the call\n    pipeline.exec(function (err, results) {\n        client._runningAutoPipelines.delete(slotKey);\n        /*\n          Invoke all callback in nextTick so the stack is cleared\n          and callbacks can throw errors without affecting other callbacks.\n        */\n        if (err) {\n            for (let i = 0; i < callbacks.length; i++) {\n                process.nextTick(callbacks[i], err);\n            }\n        }\n        else {\n            for (let i = 0; i < callbacks.length; i++) {\n                process.nextTick(callbacks[i], ...results[i]);\n            }\n        }\n        // If there is another pipeline on the same node, immediately execute it without waiting for nextTick\n        if (client._autoPipelines.has(slotKey)) {\n            executeAutoPipeline(client, slotKey);\n        }\n    });\n}\nfunction shouldUseAutoPipelining(client, functionName, commandName) {\n    return (functionName &&\n        client.options.enableAutoPipelining &&\n        !client.isPipeline &&\n        !exports.notAllowedAutoPipelineCommands.includes(commandName) &&\n        !client.options.autoPipeliningIgnoredCommands.includes(commandName));\n}\nexports.shouldUseAutoPipelining = shouldUseAutoPipelining;\nfunction getFirstValueInFlattenedArray(args) {\n    for (let i = 0; i < args.length; i++) {\n        const arg = args[i];\n        if (typeof arg === \"string\") {\n            return arg;\n        }\n        else if (Array.isArray(arg) || (0, lodash_1.isArguments)(arg)) {\n            if (arg.length === 0) {\n                continue;\n            }\n            return arg[0];\n        }\n        const flattened = [arg].flat();\n        if (flattened.length > 0) {\n            return flattened[0];\n        }\n    }\n    return undefined;\n}\nexports.getFirstValueInFlattenedArray = getFirstValueInFlattenedArray;\nfunction executeWithAutoPipelining(client, functionName, commandName, args, callback) {\n    // On cluster mode let's wait for slots to be available\n    if (client.isCluster && !client.slots.length) {\n        if (client.status === \"wait\")\n            client.connect().catch(lodash_1.noop);\n        return (0, standard_as_callback_1.default)(new Promise(function (resolve, reject) {\n            client.delayUntilReady((err) => {\n                if (err) {\n                    reject(err);\n                    return;\n                }\n                executeWithAutoPipelining(client, functionName, commandName, args, null).then(resolve, reject);\n            });\n        }), callback);\n    }\n    // If we have slot information, we can improve routing by grouping slots served by the same subset of nodes\n    // Note that the first value in args may be a (possibly empty) array.\n    // ioredis will only flatten one level of the array, in the Command constructor.\n    const prefix = client.options.keyPrefix || \"\";\n    const slotKey = client.isCluster\n        ? client.slots[calculateSlot(`${prefix}${getFirstValueInFlattenedArray(args)}`)].join(\",\")\n        : \"main\";\n    if (!client._autoPipelines.has(slotKey)) {\n        const pipeline = client.pipeline();\n        pipeline[exports.kExec] = false;\n        pipeline[exports.kCallbacks] = [];\n        client._autoPipelines.set(slotKey, pipeline);\n    }\n    const pipeline = client._autoPipelines.get(slotKey);\n    /*\n      Mark the pipeline as scheduled.\n      The symbol will make sure that the pipeline is only scheduled once per tick.\n      New commands are appended to an already scheduled pipeline.\n    */\n    if (!pipeline[exports.kExec]) {\n        pipeline[exports.kExec] = true;\n        /*\n          Deferring with setImmediate so we have a chance to capture multiple\n          commands that can be scheduled by I/O events already in the event loop queue.\n        */\n        setImmediate(executeAutoPipeline, client, slotKey);\n    }\n    // Create the promise which will execute the command in the pipeline.\n    const autoPipelinePromise = new Promise(function (resolve, reject) {\n        pipeline[exports.kCallbacks].push(function (err, value) {\n            if (err) {\n                reject(err);\n                return;\n            }\n            resolve(value);\n        });\n        if (functionName === \"call\") {\n            args.unshift(commandName);\n        }\n        pipeline[functionName](...args);\n    });\n    return (0, standard_as_callback_1.default)(autoPipelinePromise, callback);\n}\nexports.executeWithAutoPipelining = executeWithAutoPipelining;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}