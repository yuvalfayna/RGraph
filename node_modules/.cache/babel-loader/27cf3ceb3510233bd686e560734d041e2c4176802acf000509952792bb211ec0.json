{"ast":null,"code":"'use strict';\n\nconst Buffer = require('buffer').Buffer;\nconst StringDecoder = require('string_decoder').StringDecoder;\nconst decoder = new StringDecoder();\nconst errors = require('redis-errors');\nconst ReplyError = errors.ReplyError;\nconst ParserError = errors.ParserError;\nvar bufferPool = Buffer.allocUnsafe(32 * 1024);\nvar bufferOffset = 0;\nvar interval = null;\nvar counter = 0;\nvar notDecreased = 0;\n\n/**\n * Used for integer numbers only\n * @param {JavascriptRedisParser} parser\n * @returns {undefined|number}\n */\nfunction parseSimpleNumbers(parser) {\n  const length = parser.buffer.length - 1;\n  var offset = parser.offset;\n  var number = 0;\n  var sign = 1;\n  if (parser.buffer[offset] === 45) {\n    sign = -1;\n    offset++;\n  }\n  while (offset < length) {\n    const c1 = parser.buffer[offset++];\n    if (c1 === 13) {\n      // \\r\\n\n      parser.offset = offset + 1;\n      return sign * number;\n    }\n    number = number * 10 + (c1 - 48);\n  }\n}\n\n/**\n * Used for integer numbers in case of the returnNumbers option\n *\n * Reading the string as parts of n SMI is more efficient than\n * using a string directly.\n *\n * @param {JavascriptRedisParser} parser\n * @returns {undefined|string}\n */\nfunction parseStringNumbers(parser) {\n  const length = parser.buffer.length - 1;\n  var offset = parser.offset;\n  var number = 0;\n  var res = '';\n  if (parser.buffer[offset] === 45) {\n    res += '-';\n    offset++;\n  }\n  while (offset < length) {\n    var c1 = parser.buffer[offset++];\n    if (c1 === 13) {\n      // \\r\\n\n      parser.offset = offset + 1;\n      if (number !== 0) {\n        res += number;\n      }\n      return res;\n    } else if (number > 429496728) {\n      res += number * 10 + (c1 - 48);\n      number = 0;\n    } else if (c1 === 48 && number === 0) {\n      res += 0;\n    } else {\n      number = number * 10 + (c1 - 48);\n    }\n  }\n}\n\n/**\n * Parse a '+' redis simple string response but forward the offsets\n * onto convertBufferRange to generate a string.\n * @param {JavascriptRedisParser} parser\n * @returns {undefined|string|Buffer}\n */\nfunction parseSimpleString(parser) {\n  const start = parser.offset;\n  const buffer = parser.buffer;\n  const length = buffer.length - 1;\n  var offset = start;\n  while (offset < length) {\n    if (buffer[offset++] === 13) {\n      // \\r\\n\n      parser.offset = offset + 1;\n      if (parser.optionReturnBuffers === true) {\n        return parser.buffer.slice(start, offset - 1);\n      }\n      return parser.buffer.toString('utf8', start, offset - 1);\n    }\n  }\n}\n\n/**\n * Returns the read length\n * @param {JavascriptRedisParser} parser\n * @returns {undefined|number}\n */\nfunction parseLength(parser) {\n  const length = parser.buffer.length - 1;\n  var offset = parser.offset;\n  var number = 0;\n  while (offset < length) {\n    const c1 = parser.buffer[offset++];\n    if (c1 === 13) {\n      parser.offset = offset + 1;\n      return number;\n    }\n    number = number * 10 + (c1 - 48);\n  }\n}\n\n/**\n * Parse a ':' redis integer response\n *\n * If stringNumbers is activated the parser always returns numbers as string\n * This is important for big numbers (number > Math.pow(2, 53)) as js numbers\n * are 64bit floating point numbers with reduced precision\n *\n * @param {JavascriptRedisParser} parser\n * @returns {undefined|number|string}\n */\nfunction parseInteger(parser) {\n  if (parser.optionStringNumbers === true) {\n    return parseStringNumbers(parser);\n  }\n  return parseSimpleNumbers(parser);\n}\n\n/**\n * Parse a '$' redis bulk string response\n * @param {JavascriptRedisParser} parser\n * @returns {undefined|null|string}\n */\nfunction parseBulkString(parser) {\n  const length = parseLength(parser);\n  if (length === undefined) {\n    return;\n  }\n  if (length < 0) {\n    return null;\n  }\n  const offset = parser.offset + length;\n  if (offset + 2 > parser.buffer.length) {\n    parser.bigStrSize = offset + 2;\n    parser.totalChunkSize = parser.buffer.length;\n    parser.bufferCache.push(parser.buffer);\n    return;\n  }\n  const start = parser.offset;\n  parser.offset = offset + 2;\n  if (parser.optionReturnBuffers === true) {\n    return parser.buffer.slice(start, offset);\n  }\n  return parser.buffer.toString('utf8', start, offset);\n}\n\n/**\n * Parse a '-' redis error response\n * @param {JavascriptRedisParser} parser\n * @returns {ReplyError}\n */\nfunction parseError(parser) {\n  var string = parseSimpleString(parser);\n  if (string !== undefined) {\n    if (parser.optionReturnBuffers === true) {\n      string = string.toString();\n    }\n    return new ReplyError(string);\n  }\n}\n\n/**\n * Parsing error handler, resets parser buffer\n * @param {JavascriptRedisParser} parser\n * @param {number} type\n * @returns {undefined}\n */\nfunction handleError(parser, type) {\n  const err = new ParserError('Protocol error, got ' + JSON.stringify(String.fromCharCode(type)) + ' as reply type byte', JSON.stringify(parser.buffer), parser.offset);\n  parser.buffer = null;\n  parser.returnFatalError(err);\n}\n\n/**\n * Parse a '*' redis array response\n * @param {JavascriptRedisParser} parser\n * @returns {undefined|null|any[]}\n */\nfunction parseArray(parser) {\n  const length = parseLength(parser);\n  if (length === undefined) {\n    return;\n  }\n  if (length < 0) {\n    return null;\n  }\n  const responses = new Array(length);\n  return parseArrayElements(parser, responses, 0);\n}\n\n/**\n * Push a partly parsed array to the stack\n *\n * @param {JavascriptRedisParser} parser\n * @param {any[]} array\n * @param {number} pos\n * @returns {undefined}\n */\nfunction pushArrayCache(parser, array, pos) {\n  parser.arrayCache.push(array);\n  parser.arrayPos.push(pos);\n}\n\n/**\n * Parse chunked redis array response\n * @param {JavascriptRedisParser} parser\n * @returns {undefined|any[]}\n */\nfunction parseArrayChunks(parser) {\n  const tmp = parser.arrayCache.pop();\n  var pos = parser.arrayPos.pop();\n  if (parser.arrayCache.length) {\n    const res = parseArrayChunks(parser);\n    if (res === undefined) {\n      pushArrayCache(parser, tmp, pos);\n      return;\n    }\n    tmp[pos++] = res;\n  }\n  return parseArrayElements(parser, tmp, pos);\n}\n\n/**\n * Parse redis array response elements\n * @param {JavascriptRedisParser} parser\n * @param {Array} responses\n * @param {number} i\n * @returns {undefined|null|any[]}\n */\nfunction parseArrayElements(parser, responses, i) {\n  const bufferLength = parser.buffer.length;\n  while (i < responses.length) {\n    const offset = parser.offset;\n    if (parser.offset >= bufferLength) {\n      pushArrayCache(parser, responses, i);\n      return;\n    }\n    const response = parseType(parser, parser.buffer[parser.offset++]);\n    if (response === undefined) {\n      if (!(parser.arrayCache.length || parser.bufferCache.length)) {\n        parser.offset = offset;\n      }\n      pushArrayCache(parser, responses, i);\n      return;\n    }\n    responses[i] = response;\n    i++;\n  }\n  return responses;\n}\n\n/**\n * Called the appropriate parser for the specified type.\n *\n * 36: $\n * 43: +\n * 42: *\n * 58: :\n * 45: -\n *\n * @param {JavascriptRedisParser} parser\n * @param {number} type\n * @returns {*}\n */\nfunction parseType(parser, type) {\n  switch (type) {\n    case 36:\n      return parseBulkString(parser);\n    case 43:\n      return parseSimpleString(parser);\n    case 42:\n      return parseArray(parser);\n    case 58:\n      return parseInteger(parser);\n    case 45:\n      return parseError(parser);\n    default:\n      return handleError(parser, type);\n  }\n}\n\n/**\n * Decrease the bufferPool size over time\n *\n * Balance between increasing and decreasing the bufferPool.\n * Decrease the bufferPool by 10% by removing the first 10% of the current pool.\n * @returns {undefined}\n */\nfunction decreaseBufferPool() {\n  if (bufferPool.length > 50 * 1024) {\n    if (counter === 1 || notDecreased > counter * 2) {\n      const minSliceLen = Math.floor(bufferPool.length / 10);\n      const sliceLength = minSliceLen < bufferOffset ? bufferOffset : minSliceLen;\n      bufferOffset = 0;\n      bufferPool = bufferPool.slice(sliceLength, bufferPool.length);\n    } else {\n      notDecreased++;\n      counter--;\n    }\n  } else {\n    clearInterval(interval);\n    counter = 0;\n    notDecreased = 0;\n    interval = null;\n  }\n}\n\n/**\n * Check if the requested size fits in the current bufferPool.\n * If it does not, reset and increase the bufferPool accordingly.\n *\n * @param {number} length\n * @returns {undefined}\n */\nfunction resizeBuffer(length) {\n  if (bufferPool.length < length + bufferOffset) {\n    const multiplier = length > 1024 * 1024 * 75 ? 2 : 3;\n    if (bufferOffset > 1024 * 1024 * 111) {\n      bufferOffset = 1024 * 1024 * 50;\n    }\n    bufferPool = Buffer.allocUnsafe(length * multiplier + bufferOffset);\n    bufferOffset = 0;\n    counter++;\n    if (interval === null) {\n      interval = setInterval(decreaseBufferPool, 50);\n    }\n  }\n}\n\n/**\n * Concat a bulk string containing multiple chunks\n *\n * Notes:\n * 1) The first chunk might contain the whole bulk string including the \\r\n * 2) We are only safe to fully add up elements that are neither the first nor any of the last two elements\n *\n * @param {JavascriptRedisParser} parser\n * @returns {String}\n */\nfunction concatBulkString(parser) {\n  const list = parser.bufferCache;\n  const oldOffset = parser.offset;\n  var chunks = list.length;\n  var offset = parser.bigStrSize - parser.totalChunkSize;\n  parser.offset = offset;\n  if (offset <= 2) {\n    if (chunks === 2) {\n      return list[0].toString('utf8', oldOffset, list[0].length + offset - 2);\n    }\n    chunks--;\n    offset = list[list.length - 2].length + offset;\n  }\n  var res = decoder.write(list[0].slice(oldOffset));\n  for (var i = 1; i < chunks - 1; i++) {\n    res += decoder.write(list[i]);\n  }\n  res += decoder.end(list[i].slice(0, offset - 2));\n  return res;\n}\n\n/**\n * Concat the collected chunks from parser.bufferCache.\n *\n * Increases the bufferPool size beforehand if necessary.\n *\n * @param {JavascriptRedisParser} parser\n * @returns {Buffer}\n */\nfunction concatBulkBuffer(parser) {\n  const list = parser.bufferCache;\n  const oldOffset = parser.offset;\n  const length = parser.bigStrSize - oldOffset - 2;\n  var chunks = list.length;\n  var offset = parser.bigStrSize - parser.totalChunkSize;\n  parser.offset = offset;\n  if (offset <= 2) {\n    if (chunks === 2) {\n      return list[0].slice(oldOffset, list[0].length + offset - 2);\n    }\n    chunks--;\n    offset = list[list.length - 2].length + offset;\n  }\n  resizeBuffer(length);\n  const start = bufferOffset;\n  list[0].copy(bufferPool, start, oldOffset, list[0].length);\n  bufferOffset += list[0].length - oldOffset;\n  for (var i = 1; i < chunks - 1; i++) {\n    list[i].copy(bufferPool, bufferOffset);\n    bufferOffset += list[i].length;\n  }\n  list[i].copy(bufferPool, bufferOffset, 0, offset - 2);\n  bufferOffset += offset - 2;\n  return bufferPool.slice(start, bufferOffset);\n}\nclass JavascriptRedisParser {\n  /**\n   * Javascript Redis Parser constructor\n   * @param {{returnError: Function, returnReply: Function, returnFatalError?: Function, returnBuffers: boolean, stringNumbers: boolean }} options\n   * @constructor\n   */\n  constructor(options) {\n    if (!options) {\n      throw new TypeError('Options are mandatory.');\n    }\n    if (typeof options.returnError !== 'function' || typeof options.returnReply !== 'function') {\n      throw new TypeError('The returnReply and returnError options have to be functions.');\n    }\n    this.setReturnBuffers(!!options.returnBuffers);\n    this.setStringNumbers(!!options.stringNumbers);\n    this.returnError = options.returnError;\n    this.returnFatalError = options.returnFatalError || options.returnError;\n    this.returnReply = options.returnReply;\n    this.reset();\n  }\n\n  /**\n   * Reset the parser values to the initial state\n   *\n   * @returns {undefined}\n   */\n  reset() {\n    this.offset = 0;\n    this.buffer = null;\n    this.bigStrSize = 0;\n    this.totalChunkSize = 0;\n    this.bufferCache = [];\n    this.arrayCache = [];\n    this.arrayPos = [];\n  }\n\n  /**\n   * Set the returnBuffers option\n   *\n   * @param {boolean} returnBuffers\n   * @returns {undefined}\n   */\n  setReturnBuffers(returnBuffers) {\n    if (typeof returnBuffers !== 'boolean') {\n      throw new TypeError('The returnBuffers argument has to be a boolean');\n    }\n    this.optionReturnBuffers = returnBuffers;\n  }\n\n  /**\n   * Set the stringNumbers option\n   *\n   * @param {boolean} stringNumbers\n   * @returns {undefined}\n   */\n  setStringNumbers(stringNumbers) {\n    if (typeof stringNumbers !== 'boolean') {\n      throw new TypeError('The stringNumbers argument has to be a boolean');\n    }\n    this.optionStringNumbers = stringNumbers;\n  }\n\n  /**\n   * Parse the redis buffer\n   * @param {Buffer} buffer\n   * @returns {undefined}\n   */\n  execute(buffer) {\n    if (this.buffer === null) {\n      this.buffer = buffer;\n      this.offset = 0;\n    } else if (this.bigStrSize === 0) {\n      const oldLength = this.buffer.length;\n      const remainingLength = oldLength - this.offset;\n      const newBuffer = Buffer.allocUnsafe(remainingLength + buffer.length);\n      this.buffer.copy(newBuffer, 0, this.offset, oldLength);\n      buffer.copy(newBuffer, remainingLength, 0, buffer.length);\n      this.buffer = newBuffer;\n      this.offset = 0;\n      if (this.arrayCache.length) {\n        const arr = parseArrayChunks(this);\n        if (arr === undefined) {\n          return;\n        }\n        this.returnReply(arr);\n      }\n    } else if (this.totalChunkSize + buffer.length >= this.bigStrSize) {\n      this.bufferCache.push(buffer);\n      var tmp = this.optionReturnBuffers ? concatBulkBuffer(this) : concatBulkString(this);\n      this.bigStrSize = 0;\n      this.bufferCache = [];\n      this.buffer = buffer;\n      if (this.arrayCache.length) {\n        this.arrayCache[0][this.arrayPos[0]++] = tmp;\n        tmp = parseArrayChunks(this);\n        if (tmp === undefined) {\n          return;\n        }\n      }\n      this.returnReply(tmp);\n    } else {\n      this.bufferCache.push(buffer);\n      this.totalChunkSize += buffer.length;\n      return;\n    }\n    while (this.offset < this.buffer.length) {\n      const offset = this.offset;\n      const type = this.buffer[this.offset++];\n      const response = parseType(this, type);\n      if (response === undefined) {\n        if (!(this.arrayCache.length || this.bufferCache.length)) {\n          this.offset = offset;\n        }\n        return;\n      }\n      if (type === 45) {\n        this.returnError(response);\n      } else {\n        this.returnReply(response);\n      }\n    }\n    this.buffer = null;\n  }\n}\nmodule.exports = JavascriptRedisParser;","map":{"version":3,"names":["Buffer","require","StringDecoder","decoder","errors","ReplyError","ParserError","bufferPool","allocUnsafe","bufferOffset","interval","counter","notDecreased","parseSimpleNumbers","parser","length","buffer","offset","number","sign","c1","parseStringNumbers","res","parseSimpleString","start","optionReturnBuffers","slice","toString","parseLength","parseInteger","optionStringNumbers","parseBulkString","undefined","bigStrSize","totalChunkSize","bufferCache","push","parseError","string","handleError","type","err","JSON","stringify","String","fromCharCode","returnFatalError","parseArray","responses","Array","parseArrayElements","pushArrayCache","array","pos","arrayCache","arrayPos","parseArrayChunks","tmp","pop","i","bufferLength","response","parseType","decreaseBufferPool","minSliceLen","Math","floor","sliceLength","clearInterval","resizeBuffer","multiplier","setInterval","concatBulkString","list","oldOffset","chunks","write","end","concatBulkBuffer","copy","JavascriptRedisParser","constructor","options","TypeError","returnError","returnReply","setReturnBuffers","returnBuffers","setStringNumbers","stringNumbers","reset","execute","oldLength","remainingLength","newBuffer","arr","module","exports"],"sources":["C:/rgraph/node_modules/redis-parser/lib/parser.js"],"sourcesContent":["'use strict'\n\nconst Buffer = require('buffer').Buffer\nconst StringDecoder = require('string_decoder').StringDecoder\nconst decoder = new StringDecoder()\nconst errors = require('redis-errors')\nconst ReplyError = errors.ReplyError\nconst ParserError = errors.ParserError\nvar bufferPool = Buffer.allocUnsafe(32 * 1024)\nvar bufferOffset = 0\nvar interval = null\nvar counter = 0\nvar notDecreased = 0\n\n/**\n * Used for integer numbers only\n * @param {JavascriptRedisParser} parser\n * @returns {undefined|number}\n */\nfunction parseSimpleNumbers (parser) {\n  const length = parser.buffer.length - 1\n  var offset = parser.offset\n  var number = 0\n  var sign = 1\n\n  if (parser.buffer[offset] === 45) {\n    sign = -1\n    offset++\n  }\n\n  while (offset < length) {\n    const c1 = parser.buffer[offset++]\n    if (c1 === 13) { // \\r\\n\n      parser.offset = offset + 1\n      return sign * number\n    }\n    number = (number * 10) + (c1 - 48)\n  }\n}\n\n/**\n * Used for integer numbers in case of the returnNumbers option\n *\n * Reading the string as parts of n SMI is more efficient than\n * using a string directly.\n *\n * @param {JavascriptRedisParser} parser\n * @returns {undefined|string}\n */\nfunction parseStringNumbers (parser) {\n  const length = parser.buffer.length - 1\n  var offset = parser.offset\n  var number = 0\n  var res = ''\n\n  if (parser.buffer[offset] === 45) {\n    res += '-'\n    offset++\n  }\n\n  while (offset < length) {\n    var c1 = parser.buffer[offset++]\n    if (c1 === 13) { // \\r\\n\n      parser.offset = offset + 1\n      if (number !== 0) {\n        res += number\n      }\n      return res\n    } else if (number > 429496728) {\n      res += (number * 10) + (c1 - 48)\n      number = 0\n    } else if (c1 === 48 && number === 0) {\n      res += 0\n    } else {\n      number = (number * 10) + (c1 - 48)\n    }\n  }\n}\n\n/**\n * Parse a '+' redis simple string response but forward the offsets\n * onto convertBufferRange to generate a string.\n * @param {JavascriptRedisParser} parser\n * @returns {undefined|string|Buffer}\n */\nfunction parseSimpleString (parser) {\n  const start = parser.offset\n  const buffer = parser.buffer\n  const length = buffer.length - 1\n  var offset = start\n\n  while (offset < length) {\n    if (buffer[offset++] === 13) { // \\r\\n\n      parser.offset = offset + 1\n      if (parser.optionReturnBuffers === true) {\n        return parser.buffer.slice(start, offset - 1)\n      }\n      return parser.buffer.toString('utf8', start, offset - 1)\n    }\n  }\n}\n\n/**\n * Returns the read length\n * @param {JavascriptRedisParser} parser\n * @returns {undefined|number}\n */\nfunction parseLength (parser) {\n  const length = parser.buffer.length - 1\n  var offset = parser.offset\n  var number = 0\n\n  while (offset < length) {\n    const c1 = parser.buffer[offset++]\n    if (c1 === 13) {\n      parser.offset = offset + 1\n      return number\n    }\n    number = (number * 10) + (c1 - 48)\n  }\n}\n\n/**\n * Parse a ':' redis integer response\n *\n * If stringNumbers is activated the parser always returns numbers as string\n * This is important for big numbers (number > Math.pow(2, 53)) as js numbers\n * are 64bit floating point numbers with reduced precision\n *\n * @param {JavascriptRedisParser} parser\n * @returns {undefined|number|string}\n */\nfunction parseInteger (parser) {\n  if (parser.optionStringNumbers === true) {\n    return parseStringNumbers(parser)\n  }\n  return parseSimpleNumbers(parser)\n}\n\n/**\n * Parse a '$' redis bulk string response\n * @param {JavascriptRedisParser} parser\n * @returns {undefined|null|string}\n */\nfunction parseBulkString (parser) {\n  const length = parseLength(parser)\n  if (length === undefined) {\n    return\n  }\n  if (length < 0) {\n    return null\n  }\n  const offset = parser.offset + length\n  if (offset + 2 > parser.buffer.length) {\n    parser.bigStrSize = offset + 2\n    parser.totalChunkSize = parser.buffer.length\n    parser.bufferCache.push(parser.buffer)\n    return\n  }\n  const start = parser.offset\n  parser.offset = offset + 2\n  if (parser.optionReturnBuffers === true) {\n    return parser.buffer.slice(start, offset)\n  }\n  return parser.buffer.toString('utf8', start, offset)\n}\n\n/**\n * Parse a '-' redis error response\n * @param {JavascriptRedisParser} parser\n * @returns {ReplyError}\n */\nfunction parseError (parser) {\n  var string = parseSimpleString(parser)\n  if (string !== undefined) {\n    if (parser.optionReturnBuffers === true) {\n      string = string.toString()\n    }\n    return new ReplyError(string)\n  }\n}\n\n/**\n * Parsing error handler, resets parser buffer\n * @param {JavascriptRedisParser} parser\n * @param {number} type\n * @returns {undefined}\n */\nfunction handleError (parser, type) {\n  const err = new ParserError(\n    'Protocol error, got ' + JSON.stringify(String.fromCharCode(type)) + ' as reply type byte',\n    JSON.stringify(parser.buffer),\n    parser.offset\n  )\n  parser.buffer = null\n  parser.returnFatalError(err)\n}\n\n/**\n * Parse a '*' redis array response\n * @param {JavascriptRedisParser} parser\n * @returns {undefined|null|any[]}\n */\nfunction parseArray (parser) {\n  const length = parseLength(parser)\n  if (length === undefined) {\n    return\n  }\n  if (length < 0) {\n    return null\n  }\n  const responses = new Array(length)\n  return parseArrayElements(parser, responses, 0)\n}\n\n/**\n * Push a partly parsed array to the stack\n *\n * @param {JavascriptRedisParser} parser\n * @param {any[]} array\n * @param {number} pos\n * @returns {undefined}\n */\nfunction pushArrayCache (parser, array, pos) {\n  parser.arrayCache.push(array)\n  parser.arrayPos.push(pos)\n}\n\n/**\n * Parse chunked redis array response\n * @param {JavascriptRedisParser} parser\n * @returns {undefined|any[]}\n */\nfunction parseArrayChunks (parser) {\n  const tmp = parser.arrayCache.pop()\n  var pos = parser.arrayPos.pop()\n  if (parser.arrayCache.length) {\n    const res = parseArrayChunks(parser)\n    if (res === undefined) {\n      pushArrayCache(parser, tmp, pos)\n      return\n    }\n    tmp[pos++] = res\n  }\n  return parseArrayElements(parser, tmp, pos)\n}\n\n/**\n * Parse redis array response elements\n * @param {JavascriptRedisParser} parser\n * @param {Array} responses\n * @param {number} i\n * @returns {undefined|null|any[]}\n */\nfunction parseArrayElements (parser, responses, i) {\n  const bufferLength = parser.buffer.length\n  while (i < responses.length) {\n    const offset = parser.offset\n    if (parser.offset >= bufferLength) {\n      pushArrayCache(parser, responses, i)\n      return\n    }\n    const response = parseType(parser, parser.buffer[parser.offset++])\n    if (response === undefined) {\n      if (!(parser.arrayCache.length || parser.bufferCache.length)) {\n        parser.offset = offset\n      }\n      pushArrayCache(parser, responses, i)\n      return\n    }\n    responses[i] = response\n    i++\n  }\n\n  return responses\n}\n\n/**\n * Called the appropriate parser for the specified type.\n *\n * 36: $\n * 43: +\n * 42: *\n * 58: :\n * 45: -\n *\n * @param {JavascriptRedisParser} parser\n * @param {number} type\n * @returns {*}\n */\nfunction parseType (parser, type) {\n  switch (type) {\n    case 36:\n      return parseBulkString(parser)\n    case 43:\n      return parseSimpleString(parser)\n    case 42:\n      return parseArray(parser)\n    case 58:\n      return parseInteger(parser)\n    case 45:\n      return parseError(parser)\n    default:\n      return handleError(parser, type)\n  }\n}\n\n/**\n * Decrease the bufferPool size over time\n *\n * Balance between increasing and decreasing the bufferPool.\n * Decrease the bufferPool by 10% by removing the first 10% of the current pool.\n * @returns {undefined}\n */\nfunction decreaseBufferPool () {\n  if (bufferPool.length > 50 * 1024) {\n    if (counter === 1 || notDecreased > counter * 2) {\n      const minSliceLen = Math.floor(bufferPool.length / 10)\n      const sliceLength = minSliceLen < bufferOffset\n        ? bufferOffset\n        : minSliceLen\n      bufferOffset = 0\n      bufferPool = bufferPool.slice(sliceLength, bufferPool.length)\n    } else {\n      notDecreased++\n      counter--\n    }\n  } else {\n    clearInterval(interval)\n    counter = 0\n    notDecreased = 0\n    interval = null\n  }\n}\n\n/**\n * Check if the requested size fits in the current bufferPool.\n * If it does not, reset and increase the bufferPool accordingly.\n *\n * @param {number} length\n * @returns {undefined}\n */\nfunction resizeBuffer (length) {\n  if (bufferPool.length < length + bufferOffset) {\n    const multiplier = length > 1024 * 1024 * 75 ? 2 : 3\n    if (bufferOffset > 1024 * 1024 * 111) {\n      bufferOffset = 1024 * 1024 * 50\n    }\n    bufferPool = Buffer.allocUnsafe(length * multiplier + bufferOffset)\n    bufferOffset = 0\n    counter++\n    if (interval === null) {\n      interval = setInterval(decreaseBufferPool, 50)\n    }\n  }\n}\n\n/**\n * Concat a bulk string containing multiple chunks\n *\n * Notes:\n * 1) The first chunk might contain the whole bulk string including the \\r\n * 2) We are only safe to fully add up elements that are neither the first nor any of the last two elements\n *\n * @param {JavascriptRedisParser} parser\n * @returns {String}\n */\nfunction concatBulkString (parser) {\n  const list = parser.bufferCache\n  const oldOffset = parser.offset\n  var chunks = list.length\n  var offset = parser.bigStrSize - parser.totalChunkSize\n  parser.offset = offset\n  if (offset <= 2) {\n    if (chunks === 2) {\n      return list[0].toString('utf8', oldOffset, list[0].length + offset - 2)\n    }\n    chunks--\n    offset = list[list.length - 2].length + offset\n  }\n  var res = decoder.write(list[0].slice(oldOffset))\n  for (var i = 1; i < chunks - 1; i++) {\n    res += decoder.write(list[i])\n  }\n  res += decoder.end(list[i].slice(0, offset - 2))\n  return res\n}\n\n/**\n * Concat the collected chunks from parser.bufferCache.\n *\n * Increases the bufferPool size beforehand if necessary.\n *\n * @param {JavascriptRedisParser} parser\n * @returns {Buffer}\n */\nfunction concatBulkBuffer (parser) {\n  const list = parser.bufferCache\n  const oldOffset = parser.offset\n  const length = parser.bigStrSize - oldOffset - 2\n  var chunks = list.length\n  var offset = parser.bigStrSize - parser.totalChunkSize\n  parser.offset = offset\n  if (offset <= 2) {\n    if (chunks === 2) {\n      return list[0].slice(oldOffset, list[0].length + offset - 2)\n    }\n    chunks--\n    offset = list[list.length - 2].length + offset\n  }\n  resizeBuffer(length)\n  const start = bufferOffset\n  list[0].copy(bufferPool, start, oldOffset, list[0].length)\n  bufferOffset += list[0].length - oldOffset\n  for (var i = 1; i < chunks - 1; i++) {\n    list[i].copy(bufferPool, bufferOffset)\n    bufferOffset += list[i].length\n  }\n  list[i].copy(bufferPool, bufferOffset, 0, offset - 2)\n  bufferOffset += offset - 2\n  return bufferPool.slice(start, bufferOffset)\n}\n\nclass JavascriptRedisParser {\n  /**\n   * Javascript Redis Parser constructor\n   * @param {{returnError: Function, returnReply: Function, returnFatalError?: Function, returnBuffers: boolean, stringNumbers: boolean }} options\n   * @constructor\n   */\n  constructor (options) {\n    if (!options) {\n      throw new TypeError('Options are mandatory.')\n    }\n    if (typeof options.returnError !== 'function' || typeof options.returnReply !== 'function') {\n      throw new TypeError('The returnReply and returnError options have to be functions.')\n    }\n    this.setReturnBuffers(!!options.returnBuffers)\n    this.setStringNumbers(!!options.stringNumbers)\n    this.returnError = options.returnError\n    this.returnFatalError = options.returnFatalError || options.returnError\n    this.returnReply = options.returnReply\n    this.reset()\n  }\n\n  /**\n   * Reset the parser values to the initial state\n   *\n   * @returns {undefined}\n   */\n  reset () {\n    this.offset = 0\n    this.buffer = null\n    this.bigStrSize = 0\n    this.totalChunkSize = 0\n    this.bufferCache = []\n    this.arrayCache = []\n    this.arrayPos = []\n  }\n\n  /**\n   * Set the returnBuffers option\n   *\n   * @param {boolean} returnBuffers\n   * @returns {undefined}\n   */\n  setReturnBuffers (returnBuffers) {\n    if (typeof returnBuffers !== 'boolean') {\n      throw new TypeError('The returnBuffers argument has to be a boolean')\n    }\n    this.optionReturnBuffers = returnBuffers\n  }\n\n  /**\n   * Set the stringNumbers option\n   *\n   * @param {boolean} stringNumbers\n   * @returns {undefined}\n   */\n  setStringNumbers (stringNumbers) {\n    if (typeof stringNumbers !== 'boolean') {\n      throw new TypeError('The stringNumbers argument has to be a boolean')\n    }\n    this.optionStringNumbers = stringNumbers\n  }\n\n  /**\n   * Parse the redis buffer\n   * @param {Buffer} buffer\n   * @returns {undefined}\n   */\n  execute (buffer) {\n    if (this.buffer === null) {\n      this.buffer = buffer\n      this.offset = 0\n    } else if (this.bigStrSize === 0) {\n      const oldLength = this.buffer.length\n      const remainingLength = oldLength - this.offset\n      const newBuffer = Buffer.allocUnsafe(remainingLength + buffer.length)\n      this.buffer.copy(newBuffer, 0, this.offset, oldLength)\n      buffer.copy(newBuffer, remainingLength, 0, buffer.length)\n      this.buffer = newBuffer\n      this.offset = 0\n      if (this.arrayCache.length) {\n        const arr = parseArrayChunks(this)\n        if (arr === undefined) {\n          return\n        }\n        this.returnReply(arr)\n      }\n    } else if (this.totalChunkSize + buffer.length >= this.bigStrSize) {\n      this.bufferCache.push(buffer)\n      var tmp = this.optionReturnBuffers ? concatBulkBuffer(this) : concatBulkString(this)\n      this.bigStrSize = 0\n      this.bufferCache = []\n      this.buffer = buffer\n      if (this.arrayCache.length) {\n        this.arrayCache[0][this.arrayPos[0]++] = tmp\n        tmp = parseArrayChunks(this)\n        if (tmp === undefined) {\n          return\n        }\n      }\n      this.returnReply(tmp)\n    } else {\n      this.bufferCache.push(buffer)\n      this.totalChunkSize += buffer.length\n      return\n    }\n\n    while (this.offset < this.buffer.length) {\n      const offset = this.offset\n      const type = this.buffer[this.offset++]\n      const response = parseType(this, type)\n      if (response === undefined) {\n        if (!(this.arrayCache.length || this.bufferCache.length)) {\n          this.offset = offset\n        }\n        return\n      }\n\n      if (type === 45) {\n        this.returnError(response)\n      } else {\n        this.returnReply(response)\n      }\n    }\n\n    this.buffer = null\n  }\n}\n\nmodule.exports = JavascriptRedisParser\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}