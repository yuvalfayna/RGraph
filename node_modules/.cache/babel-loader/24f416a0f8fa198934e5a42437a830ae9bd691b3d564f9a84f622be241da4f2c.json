{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst commands_1 = require(\"@ioredis/commands\");\nconst events_1 = require(\"events\");\nconst standard_as_callback_1 = require(\"standard-as-callback\");\nconst cluster_1 = require(\"./cluster\");\nconst Command_1 = require(\"./Command\");\nconst connectors_1 = require(\"./connectors\");\nconst SentinelConnector_1 = require(\"./connectors/SentinelConnector\");\nconst eventHandler = require(\"./redis/event_handler\");\nconst RedisOptions_1 = require(\"./redis/RedisOptions\");\nconst ScanStream_1 = require(\"./ScanStream\");\nconst transaction_1 = require(\"./transaction\");\nconst utils_1 = require(\"./utils\");\nconst applyMixin_1 = require(\"./utils/applyMixin\");\nconst Commander_1 = require(\"./utils/Commander\");\nconst lodash_1 = require(\"./utils/lodash\");\nconst Deque = require(\"denque\");\nconst debug = (0, utils_1.Debug)(\"redis\");\n/**\n * This is the major component of ioredis.\n * Use it to connect to a standalone Redis server or Sentinels.\n *\n * ```typescript\n * const redis = new Redis(); // Default port is 6379\n * async function main() {\n *   redis.set(\"foo\", \"bar\");\n *   redis.get(\"foo\", (err, result) => {\n *     // `result` should be \"bar\"\n *     console.log(err, result);\n *   });\n *   // Or use Promise\n *   const result = await redis.get(\"foo\");\n * }\n * ```\n */\nclass Redis extends Commander_1.default {\n  constructor(arg1, arg2, arg3) {\n    super();\n    this.status = \"wait\";\n    /**\n     * @ignore\n     */\n    this.isCluster = false;\n    this.reconnectTimeout = null;\n    this.connectionEpoch = 0;\n    this.retryAttempts = 0;\n    this.manuallyClosing = false;\n    // Prepare autopipelines structures\n    this._autoPipelines = new Map();\n    this._runningAutoPipelines = new Set();\n    this.parseOptions(arg1, arg2, arg3);\n    events_1.EventEmitter.call(this);\n    this.resetCommandQueue();\n    this.resetOfflineQueue();\n    if (this.options.Connector) {\n      this.connector = new this.options.Connector(this.options);\n    } else if (this.options.sentinels) {\n      const sentinelConnector = new SentinelConnector_1.default(this.options);\n      sentinelConnector.emitter = this;\n      this.connector = sentinelConnector;\n    } else {\n      this.connector = new connectors_1.StandaloneConnector(this.options);\n    }\n    if (this.options.scripts) {\n      Object.entries(this.options.scripts).forEach(([name, definition]) => {\n        this.defineCommand(name, definition);\n      });\n    }\n    // end(or wait) -> connecting -> connect -> ready -> end\n    if (this.options.lazyConnect) {\n      this.setStatus(\"wait\");\n    } else {\n      this.connect().catch(lodash_1.noop);\n    }\n  }\n  /**\n   * Create a Redis instance.\n   * This is the same as `new Redis()` but is included for compatibility with node-redis.\n   */\n  static createClient(...args) {\n    return new Redis(...args);\n  }\n  get autoPipelineQueueSize() {\n    let queued = 0;\n    for (const pipeline of this._autoPipelines.values()) {\n      queued += pipeline.length;\n    }\n    return queued;\n  }\n  /**\n   * Create a connection to Redis.\n   * This method will be invoked automatically when creating a new Redis instance\n   * unless `lazyConnect: true` is passed.\n   *\n   * When calling this method manually, a Promise is returned, which will\n   * be resolved when the connection status is ready.\n   */\n  connect(callback) {\n    const promise = new Promise((resolve, reject) => {\n      if (this.status === \"connecting\" || this.status === \"connect\" || this.status === \"ready\") {\n        reject(new Error(\"Redis is already connecting/connected\"));\n        return;\n      }\n      this.connectionEpoch += 1;\n      this.setStatus(\"connecting\");\n      const {\n        options\n      } = this;\n      this.condition = {\n        select: options.db,\n        auth: options.username ? [options.username, options.password] : options.password,\n        subscriber: false\n      };\n      const _this = this;\n      (0, standard_as_callback_1.default)(this.connector.connect(function (type, err) {\n        _this.silentEmit(type, err);\n      }), function (err, stream) {\n        if (err) {\n          _this.flushQueue(err);\n          _this.silentEmit(\"error\", err);\n          reject(err);\n          _this.setStatus(\"end\");\n          return;\n        }\n        let CONNECT_EVENT = options.tls ? \"secureConnect\" : \"connect\";\n        if (\"sentinels\" in options && options.sentinels && !options.enableTLSForSentinelMode) {\n          CONNECT_EVENT = \"connect\";\n        }\n        _this.stream = stream;\n        if (options.noDelay) {\n          stream.setNoDelay(true);\n        }\n        // Node ignores setKeepAlive before connect, therefore we wait for the event:\n        // https://github.com/nodejs/node/issues/31663\n        if (typeof options.keepAlive === \"number\") {\n          if (stream.connecting) {\n            stream.once(CONNECT_EVENT, () => {\n              stream.setKeepAlive(true, options.keepAlive);\n            });\n          } else {\n            stream.setKeepAlive(true, options.keepAlive);\n          }\n        }\n        if (stream.connecting) {\n          stream.once(CONNECT_EVENT, eventHandler.connectHandler(_this));\n          if (options.connectTimeout) {\n            /*\n             * Typically, Socket#setTimeout(0) will clear the timer\n             * set before. However, in some platforms (Electron 3.x~4.x),\n             * the timer will not be cleared. So we introduce a variable here.\n             *\n             * See https://github.com/electron/electron/issues/14915\n             */\n            let connectTimeoutCleared = false;\n            stream.setTimeout(options.connectTimeout, function () {\n              if (connectTimeoutCleared) {\n                return;\n              }\n              stream.setTimeout(0);\n              stream.destroy();\n              const err = new Error(\"connect ETIMEDOUT\");\n              // @ts-expect-error\n              err.errorno = \"ETIMEDOUT\";\n              // @ts-expect-error\n              err.code = \"ETIMEDOUT\";\n              // @ts-expect-error\n              err.syscall = \"connect\";\n              eventHandler.errorHandler(_this)(err);\n            });\n            stream.once(CONNECT_EVENT, function () {\n              connectTimeoutCleared = true;\n              stream.setTimeout(0);\n            });\n          }\n        } else if (stream.destroyed) {\n          const firstError = _this.connector.firstError;\n          if (firstError) {\n            process.nextTick(() => {\n              eventHandler.errorHandler(_this)(firstError);\n            });\n          }\n          process.nextTick(eventHandler.closeHandler(_this));\n        } else {\n          process.nextTick(eventHandler.connectHandler(_this));\n        }\n        if (!stream.destroyed) {\n          stream.once(\"error\", eventHandler.errorHandler(_this));\n          stream.once(\"close\", eventHandler.closeHandler(_this));\n        }\n        const connectionReadyHandler = function () {\n          _this.removeListener(\"close\", connectionCloseHandler);\n          resolve();\n        };\n        var connectionCloseHandler = function () {\n          _this.removeListener(\"ready\", connectionReadyHandler);\n          reject(new Error(utils_1.CONNECTION_CLOSED_ERROR_MSG));\n        };\n        _this.once(\"ready\", connectionReadyHandler);\n        _this.once(\"close\", connectionCloseHandler);\n      });\n    });\n    return (0, standard_as_callback_1.default)(promise, callback);\n  }\n  /**\n   * Disconnect from Redis.\n   *\n   * This method closes the connection immediately,\n   * and may lose some pending replies that haven't written to client.\n   * If you want to wait for the pending replies, use Redis#quit instead.\n   */\n  disconnect(reconnect = false) {\n    if (!reconnect) {\n      this.manuallyClosing = true;\n    }\n    if (this.reconnectTimeout && !reconnect) {\n      clearTimeout(this.reconnectTimeout);\n      this.reconnectTimeout = null;\n    }\n    if (this.status === \"wait\") {\n      eventHandler.closeHandler(this)();\n    } else {\n      this.connector.disconnect();\n    }\n  }\n  /**\n   * Disconnect from Redis.\n   *\n   * @deprecated\n   */\n  end() {\n    this.disconnect();\n  }\n  /**\n   * Create a new instance with the same options as the current one.\n   *\n   * @example\n   * ```js\n   * var redis = new Redis(6380);\n   * var anotherRedis = redis.duplicate();\n   * ```\n   */\n  duplicate(override) {\n    return new Redis({\n      ...this.options,\n      ...override\n    });\n  }\n  /**\n   * Mode of the connection.\n   *\n   * One of `\"normal\"`, `\"subscriber\"`, or `\"monitor\"`. When the connection is\n   * not in `\"normal\"` mode, certain commands are not allowed.\n   */\n  get mode() {\n    var _a;\n    return this.options.monitor ? \"monitor\" : ((_a = this.condition) === null || _a === void 0 ? void 0 : _a.subscriber) ? \"subscriber\" : \"normal\";\n  }\n  /**\n   * Listen for all requests received by the server in real time.\n   *\n   * This command will create a new connection to Redis and send a\n   * MONITOR command via the new connection in order to avoid disturbing\n   * the current connection.\n   *\n   * @param callback The callback function. If omit, a promise will be returned.\n   * @example\n   * ```js\n   * var redis = new Redis();\n   * redis.monitor(function (err, monitor) {\n   *   // Entering monitoring mode.\n   *   monitor.on('monitor', function (time, args, source, database) {\n   *     console.log(time + \": \" + util.inspect(args));\n   *   });\n   * });\n   *\n   * // supports promise as well as other commands\n   * redis.monitor().then(function (monitor) {\n   *   monitor.on('monitor', function (time, args, source, database) {\n   *     console.log(time + \": \" + util.inspect(args));\n   *   });\n   * });\n   * ```\n   */\n  monitor(callback) {\n    const monitorInstance = this.duplicate({\n      monitor: true,\n      lazyConnect: false\n    });\n    return (0, standard_as_callback_1.default)(new Promise(function (resolve, reject) {\n      monitorInstance.once(\"error\", reject);\n      monitorInstance.once(\"monitoring\", function () {\n        resolve(monitorInstance);\n      });\n    }), callback);\n  }\n  /**\n   * Send a command to Redis\n   *\n   * This method is used internally and in most cases you should not\n   * use it directly. If you need to send a command that is not supported\n   * by the library, you can use the `call` method:\n   *\n   * ```js\n   * const redis = new Redis();\n   *\n   * redis.call('set', 'foo', 'bar');\n   * // or\n   * redis.call(['set', 'foo', 'bar']);\n   * ```\n   *\n   * @ignore\n   */\n  sendCommand(command, stream) {\n    var _a, _b;\n    if (this.status === \"wait\") {\n      this.connect().catch(lodash_1.noop);\n    }\n    if (this.status === \"end\") {\n      command.reject(new Error(utils_1.CONNECTION_CLOSED_ERROR_MSG));\n      return command.promise;\n    }\n    if (((_a = this.condition) === null || _a === void 0 ? void 0 : _a.subscriber) && !Command_1.default.checkFlag(\"VALID_IN_SUBSCRIBER_MODE\", command.name)) {\n      command.reject(new Error(\"Connection in subscriber mode, only subscriber commands may be used\"));\n      return command.promise;\n    }\n    if (typeof this.options.commandTimeout === \"number\") {\n      command.setTimeout(this.options.commandTimeout);\n    }\n    let writable = this.status === \"ready\" || !stream && this.status === \"connect\" && (0, commands_1.exists)(command.name) && (0, commands_1.hasFlag)(command.name, \"loading\");\n    if (!this.stream) {\n      writable = false;\n    } else if (!this.stream.writable) {\n      writable = false;\n      // @ts-expect-error\n    } else if (this.stream._writableState && this.stream._writableState.ended) {\n      // TODO: We should be able to remove this as the PR has already been merged.\n      // https://github.com/iojs/io.js/pull/1217\n      writable = false;\n    }\n    if (!writable) {\n      if (!this.options.enableOfflineQueue) {\n        command.reject(new Error(\"Stream isn't writeable and enableOfflineQueue options is false\"));\n        return command.promise;\n      }\n      if (command.name === \"quit\" && this.offlineQueue.length === 0) {\n        this.disconnect();\n        command.resolve(Buffer.from(\"OK\"));\n        return command.promise;\n      }\n      // @ts-expect-error\n      if (debug.enabled) {\n        debug(\"queue command[%s]: %d -> %s(%o)\", this._getDescription(), this.condition.select, command.name, command.args);\n      }\n      this.offlineQueue.push({\n        command: command,\n        stream: stream,\n        select: this.condition.select\n      });\n    } else {\n      // @ts-expect-error\n      if (debug.enabled) {\n        debug(\"write command[%s]: %d -> %s(%o)\", this._getDescription(), (_b = this.condition) === null || _b === void 0 ? void 0 : _b.select, command.name, command.args);\n      }\n      if (stream) {\n        if (\"isPipeline\" in stream && stream.isPipeline) {\n          stream.write(command.toWritable(stream.destination.redis.stream));\n        } else {\n          stream.write(command.toWritable(stream));\n        }\n      } else {\n        this.stream.write(command.toWritable(this.stream));\n      }\n      this.commandQueue.push({\n        command: command,\n        stream: stream,\n        select: this.condition.select\n      });\n      if (Command_1.default.checkFlag(\"WILL_DISCONNECT\", command.name)) {\n        this.manuallyClosing = true;\n      }\n      if (this.options.socketTimeout !== undefined && this.socketTimeoutTimer === undefined) {\n        this.setSocketTimeout();\n      }\n    }\n    if (command.name === \"select\" && (0, utils_1.isInt)(command.args[0])) {\n      const db = parseInt(command.args[0], 10);\n      if (this.condition.select !== db) {\n        this.condition.select = db;\n        this.emit(\"select\", db);\n        debug(\"switch to db [%d]\", this.condition.select);\n      }\n    }\n    return command.promise;\n  }\n  setSocketTimeout() {\n    this.socketTimeoutTimer = setTimeout(() => {\n      this.stream.destroy(new Error(`Socket timeout. Expecting data, but didn't receive any in ${this.options.socketTimeout}ms.`));\n      this.socketTimeoutTimer = undefined;\n    }, this.options.socketTimeout);\n    // this handler must run after the \"data\" handler in \"DataHandler\"\n    // so that `this.commandQueue.length` will be updated\n    this.stream.once(\"data\", () => {\n      clearTimeout(this.socketTimeoutTimer);\n      this.socketTimeoutTimer = undefined;\n      if (this.commandQueue.length === 0) return;\n      this.setSocketTimeout();\n    });\n  }\n  scanStream(options) {\n    return this.createScanStream(\"scan\", {\n      options\n    });\n  }\n  scanBufferStream(options) {\n    return this.createScanStream(\"scanBuffer\", {\n      options\n    });\n  }\n  sscanStream(key, options) {\n    return this.createScanStream(\"sscan\", {\n      key,\n      options\n    });\n  }\n  sscanBufferStream(key, options) {\n    return this.createScanStream(\"sscanBuffer\", {\n      key,\n      options\n    });\n  }\n  hscanStream(key, options) {\n    return this.createScanStream(\"hscan\", {\n      key,\n      options\n    });\n  }\n  hscanBufferStream(key, options) {\n    return this.createScanStream(\"hscanBuffer\", {\n      key,\n      options\n    });\n  }\n  zscanStream(key, options) {\n    return this.createScanStream(\"zscan\", {\n      key,\n      options\n    });\n  }\n  zscanBufferStream(key, options) {\n    return this.createScanStream(\"zscanBuffer\", {\n      key,\n      options\n    });\n  }\n  /**\n   * Emit only when there's at least one listener.\n   *\n   * @ignore\n   */\n  silentEmit(eventName, arg) {\n    let error;\n    if (eventName === \"error\") {\n      error = arg;\n      if (this.status === \"end\") {\n        return;\n      }\n      if (this.manuallyClosing) {\n        // ignore connection related errors when manually disconnecting\n        if (error instanceof Error && (error.message === utils_1.CONNECTION_CLOSED_ERROR_MSG ||\n        // @ts-expect-error\n        error.syscall === \"connect\" ||\n        // @ts-expect-error\n        error.syscall === \"read\")) {\n          return;\n        }\n      }\n    }\n    if (this.listeners(eventName).length > 0) {\n      return this.emit.apply(this, arguments);\n    }\n    if (error && error instanceof Error) {\n      console.error(\"[ioredis] Unhandled error event:\", error.stack);\n    }\n    return false;\n  }\n  /**\n   * @ignore\n   */\n  recoverFromFatalError(_commandError, err, options) {\n    this.flushQueue(err, options);\n    this.silentEmit(\"error\", err);\n    this.disconnect(true);\n  }\n  /**\n   * @ignore\n   */\n  handleReconnection(err, item) {\n    var _a;\n    let needReconnect = false;\n    if (this.options.reconnectOnError) {\n      needReconnect = this.options.reconnectOnError(err);\n    }\n    switch (needReconnect) {\n      case 1:\n      case true:\n        if (this.status !== \"reconnecting\") {\n          this.disconnect(true);\n        }\n        item.command.reject(err);\n        break;\n      case 2:\n        if (this.status !== \"reconnecting\") {\n          this.disconnect(true);\n        }\n        if (((_a = this.condition) === null || _a === void 0 ? void 0 : _a.select) !== item.select && item.command.name !== \"select\") {\n          this.select(item.select);\n        }\n        // TODO\n        // @ts-expect-error\n        this.sendCommand(item.command);\n        break;\n      default:\n        item.command.reject(err);\n    }\n  }\n  /**\n   * Get description of the connection. Used for debugging.\n   */\n  _getDescription() {\n    let description;\n    if (\"path\" in this.options && this.options.path) {\n      description = this.options.path;\n    } else if (this.stream && this.stream.remoteAddress && this.stream.remotePort) {\n      description = this.stream.remoteAddress + \":\" + this.stream.remotePort;\n    } else if (\"host\" in this.options && this.options.host) {\n      description = this.options.host + \":\" + this.options.port;\n    } else {\n      // Unexpected\n      description = \"\";\n    }\n    if (this.options.connectionName) {\n      description += ` (${this.options.connectionName})`;\n    }\n    return description;\n  }\n  resetCommandQueue() {\n    this.commandQueue = new Deque();\n  }\n  resetOfflineQueue() {\n    this.offlineQueue = new Deque();\n  }\n  parseOptions(...args) {\n    const options = {};\n    let isTls = false;\n    for (let i = 0; i < args.length; ++i) {\n      const arg = args[i];\n      if (arg === null || typeof arg === \"undefined\") {\n        continue;\n      }\n      if (typeof arg === \"object\") {\n        (0, lodash_1.defaults)(options, arg);\n      } else if (typeof arg === \"string\") {\n        (0, lodash_1.defaults)(options, (0, utils_1.parseURL)(arg));\n        if (arg.startsWith(\"rediss://\")) {\n          isTls = true;\n        }\n      } else if (typeof arg === \"number\") {\n        options.port = arg;\n      } else {\n        throw new Error(\"Invalid argument \" + arg);\n      }\n    }\n    if (isTls) {\n      (0, lodash_1.defaults)(options, {\n        tls: true\n      });\n    }\n    (0, lodash_1.defaults)(options, Redis.defaultOptions);\n    if (typeof options.port === \"string\") {\n      options.port = parseInt(options.port, 10);\n    }\n    if (typeof options.db === \"string\") {\n      options.db = parseInt(options.db, 10);\n    }\n    // @ts-expect-error\n    this.options = (0, utils_1.resolveTLSProfile)(options);\n  }\n  /**\n   * Change instance's status\n   */\n  setStatus(status, arg) {\n    // @ts-expect-error\n    if (debug.enabled) {\n      debug(\"status[%s]: %s -> %s\", this._getDescription(), this.status || \"[empty]\", status);\n    }\n    this.status = status;\n    process.nextTick(this.emit.bind(this, status, arg));\n  }\n  createScanStream(command, {\n    key,\n    options = {}\n  }) {\n    return new ScanStream_1.default({\n      objectMode: true,\n      key: key,\n      redis: this,\n      command: command,\n      ...options\n    });\n  }\n  /**\n   * Flush offline queue and command queue with error.\n   *\n   * @param error The error object to send to the commands\n   * @param options options\n   */\n  flushQueue(error, options) {\n    options = (0, lodash_1.defaults)({}, options, {\n      offlineQueue: true,\n      commandQueue: true\n    });\n    let item;\n    if (options.offlineQueue) {\n      while (item = this.offlineQueue.shift()) {\n        item.command.reject(error);\n      }\n    }\n    if (options.commandQueue) {\n      if (this.commandQueue.length > 0) {\n        if (this.stream) {\n          this.stream.removeAllListeners(\"data\");\n        }\n        while (item = this.commandQueue.shift()) {\n          item.command.reject(error);\n        }\n      }\n    }\n  }\n  /**\n   * Check whether Redis has finished loading the persistent data and is able to\n   * process commands.\n   */\n  _readyCheck(callback) {\n    const _this = this;\n    this.info(function (err, res) {\n      if (err) {\n        if (err.message && err.message.includes(\"NOPERM\")) {\n          console.warn(`Skipping the ready check because INFO command fails: \"${err.message}\". You can disable ready check with \"enableReadyCheck\". More: https://github.com/luin/ioredis/wiki/Disable-ready-check.`);\n          return callback(null, {});\n        }\n        return callback(err);\n      }\n      if (typeof res !== \"string\") {\n        return callback(null, res);\n      }\n      const info = {};\n      const lines = res.split(\"\\r\\n\");\n      for (let i = 0; i < lines.length; ++i) {\n        const [fieldName, ...fieldValueParts] = lines[i].split(\":\");\n        const fieldValue = fieldValueParts.join(\":\");\n        if (fieldValue) {\n          info[fieldName] = fieldValue;\n        }\n      }\n      if (!info.loading || info.loading === \"0\") {\n        callback(null, info);\n      } else {\n        const loadingEtaMs = (info.loading_eta_seconds || 1) * 1000;\n        const retryTime = _this.options.maxLoadingRetryTime && _this.options.maxLoadingRetryTime < loadingEtaMs ? _this.options.maxLoadingRetryTime : loadingEtaMs;\n        debug(\"Redis server still loading, trying again in \" + retryTime + \"ms\");\n        setTimeout(function () {\n          _this._readyCheck(callback);\n        }, retryTime);\n      }\n    }).catch(lodash_1.noop);\n  }\n}\nRedis.Cluster = cluster_1.default;\nRedis.Command = Command_1.default;\n/**\n * Default options\n */\nRedis.defaultOptions = RedisOptions_1.DEFAULT_REDIS_OPTIONS;\n(0, applyMixin_1.default)(Redis, events_1.EventEmitter);\n(0, transaction_1.addTransactionSupport)(Redis.prototype);\nexports.default = Redis;","map":{"version":3,"names":["Object","defineProperty","exports","value","commands_1","require","events_1","standard_as_callback_1","cluster_1","Command_1","connectors_1","SentinelConnector_1","eventHandler","RedisOptions_1","ScanStream_1","transaction_1","utils_1","applyMixin_1","Commander_1","lodash_1","Deque","debug","Debug","Redis","default","constructor","arg1","arg2","arg3","status","isCluster","reconnectTimeout","connectionEpoch","retryAttempts","manuallyClosing","_autoPipelines","Map","_runningAutoPipelines","Set","parseOptions","EventEmitter","call","resetCommandQueue","resetOfflineQueue","options","Connector","connector","sentinels","sentinelConnector","emitter","StandaloneConnector","scripts","entries","forEach","name","definition","defineCommand","lazyConnect","setStatus","connect","catch","noop","createClient","args","autoPipelineQueueSize","queued","pipeline","values","length","callback","promise","Promise","resolve","reject","Error","condition","select","db","auth","username","password","subscriber","_this","type","err","silentEmit","stream","flushQueue","CONNECT_EVENT","tls","enableTLSForSentinelMode","noDelay","setNoDelay","keepAlive","connecting","once","setKeepAlive","connectHandler","connectTimeout","connectTimeoutCleared","setTimeout","destroy","errorno","code","syscall","errorHandler","destroyed","firstError","process","nextTick","closeHandler","connectionReadyHandler","removeListener","connectionCloseHandler","CONNECTION_CLOSED_ERROR_MSG","disconnect","reconnect","clearTimeout","end","duplicate","override","mode","_a","monitor","monitorInstance","sendCommand","command","_b","checkFlag","commandTimeout","writable","exists","hasFlag","_writableState","ended","enableOfflineQueue","offlineQueue","Buffer","from","enabled","_getDescription","push","isPipeline","write","toWritable","destination","redis","commandQueue","socketTimeout","undefined","socketTimeoutTimer","setSocketTimeout","isInt","parseInt","emit","scanStream","createScanStream","scanBufferStream","sscanStream","key","sscanBufferStream","hscanStream","hscanBufferStream","zscanStream","zscanBufferStream","eventName","arg","error","message","listeners","apply","arguments","console","stack","recoverFromFatalError","_commandError","handleReconnection","item","needReconnect","reconnectOnError","description","path","remoteAddress","remotePort","host","port","connectionName","isTls","i","defaults","parseURL","startsWith","defaultOptions","resolveTLSProfile","bind","objectMode","shift","removeAllListeners","_readyCheck","info","res","includes","warn","lines","split","fieldName","fieldValueParts","fieldValue","join","loading","loadingEtaMs","loading_eta_seconds","retryTime","maxLoadingRetryTime","Cluster","Command","DEFAULT_REDIS_OPTIONS","addTransactionSupport","prototype"],"sources":["C:/rgraph/node_modules/ioredis/built/Redis.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst commands_1 = require(\"@ioredis/commands\");\nconst events_1 = require(\"events\");\nconst standard_as_callback_1 = require(\"standard-as-callback\");\nconst cluster_1 = require(\"./cluster\");\nconst Command_1 = require(\"./Command\");\nconst connectors_1 = require(\"./connectors\");\nconst SentinelConnector_1 = require(\"./connectors/SentinelConnector\");\nconst eventHandler = require(\"./redis/event_handler\");\nconst RedisOptions_1 = require(\"./redis/RedisOptions\");\nconst ScanStream_1 = require(\"./ScanStream\");\nconst transaction_1 = require(\"./transaction\");\nconst utils_1 = require(\"./utils\");\nconst applyMixin_1 = require(\"./utils/applyMixin\");\nconst Commander_1 = require(\"./utils/Commander\");\nconst lodash_1 = require(\"./utils/lodash\");\nconst Deque = require(\"denque\");\nconst debug = (0, utils_1.Debug)(\"redis\");\n/**\n * This is the major component of ioredis.\n * Use it to connect to a standalone Redis server or Sentinels.\n *\n * ```typescript\n * const redis = new Redis(); // Default port is 6379\n * async function main() {\n *   redis.set(\"foo\", \"bar\");\n *   redis.get(\"foo\", (err, result) => {\n *     // `result` should be \"bar\"\n *     console.log(err, result);\n *   });\n *   // Or use Promise\n *   const result = await redis.get(\"foo\");\n * }\n * ```\n */\nclass Redis extends Commander_1.default {\n    constructor(arg1, arg2, arg3) {\n        super();\n        this.status = \"wait\";\n        /**\n         * @ignore\n         */\n        this.isCluster = false;\n        this.reconnectTimeout = null;\n        this.connectionEpoch = 0;\n        this.retryAttempts = 0;\n        this.manuallyClosing = false;\n        // Prepare autopipelines structures\n        this._autoPipelines = new Map();\n        this._runningAutoPipelines = new Set();\n        this.parseOptions(arg1, arg2, arg3);\n        events_1.EventEmitter.call(this);\n        this.resetCommandQueue();\n        this.resetOfflineQueue();\n        if (this.options.Connector) {\n            this.connector = new this.options.Connector(this.options);\n        }\n        else if (this.options.sentinels) {\n            const sentinelConnector = new SentinelConnector_1.default(this.options);\n            sentinelConnector.emitter = this;\n            this.connector = sentinelConnector;\n        }\n        else {\n            this.connector = new connectors_1.StandaloneConnector(this.options);\n        }\n        if (this.options.scripts) {\n            Object.entries(this.options.scripts).forEach(([name, definition]) => {\n                this.defineCommand(name, definition);\n            });\n        }\n        // end(or wait) -> connecting -> connect -> ready -> end\n        if (this.options.lazyConnect) {\n            this.setStatus(\"wait\");\n        }\n        else {\n            this.connect().catch(lodash_1.noop);\n        }\n    }\n    /**\n     * Create a Redis instance.\n     * This is the same as `new Redis()` but is included for compatibility with node-redis.\n     */\n    static createClient(...args) {\n        return new Redis(...args);\n    }\n    get autoPipelineQueueSize() {\n        let queued = 0;\n        for (const pipeline of this._autoPipelines.values()) {\n            queued += pipeline.length;\n        }\n        return queued;\n    }\n    /**\n     * Create a connection to Redis.\n     * This method will be invoked automatically when creating a new Redis instance\n     * unless `lazyConnect: true` is passed.\n     *\n     * When calling this method manually, a Promise is returned, which will\n     * be resolved when the connection status is ready.\n     */\n    connect(callback) {\n        const promise = new Promise((resolve, reject) => {\n            if (this.status === \"connecting\" ||\n                this.status === \"connect\" ||\n                this.status === \"ready\") {\n                reject(new Error(\"Redis is already connecting/connected\"));\n                return;\n            }\n            this.connectionEpoch += 1;\n            this.setStatus(\"connecting\");\n            const { options } = this;\n            this.condition = {\n                select: options.db,\n                auth: options.username\n                    ? [options.username, options.password]\n                    : options.password,\n                subscriber: false,\n            };\n            const _this = this;\n            (0, standard_as_callback_1.default)(this.connector.connect(function (type, err) {\n                _this.silentEmit(type, err);\n            }), function (err, stream) {\n                if (err) {\n                    _this.flushQueue(err);\n                    _this.silentEmit(\"error\", err);\n                    reject(err);\n                    _this.setStatus(\"end\");\n                    return;\n                }\n                let CONNECT_EVENT = options.tls ? \"secureConnect\" : \"connect\";\n                if (\"sentinels\" in options &&\n                    options.sentinels &&\n                    !options.enableTLSForSentinelMode) {\n                    CONNECT_EVENT = \"connect\";\n                }\n                _this.stream = stream;\n                if (options.noDelay) {\n                    stream.setNoDelay(true);\n                }\n                // Node ignores setKeepAlive before connect, therefore we wait for the event:\n                // https://github.com/nodejs/node/issues/31663\n                if (typeof options.keepAlive === \"number\") {\n                    if (stream.connecting) {\n                        stream.once(CONNECT_EVENT, () => {\n                            stream.setKeepAlive(true, options.keepAlive);\n                        });\n                    }\n                    else {\n                        stream.setKeepAlive(true, options.keepAlive);\n                    }\n                }\n                if (stream.connecting) {\n                    stream.once(CONNECT_EVENT, eventHandler.connectHandler(_this));\n                    if (options.connectTimeout) {\n                        /*\n                         * Typically, Socket#setTimeout(0) will clear the timer\n                         * set before. However, in some platforms (Electron 3.x~4.x),\n                         * the timer will not be cleared. So we introduce a variable here.\n                         *\n                         * See https://github.com/electron/electron/issues/14915\n                         */\n                        let connectTimeoutCleared = false;\n                        stream.setTimeout(options.connectTimeout, function () {\n                            if (connectTimeoutCleared) {\n                                return;\n                            }\n                            stream.setTimeout(0);\n                            stream.destroy();\n                            const err = new Error(\"connect ETIMEDOUT\");\n                            // @ts-expect-error\n                            err.errorno = \"ETIMEDOUT\";\n                            // @ts-expect-error\n                            err.code = \"ETIMEDOUT\";\n                            // @ts-expect-error\n                            err.syscall = \"connect\";\n                            eventHandler.errorHandler(_this)(err);\n                        });\n                        stream.once(CONNECT_EVENT, function () {\n                            connectTimeoutCleared = true;\n                            stream.setTimeout(0);\n                        });\n                    }\n                }\n                else if (stream.destroyed) {\n                    const firstError = _this.connector.firstError;\n                    if (firstError) {\n                        process.nextTick(() => {\n                            eventHandler.errorHandler(_this)(firstError);\n                        });\n                    }\n                    process.nextTick(eventHandler.closeHandler(_this));\n                }\n                else {\n                    process.nextTick(eventHandler.connectHandler(_this));\n                }\n                if (!stream.destroyed) {\n                    stream.once(\"error\", eventHandler.errorHandler(_this));\n                    stream.once(\"close\", eventHandler.closeHandler(_this));\n                }\n                const connectionReadyHandler = function () {\n                    _this.removeListener(\"close\", connectionCloseHandler);\n                    resolve();\n                };\n                var connectionCloseHandler = function () {\n                    _this.removeListener(\"ready\", connectionReadyHandler);\n                    reject(new Error(utils_1.CONNECTION_CLOSED_ERROR_MSG));\n                };\n                _this.once(\"ready\", connectionReadyHandler);\n                _this.once(\"close\", connectionCloseHandler);\n            });\n        });\n        return (0, standard_as_callback_1.default)(promise, callback);\n    }\n    /**\n     * Disconnect from Redis.\n     *\n     * This method closes the connection immediately,\n     * and may lose some pending replies that haven't written to client.\n     * If you want to wait for the pending replies, use Redis#quit instead.\n     */\n    disconnect(reconnect = false) {\n        if (!reconnect) {\n            this.manuallyClosing = true;\n        }\n        if (this.reconnectTimeout && !reconnect) {\n            clearTimeout(this.reconnectTimeout);\n            this.reconnectTimeout = null;\n        }\n        if (this.status === \"wait\") {\n            eventHandler.closeHandler(this)();\n        }\n        else {\n            this.connector.disconnect();\n        }\n    }\n    /**\n     * Disconnect from Redis.\n     *\n     * @deprecated\n     */\n    end() {\n        this.disconnect();\n    }\n    /**\n     * Create a new instance with the same options as the current one.\n     *\n     * @example\n     * ```js\n     * var redis = new Redis(6380);\n     * var anotherRedis = redis.duplicate();\n     * ```\n     */\n    duplicate(override) {\n        return new Redis({ ...this.options, ...override });\n    }\n    /**\n     * Mode of the connection.\n     *\n     * One of `\"normal\"`, `\"subscriber\"`, or `\"monitor\"`. When the connection is\n     * not in `\"normal\"` mode, certain commands are not allowed.\n     */\n    get mode() {\n        var _a;\n        return this.options.monitor\n            ? \"monitor\"\n            : ((_a = this.condition) === null || _a === void 0 ? void 0 : _a.subscriber)\n                ? \"subscriber\"\n                : \"normal\";\n    }\n    /**\n     * Listen for all requests received by the server in real time.\n     *\n     * This command will create a new connection to Redis and send a\n     * MONITOR command via the new connection in order to avoid disturbing\n     * the current connection.\n     *\n     * @param callback The callback function. If omit, a promise will be returned.\n     * @example\n     * ```js\n     * var redis = new Redis();\n     * redis.monitor(function (err, monitor) {\n     *   // Entering monitoring mode.\n     *   monitor.on('monitor', function (time, args, source, database) {\n     *     console.log(time + \": \" + util.inspect(args));\n     *   });\n     * });\n     *\n     * // supports promise as well as other commands\n     * redis.monitor().then(function (monitor) {\n     *   monitor.on('monitor', function (time, args, source, database) {\n     *     console.log(time + \": \" + util.inspect(args));\n     *   });\n     * });\n     * ```\n     */\n    monitor(callback) {\n        const monitorInstance = this.duplicate({\n            monitor: true,\n            lazyConnect: false,\n        });\n        return (0, standard_as_callback_1.default)(new Promise(function (resolve, reject) {\n            monitorInstance.once(\"error\", reject);\n            monitorInstance.once(\"monitoring\", function () {\n                resolve(monitorInstance);\n            });\n        }), callback);\n    }\n    /**\n     * Send a command to Redis\n     *\n     * This method is used internally and in most cases you should not\n     * use it directly. If you need to send a command that is not supported\n     * by the library, you can use the `call` method:\n     *\n     * ```js\n     * const redis = new Redis();\n     *\n     * redis.call('set', 'foo', 'bar');\n     * // or\n     * redis.call(['set', 'foo', 'bar']);\n     * ```\n     *\n     * @ignore\n     */\n    sendCommand(command, stream) {\n        var _a, _b;\n        if (this.status === \"wait\") {\n            this.connect().catch(lodash_1.noop);\n        }\n        if (this.status === \"end\") {\n            command.reject(new Error(utils_1.CONNECTION_CLOSED_ERROR_MSG));\n            return command.promise;\n        }\n        if (((_a = this.condition) === null || _a === void 0 ? void 0 : _a.subscriber) &&\n            !Command_1.default.checkFlag(\"VALID_IN_SUBSCRIBER_MODE\", command.name)) {\n            command.reject(new Error(\"Connection in subscriber mode, only subscriber commands may be used\"));\n            return command.promise;\n        }\n        if (typeof this.options.commandTimeout === \"number\") {\n            command.setTimeout(this.options.commandTimeout);\n        }\n        let writable = this.status === \"ready\" ||\n            (!stream &&\n                this.status === \"connect\" &&\n                (0, commands_1.exists)(command.name) &&\n                (0, commands_1.hasFlag)(command.name, \"loading\"));\n        if (!this.stream) {\n            writable = false;\n        }\n        else if (!this.stream.writable) {\n            writable = false;\n            // @ts-expect-error\n        }\n        else if (this.stream._writableState && this.stream._writableState.ended) {\n            // TODO: We should be able to remove this as the PR has already been merged.\n            // https://github.com/iojs/io.js/pull/1217\n            writable = false;\n        }\n        if (!writable) {\n            if (!this.options.enableOfflineQueue) {\n                command.reject(new Error(\"Stream isn't writeable and enableOfflineQueue options is false\"));\n                return command.promise;\n            }\n            if (command.name === \"quit\" && this.offlineQueue.length === 0) {\n                this.disconnect();\n                command.resolve(Buffer.from(\"OK\"));\n                return command.promise;\n            }\n            // @ts-expect-error\n            if (debug.enabled) {\n                debug(\"queue command[%s]: %d -> %s(%o)\", this._getDescription(), this.condition.select, command.name, command.args);\n            }\n            this.offlineQueue.push({\n                command: command,\n                stream: stream,\n                select: this.condition.select,\n            });\n        }\n        else {\n            // @ts-expect-error\n            if (debug.enabled) {\n                debug(\"write command[%s]: %d -> %s(%o)\", this._getDescription(), (_b = this.condition) === null || _b === void 0 ? void 0 : _b.select, command.name, command.args);\n            }\n            if (stream) {\n                if (\"isPipeline\" in stream && stream.isPipeline) {\n                    stream.write(command.toWritable(stream.destination.redis.stream));\n                }\n                else {\n                    stream.write(command.toWritable(stream));\n                }\n            }\n            else {\n                this.stream.write(command.toWritable(this.stream));\n            }\n            this.commandQueue.push({\n                command: command,\n                stream: stream,\n                select: this.condition.select,\n            });\n            if (Command_1.default.checkFlag(\"WILL_DISCONNECT\", command.name)) {\n                this.manuallyClosing = true;\n            }\n            if (this.options.socketTimeout !== undefined && this.socketTimeoutTimer === undefined) {\n                this.setSocketTimeout();\n            }\n        }\n        if (command.name === \"select\" && (0, utils_1.isInt)(command.args[0])) {\n            const db = parseInt(command.args[0], 10);\n            if (this.condition.select !== db) {\n                this.condition.select = db;\n                this.emit(\"select\", db);\n                debug(\"switch to db [%d]\", this.condition.select);\n            }\n        }\n        return command.promise;\n    }\n    setSocketTimeout() {\n        this.socketTimeoutTimer = setTimeout(() => {\n            this.stream.destroy(new Error(`Socket timeout. Expecting data, but didn't receive any in ${this.options.socketTimeout}ms.`));\n            this.socketTimeoutTimer = undefined;\n        }, this.options.socketTimeout);\n        // this handler must run after the \"data\" handler in \"DataHandler\"\n        // so that `this.commandQueue.length` will be updated\n        this.stream.once(\"data\", () => {\n            clearTimeout(this.socketTimeoutTimer);\n            this.socketTimeoutTimer = undefined;\n            if (this.commandQueue.length === 0)\n                return;\n            this.setSocketTimeout();\n        });\n    }\n    scanStream(options) {\n        return this.createScanStream(\"scan\", { options });\n    }\n    scanBufferStream(options) {\n        return this.createScanStream(\"scanBuffer\", { options });\n    }\n    sscanStream(key, options) {\n        return this.createScanStream(\"sscan\", { key, options });\n    }\n    sscanBufferStream(key, options) {\n        return this.createScanStream(\"sscanBuffer\", { key, options });\n    }\n    hscanStream(key, options) {\n        return this.createScanStream(\"hscan\", { key, options });\n    }\n    hscanBufferStream(key, options) {\n        return this.createScanStream(\"hscanBuffer\", { key, options });\n    }\n    zscanStream(key, options) {\n        return this.createScanStream(\"zscan\", { key, options });\n    }\n    zscanBufferStream(key, options) {\n        return this.createScanStream(\"zscanBuffer\", { key, options });\n    }\n    /**\n     * Emit only when there's at least one listener.\n     *\n     * @ignore\n     */\n    silentEmit(eventName, arg) {\n        let error;\n        if (eventName === \"error\") {\n            error = arg;\n            if (this.status === \"end\") {\n                return;\n            }\n            if (this.manuallyClosing) {\n                // ignore connection related errors when manually disconnecting\n                if (error instanceof Error &&\n                    (error.message === utils_1.CONNECTION_CLOSED_ERROR_MSG ||\n                        // @ts-expect-error\n                        error.syscall === \"connect\" ||\n                        // @ts-expect-error\n                        error.syscall === \"read\")) {\n                    return;\n                }\n            }\n        }\n        if (this.listeners(eventName).length > 0) {\n            return this.emit.apply(this, arguments);\n        }\n        if (error && error instanceof Error) {\n            console.error(\"[ioredis] Unhandled error event:\", error.stack);\n        }\n        return false;\n    }\n    /**\n     * @ignore\n     */\n    recoverFromFatalError(_commandError, err, options) {\n        this.flushQueue(err, options);\n        this.silentEmit(\"error\", err);\n        this.disconnect(true);\n    }\n    /**\n     * @ignore\n     */\n    handleReconnection(err, item) {\n        var _a;\n        let needReconnect = false;\n        if (this.options.reconnectOnError) {\n            needReconnect = this.options.reconnectOnError(err);\n        }\n        switch (needReconnect) {\n            case 1:\n            case true:\n                if (this.status !== \"reconnecting\") {\n                    this.disconnect(true);\n                }\n                item.command.reject(err);\n                break;\n            case 2:\n                if (this.status !== \"reconnecting\") {\n                    this.disconnect(true);\n                }\n                if (((_a = this.condition) === null || _a === void 0 ? void 0 : _a.select) !== item.select &&\n                    item.command.name !== \"select\") {\n                    this.select(item.select);\n                }\n                // TODO\n                // @ts-expect-error\n                this.sendCommand(item.command);\n                break;\n            default:\n                item.command.reject(err);\n        }\n    }\n    /**\n     * Get description of the connection. Used for debugging.\n     */\n    _getDescription() {\n        let description;\n        if (\"path\" in this.options && this.options.path) {\n            description = this.options.path;\n        }\n        else if (this.stream &&\n            this.stream.remoteAddress &&\n            this.stream.remotePort) {\n            description = this.stream.remoteAddress + \":\" + this.stream.remotePort;\n        }\n        else if (\"host\" in this.options && this.options.host) {\n            description = this.options.host + \":\" + this.options.port;\n        }\n        else {\n            // Unexpected\n            description = \"\";\n        }\n        if (this.options.connectionName) {\n            description += ` (${this.options.connectionName})`;\n        }\n        return description;\n    }\n    resetCommandQueue() {\n        this.commandQueue = new Deque();\n    }\n    resetOfflineQueue() {\n        this.offlineQueue = new Deque();\n    }\n    parseOptions(...args) {\n        const options = {};\n        let isTls = false;\n        for (let i = 0; i < args.length; ++i) {\n            const arg = args[i];\n            if (arg === null || typeof arg === \"undefined\") {\n                continue;\n            }\n            if (typeof arg === \"object\") {\n                (0, lodash_1.defaults)(options, arg);\n            }\n            else if (typeof arg === \"string\") {\n                (0, lodash_1.defaults)(options, (0, utils_1.parseURL)(arg));\n                if (arg.startsWith(\"rediss://\")) {\n                    isTls = true;\n                }\n            }\n            else if (typeof arg === \"number\") {\n                options.port = arg;\n            }\n            else {\n                throw new Error(\"Invalid argument \" + arg);\n            }\n        }\n        if (isTls) {\n            (0, lodash_1.defaults)(options, { tls: true });\n        }\n        (0, lodash_1.defaults)(options, Redis.defaultOptions);\n        if (typeof options.port === \"string\") {\n            options.port = parseInt(options.port, 10);\n        }\n        if (typeof options.db === \"string\") {\n            options.db = parseInt(options.db, 10);\n        }\n        // @ts-expect-error\n        this.options = (0, utils_1.resolveTLSProfile)(options);\n    }\n    /**\n     * Change instance's status\n     */\n    setStatus(status, arg) {\n        // @ts-expect-error\n        if (debug.enabled) {\n            debug(\"status[%s]: %s -> %s\", this._getDescription(), this.status || \"[empty]\", status);\n        }\n        this.status = status;\n        process.nextTick(this.emit.bind(this, status, arg));\n    }\n    createScanStream(command, { key, options = {} }) {\n        return new ScanStream_1.default({\n            objectMode: true,\n            key: key,\n            redis: this,\n            command: command,\n            ...options,\n        });\n    }\n    /**\n     * Flush offline queue and command queue with error.\n     *\n     * @param error The error object to send to the commands\n     * @param options options\n     */\n    flushQueue(error, options) {\n        options = (0, lodash_1.defaults)({}, options, {\n            offlineQueue: true,\n            commandQueue: true,\n        });\n        let item;\n        if (options.offlineQueue) {\n            while ((item = this.offlineQueue.shift())) {\n                item.command.reject(error);\n            }\n        }\n        if (options.commandQueue) {\n            if (this.commandQueue.length > 0) {\n                if (this.stream) {\n                    this.stream.removeAllListeners(\"data\");\n                }\n                while ((item = this.commandQueue.shift())) {\n                    item.command.reject(error);\n                }\n            }\n        }\n    }\n    /**\n     * Check whether Redis has finished loading the persistent data and is able to\n     * process commands.\n     */\n    _readyCheck(callback) {\n        const _this = this;\n        this.info(function (err, res) {\n            if (err) {\n                if (err.message && err.message.includes(\"NOPERM\")) {\n                    console.warn(`Skipping the ready check because INFO command fails: \"${err.message}\". You can disable ready check with \"enableReadyCheck\". More: https://github.com/luin/ioredis/wiki/Disable-ready-check.`);\n                    return callback(null, {});\n                }\n                return callback(err);\n            }\n            if (typeof res !== \"string\") {\n                return callback(null, res);\n            }\n            const info = {};\n            const lines = res.split(\"\\r\\n\");\n            for (let i = 0; i < lines.length; ++i) {\n                const [fieldName, ...fieldValueParts] = lines[i].split(\":\");\n                const fieldValue = fieldValueParts.join(\":\");\n                if (fieldValue) {\n                    info[fieldName] = fieldValue;\n                }\n            }\n            if (!info.loading || info.loading === \"0\") {\n                callback(null, info);\n            }\n            else {\n                const loadingEtaMs = (info.loading_eta_seconds || 1) * 1000;\n                const retryTime = _this.options.maxLoadingRetryTime &&\n                    _this.options.maxLoadingRetryTime < loadingEtaMs\n                    ? _this.options.maxLoadingRetryTime\n                    : loadingEtaMs;\n                debug(\"Redis server still loading, trying again in \" + retryTime + \"ms\");\n                setTimeout(function () {\n                    _this._readyCheck(callback);\n                }, retryTime);\n            }\n        }).catch(lodash_1.noop);\n    }\n}\nRedis.Cluster = cluster_1.default;\nRedis.Command = Command_1.default;\n/**\n * Default options\n */\nRedis.defaultOptions = RedisOptions_1.DEFAULT_REDIS_OPTIONS;\n(0, applyMixin_1.default)(Redis, events_1.EventEmitter);\n(0, transaction_1.addTransactionSupport)(Redis.prototype);\nexports.default = Redis;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}